// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.3 DO NOT EDIT.
package nessus

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// The interface specification for the client above.
type ClientInterface interface {
	// IoV1AccessGroupsList request
	IoV1AccessGroupsList(ctx context.Context, params *IoV1AccessGroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV1AccessGroupsCreate request with any body
	IoV1AccessGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoV1AccessGroupsCreate(ctx context.Context, body IoV1AccessGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV1AccessGroupsListFilters request
	IoV1AccessGroupsListFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV1AccessGroupsListRuleFilters request
	IoV1AccessGroupsListRuleFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV1AccessGroupsDelete request
	IoV1AccessGroupsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV1AccessGroupsDetails request
	IoV1AccessGroupsDetails(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV1AccessGroupsEdit request with any body
	IoV1AccessGroupsEditWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoV1AccessGroupsEdit(ctx context.Context, id string, body IoV1AccessGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetsBulkUpdateAcr request with any body
	AssetsBulkUpdateAcrWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssetsBulkUpdateAcr(ctx context.Context, body AssetsBulkUpdateAcrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetsBulkDelete request with any body
	AssetsBulkDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssetsBulkDelete(ctx context.Context, body AssetsBulkDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetsBulkMove request with any body
	AssetsBulkMoveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssetsBulkMove(ctx context.Context, body AssetsBulkMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VulnerabilitiesImportV2 request with any body
	VulnerabilitiesImportV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VulnerabilitiesImportV2(ctx context.Context, body VulnerabilitiesImportV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetsListAssets request
	AssetsListAssets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportsAssetsRequestExport request with any body
	ExportsAssetsRequestExportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportsAssetsRequestExport(ctx context.Context, body ExportsAssetsRequestExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportsAssetsExportStatusRecent request
	ExportsAssetsExportStatusRecent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportsAssetsExportCancel request
	ExportsAssetsExportCancel(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportsAssetsDownloadChunk request
	ExportsAssetsDownloadChunk(ctx context.Context, exportUuid string, chunkId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportsAssetsExportStatus request
	ExportsAssetsExportStatus(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetsAssetInfo request
	AssetsAssetInfo(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuditLogEvents request
	AuditLogEvents(ctx context.Context, params *AuditLogEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoExportsComplianceCreate request with any body
	IoExportsComplianceCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoExportsComplianceCreate(ctx context.Context, body IoExportsComplianceCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoExportsComplianceCancel request
	IoExportsComplianceCancel(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoExportsComplianceDownload request
	IoExportsComplianceDownload(ctx context.Context, exportUuid string, chunkId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoExportsComplianceStatus request
	IoExportsComplianceStatus(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CredentialsList request
	CredentialsList(ctx context.Context, params *CredentialsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CredentialsCreate request with any body
	CredentialsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CredentialsCreate(ctx context.Context, body CredentialsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CredentialsFileUpload request with any body
	CredentialsFileUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CredentialsListCredentialTypes request
	CredentialsListCredentialTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CredentialsDelete request
	CredentialsDelete(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CredentialsDetails request
	CredentialsDetails(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CredentialsUpdate request with any body
	CredentialsUpdateWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CredentialsUpdate(ctx context.Context, uuid string, body CredentialsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditorPluginDescription request
	EditorPluginDescription(ctx context.Context, policyId int32, familyId int32, pluginId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditorListTemplates request
	EditorListTemplates(ctx context.Context, pType EditorListTemplatesParamsType, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditorTemplateDetails request
	EditorTemplateDetails(ctx context.Context, pType EditorTemplateDetailsParamsType, templateUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditorDetails request
	EditorDetails(ctx context.Context, pType EditorDetailsParamsType, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditorAudits request
	EditorAudits(ctx context.Context, pType EditorAuditsParamsType, objectId int32, fileId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExclusionsList request
	ExclusionsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExclusionsCreate request with any body
	ExclusionsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExclusionsCreate(ctx context.Context, body ExclusionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExclusionsImport request with any body
	ExclusionsImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExclusionsImport(ctx context.Context, body ExclusionsImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExclusionsDelete request
	ExclusionsDelete(ctx context.Context, exclusionId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExclusionsDetails request
	ExclusionsDetails(ctx context.Context, exclusionId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExclusionsEdit request with any body
	ExclusionsEditWithBody(ctx context.Context, exclusionId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExclusionsEdit(ctx context.Context, exclusionId int32, body ExclusionsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileUpload request with any body
	FileUploadWithBody(ctx context.Context, params *FileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoFiltersCredentialsList request
	IoFiltersCredentialsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoFiltersAgentsList request
	IoFiltersAgentsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoFiltersScanList request
	IoFiltersScanList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoFiltersScanHistoryList request
	IoFiltersScanHistoryList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoFiltersAssetsList request
	IoFiltersAssetsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoFiltersAssetsListV2 request with any body
	IoFiltersAssetsListV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoFiltersAssetsListV2(ctx context.Context, body IoFiltersAssetsListV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoFiltersVulnerabilitiesWorkbenchList request
	IoFiltersVulnerabilitiesWorkbenchList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoFiltersVulnerabilitiesWorkbenchListV2 request with any body
	IoFiltersVulnerabilitiesWorkbenchListV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoFiltersVulnerabilitiesWorkbenchListV2(ctx context.Context, body IoFiltersVulnerabilitiesWorkbenchListV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FoldersList request
	FoldersList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FoldersCreate request with any body
	FoldersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FoldersCreate(ctx context.Context, body FoldersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FoldersDelete request
	FoldersDelete(ctx context.Context, folderId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FoldersEdit request with any body
	FoldersEditWithBody(ctx context.Context, folderId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FoldersEdit(ctx context.Context, folderId int32, body FoldersEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetsListImportJobs request
	AssetsListImportJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetsImportJobInfo request
	AssetsImportJobInfo(ctx context.Context, assetImportJobUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssetsImport request with any body
	AssetsImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssetsImport(ctx context.Context, body AssetsImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VulnerabilitiesImport request with any body
	VulnerabilitiesImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VulnerabilitiesImport(ctx context.Context, body VulnerabilitiesImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworksList request
	NetworksList(ctx context.Context, params *NetworksListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworksCreate request with any body
	NetworksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NetworksCreate(ctx context.Context, body NetworksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworksDelete request
	NetworksDelete(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworksDetails request
	NetworksDetails(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworksUpdate request with any body
	NetworksUpdateWithBody(ctx context.Context, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NetworksUpdate(ctx context.Context, networkId string, body NetworksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworksListAssignableScanners request
	NetworksListAssignableScanners(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoNetworksAssetCountDetails request
	IoNetworksAssetCountDetails(ctx context.Context, networkId string, numDays int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworksListScanners request
	NetworksListScanners(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworksAssignScannerBulk request with any body
	NetworksAssignScannerBulkWithBody(ctx context.Context, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NetworksAssignScannerBulk(ctx context.Context, networkId string, body NetworksAssignScannerBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworksAssignScanner request
	NetworksAssignScanner(ctx context.Context, networkId string, scannerUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermissionsList request
	PermissionsList(ctx context.Context, objectType PermissionsListParamsObjectType, objectId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermissionsChange request with any body
	PermissionsChangeWithBody(ctx context.Context, objectType PermissionsChangeParamsObjectType, objectId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermissionsChange(ctx context.Context, objectType PermissionsChangeParamsObjectType, objectId int32, body PermissionsChangeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoPluginsFamiliesList request
	IoPluginsFamiliesList(ctx context.Context, params *IoPluginsFamiliesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoPluginsFamilyDetails request
	IoPluginsFamilyDetails(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoPluginsList request
	IoPluginsList(ctx context.Context, params *IoPluginsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoPluginsDetails request
	IoPluginsDetails(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PoliciesList request
	PoliciesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PoliciesCreate request with any body
	PoliciesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PoliciesCreate(ctx context.Context, body PoliciesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PoliciesImport request with any body
	PoliciesImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PoliciesImport(ctx context.Context, body PoliciesImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PoliciesDelete request
	PoliciesDelete(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PoliciesDetails request
	PoliciesDetails(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PoliciesConfigure request
	PoliciesConfigure(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PoliciesCopy request
	PoliciesCopy(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PoliciesExport request
	PoliciesExport(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannerGroupsList request
	ScannerGroupsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannerGroupsCreate request with any body
	ScannerGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScannerGroupsCreate(ctx context.Context, body ScannerGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannerGroupsDelete request
	ScannerGroupsDelete(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannerGroupsDetails request
	ScannerGroupsDetails(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannerGroupsEdit request with any body
	ScannerGroupsEditWithBody(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScannerGroupsEdit(ctx context.Context, groupId int32, body ScannerGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoScannerGroupsListRoutes request
	IoScannerGroupsListRoutes(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoScannerGroupsUpdateRoutes request with any body
	IoScannerGroupsUpdateRoutesWithBody(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoScannerGroupsUpdateRoutes(ctx context.Context, groupId int32, body IoScannerGroupsUpdateRoutesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannerGroupsListScanners request
	ScannerGroupsListScanners(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannerGroupsDeleteScanner request
	ScannerGroupsDeleteScanner(ctx context.Context, groupId int32, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannerGroupsAddScanner request
	ScannerGroupsAddScanner(ctx context.Context, groupId int32, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannersList request
	ScannersList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkAddAgents request with any body
	BulkAddAgentsWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkAddAgents(ctx context.Context, groupId string, body BulkAddAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoAgentBulkOperationsGroupDirective request with any body
	IoAgentBulkOperationsGroupDirectiveWithBody(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoAgentBulkOperationsGroupDirective(ctx context.Context, groupId int32, body IoAgentBulkOperationsGroupDirectiveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkRemoveAgents request with any body
	BulkRemoveAgentsWithBody(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkRemoveAgents(ctx context.Context, groupId int32, body BulkRemoveAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkTaskAgentGroupStatus request
	BulkTaskAgentGroupStatus(ctx context.Context, groupId int32, taskUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoAgentBulkOperationsAddToNetwork request with any body
	IoAgentBulkOperationsAddToNetworkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoAgentBulkOperationsAddToNetwork(ctx context.Context, body IoAgentBulkOperationsAddToNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoAgentBulkOperationsDirective request with any body
	IoAgentBulkOperationsDirectiveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoAgentBulkOperationsDirective(ctx context.Context, body IoAgentBulkOperationsDirectiveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoAgentBulkOperationsRemoveFromNetwork request with any body
	IoAgentBulkOperationsRemoveFromNetworkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoAgentBulkOperationsRemoveFromNetwork(ctx context.Context, body IoAgentBulkOperationsRemoveFromNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUnlinkAgents request with any body
	BulkUnlinkAgentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUnlinkAgents(ctx context.Context, body BulkUnlinkAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkTaskAgentStatus request
	BulkTaskAgentStatus(ctx context.Context, taskUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannersDelete request
	ScannersDelete(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannersDetails request
	ScannersDetails(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannersEdit request with any body
	ScannersEditWithBody(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScannersEdit(ctx context.Context, scannerId int32, body ScannersEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentGroupsList request
	AgentGroupsList(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentGroupsCreate request with any body
	AgentGroupsCreateWithBody(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AgentGroupsCreate(ctx context.Context, scannerId int32, body AgentGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentGroupListAgents request
	AgentGroupListAgents(ctx context.Context, scannerId int32, agentGroupId int32, params *AgentGroupListAgentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentGroupsDelete request
	AgentGroupsDelete(ctx context.Context, scannerId int32, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentGroupsDetails request
	AgentGroupsDetails(ctx context.Context, scannerId int32, groupId int32, params *AgentGroupsDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentGroupsConfigure request with any body
	AgentGroupsConfigureWithBody(ctx context.Context, scannerId int32, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AgentGroupsConfigure(ctx context.Context, scannerId int32, groupId int32, body AgentGroupsConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentGroupsDeleteAgent request
	AgentGroupsDeleteAgent(ctx context.Context, scannerId int32, groupId int32, agentId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentGroupsAddAgent request
	AgentGroupsAddAgent(ctx context.Context, scannerId int32, groupId int32, agentId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentsList request
	AgentsList(ctx context.Context, scannerId int32, params *AgentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentConfigDetails request
	AgentConfigDetails(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentConfigEdit request with any body
	AgentConfigEditWithBody(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AgentConfigEdit(ctx context.Context, scannerId int32, body AgentConfigEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentExclusionsList request
	AgentExclusionsList(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentExclusionsCreate request with any body
	AgentExclusionsCreateWithBody(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AgentExclusionsCreate(ctx context.Context, scannerId int32, body AgentExclusionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentExclusionsDelete request
	AgentExclusionsDelete(ctx context.Context, scannerId int32, exclusionId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentExclusionsDetails request
	AgentExclusionsDetails(ctx context.Context, scannerId int32, exclusionId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentExclusionsEdit request with any body
	AgentExclusionsEditWithBody(ctx context.Context, scannerId int32, exclusionId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AgentExclusionsEdit(ctx context.Context, scannerId int32, exclusionId int32, body AgentExclusionsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentsDelete request
	AgentsDelete(ctx context.Context, scannerId int32, agentId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AgentsGet request
	AgentsGet(ctx context.Context, scannerId int32, agentId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannersGetAwsTargets request
	ScannersGetAwsTargets(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannersGetScannerKey request
	ScannersGetScannerKey(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannersToggleLinkState request with any body
	ScannersToggleLinkStateWithBody(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScannersToggleLinkState(ctx context.Context, scannerId int32, body ScannersToggleLinkStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannersGetScans request
	ScannersGetScans(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannersControlScans request with any body
	ScannersControlScansWithBody(ctx context.Context, scannerId int32, scanUuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScannersControlScans(ctx context.Context, scannerId int32, scanUuid string, body ScannersControlScansJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansList request
	ScansList(ctx context.Context, params *ScansListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansCreate request with any body
	ScansCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScansCreate(ctx context.Context, body ScansCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoScansCheckAutoTargets request with any body
	IoScansCheckAutoTargetsWithBody(ctx context.Context, params *IoScansCheckAutoTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoScansCheckAutoTargets(ctx context.Context, params *IoScansCheckAutoTargetsParams, body IoScansCheckAutoTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansImport request with any body
	ScansImportWithBody(ctx context.Context, params *ScansImportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScansImport(ctx context.Context, params *ScansImportParams, body ScansImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoScansRemediationList request
	IoScansRemediationList(ctx context.Context, params *IoScansRemediationListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoScansRemediationCreate request with any body
	IoScansRemediationCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoScansRemediationCreate(ctx context.Context, body IoScansRemediationCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansTimezones request
	ScansTimezones(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansDelete request
	ScansDelete(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansDetails request
	ScansDetails(ctx context.Context, scanId string, params *ScansDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansConfigure request with any body
	ScansConfigureWithBody(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScansConfigure(ctx context.Context, scanId string, body ScansConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansAttachments request
	ScansAttachments(ctx context.Context, scanId string, attachmentId string, params *ScansAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansCopy request with any body
	ScansCopyWithBody(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScansCopy(ctx context.Context, scanId string, body ScansCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoScansCredentialsConvert request with any body
	IoScansCredentialsConvertWithBody(ctx context.Context, scanId int, credentialsId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoScansCredentialsConvert(ctx context.Context, scanId int, credentialsId int, body IoScansCredentialsConvertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansExportRequest request with any body
	ScansExportRequestWithBody(ctx context.Context, scanId string, params *ScansExportRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScansExportRequest(ctx context.Context, scanId string, params *ScansExportRequestParams, body ScansExportRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansExportDownload request
	ScansExportDownload(ctx context.Context, scanId string, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansExportStatus request
	ScansExportStatus(ctx context.Context, scanId string, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansHistory request
	ScansHistory(ctx context.Context, scanId string, params *ScansHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansDeleteHistory request
	ScansDeleteHistory(ctx context.Context, scanId string, historyId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansHistoryDetails request
	ScansHistoryDetails(ctx context.Context, scanId string, historyUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansGetLatestStatus request
	ScansGetLatestStatus(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansLaunch request with any body
	ScansLaunchWithBody(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScansLaunch(ctx context.Context, scanId string, body ScansLaunchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansPause request
	ScansPause(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansResume request
	ScansResume(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansSchedule request with any body
	ScansScheduleWithBody(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScansSchedule(ctx context.Context, scanId string, body ScansScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansReadStatus request with any body
	ScansReadStatusWithBody(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScansReadStatus(ctx context.Context, scanId string, body ScansReadStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansStop request
	ScansStop(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansHostDetails request
	ScansHostDetails(ctx context.Context, scanUuid string, hostId int32, params *ScansHostDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScansPluginOutput request
	ScansPluginOutput(ctx context.Context, scanUuid string, hostId int32, pluginId int32, params *ScansPluginOutputParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServerProperties request
	ServerProperties(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServerStatus request
	ServerStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsAssignAssetTags request with any body
	TagsAssignAssetTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsAssignAssetTags(ctx context.Context, body TagsAssignAssetTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsListAssetFilters request
	TagsListAssetFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsListAssetTags request
	TagsListAssetTags(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsListTagCategories request
	TagsListTagCategories(ctx context.Context, params *TagsListTagCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsCreateTagCategory request with any body
	TagsCreateTagCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsCreateTagCategory(ctx context.Context, body TagsCreateTagCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsDeleteTagCategory request
	TagsDeleteTagCategory(ctx context.Context, categoryUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsTagCategoryDetails request
	TagsTagCategoryDetails(ctx context.Context, categoryUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsEditTagCategory request with any body
	TagsEditTagCategoryWithBody(ctx context.Context, categoryUuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsEditTagCategory(ctx context.Context, categoryUuid string, body TagsEditTagCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsListTagValues request
	TagsListTagValues(ctx context.Context, params *TagsListTagValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsCreateTagValue request with any body
	TagsCreateTagValueWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsCreateTagValue(ctx context.Context, body TagsCreateTagValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsDeleteTagValuesBulk request with any body
	TagsDeleteTagValuesBulkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsDeleteTagValuesBulk(ctx context.Context, body TagsDeleteTagValuesBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsDeleteTagValue request
	TagsDeleteTagValue(ctx context.Context, valueUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsTagValueDetails request
	TagsTagValueDetails(ctx context.Context, valueUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TagsUpdateTagValue request with any body
	TagsUpdateTagValueWithBody(ctx context.Context, valueUuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TagsUpdateTagValue(ctx context.Context, valueUuid string, body TagsUpdateTagValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TargetGroupsList request
	TargetGroupsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TargetGroupsCreate request with any body
	TargetGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TargetGroupsCreate(ctx context.Context, body TargetGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TargetGroupsDelete request
	TargetGroupsDelete(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TargetGroupsDetails request
	TargetGroupsDetails(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TargetGroupsEdit request with any body
	TargetGroupsEditWithBody(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TargetGroupsEdit(ctx context.Context, groupId int32, body TargetGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV2AccessGroupsList request
	IoV2AccessGroupsList(ctx context.Context, params *IoV2AccessGroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV2AccessGroupsCreate request with any body
	IoV2AccessGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoV2AccessGroupsCreate(ctx context.Context, body IoV2AccessGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV2AccessGroupsListFilters request
	IoV2AccessGroupsListFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV2AccessGroupsListRuleFilters request
	IoV2AccessGroupsListRuleFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV2AccessGroupsDelete request
	IoV2AccessGroupsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV2AccessGroupsDetails request
	IoV2AccessGroupsDetails(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IoV2AccessGroupsEdit request with any body
	IoV2AccessGroupsEditWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IoV2AccessGroupsEdit(ctx context.Context, id string, body IoV2AccessGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportsVulnsRequestExport request with any body
	ExportsVulnsRequestExportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportsVulnsRequestExport(ctx context.Context, body ExportsVulnsRequestExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportsVulnsExportStatusRecent request
	ExportsVulnsExportStatusRecent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportsVulnsExportCancel request
	ExportsVulnsExportCancel(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportsVulnsDownloadChunk request
	ExportsVulnsDownloadChunk(ctx context.Context, exportUuid string, chunkId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportsVulnsExportStatus request
	ExportsVulnsExportStatus(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesAssets request
	WorkbenchesAssets(ctx context.Context, params *WorkbenchesAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesAssetsVulnerabilities request
	WorkbenchesAssetsVulnerabilities(ctx context.Context, params *WorkbenchesAssetsVulnerabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesAssetInfo request
	WorkbenchesAssetInfo(ctx context.Context, assetId string, params *WorkbenchesAssetInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesAssetVulnerabilities request
	WorkbenchesAssetVulnerabilities(ctx context.Context, assetId string, params *WorkbenchesAssetVulnerabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesAssetVulnerabilityInfo request
	WorkbenchesAssetVulnerabilityInfo(ctx context.Context, assetId string, pluginId int32, params *WorkbenchesAssetVulnerabilityInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesAssetVulnerabilityOutput request
	WorkbenchesAssetVulnerabilityOutput(ctx context.Context, assetId string, pluginId int32, params *WorkbenchesAssetVulnerabilityOutputParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesAssetsDelete request
	WorkbenchesAssetsDelete(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesAssetsActivity request
	WorkbenchesAssetsActivity(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesExportRequest request
	WorkbenchesExportRequest(ctx context.Context, params *WorkbenchesExportRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesExportDownload request
	WorkbenchesExportDownload(ctx context.Context, fileId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesExportStatus request
	WorkbenchesExportStatus(ctx context.Context, fileId int32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesVulnerabilities request
	WorkbenchesVulnerabilities(ctx context.Context, params *WorkbenchesVulnerabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesVulnerabilityInfo request
	WorkbenchesVulnerabilityInfo(ctx context.Context, pluginId int32, params *WorkbenchesVulnerabilityInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkbenchesVulnerabilityOutput request
	WorkbenchesVulnerabilityOutput(ctx context.Context, pluginId int32, params *WorkbenchesVulnerabilityOutputParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) IoV1AccessGroupsList(ctx context.Context, params *IoV1AccessGroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV1AccessGroupsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV1AccessGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV1AccessGroupsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV1AccessGroupsCreate(ctx context.Context, body IoV1AccessGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV1AccessGroupsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV1AccessGroupsListFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV1AccessGroupsListFiltersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV1AccessGroupsListRuleFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV1AccessGroupsListRuleFiltersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV1AccessGroupsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV1AccessGroupsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV1AccessGroupsDetails(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV1AccessGroupsDetailsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV1AccessGroupsEditWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV1AccessGroupsEditRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV1AccessGroupsEdit(ctx context.Context, id string, body IoV1AccessGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV1AccessGroupsEditRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AssetsBulkUpdateAcrWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetsBulkUpdateAcrRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AssetsBulkUpdateAcr(ctx context.Context, body AssetsBulkUpdateAcrJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetsBulkUpdateAcrRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AssetsBulkDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetsBulkDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AssetsBulkDelete(ctx context.Context, body AssetsBulkDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetsBulkDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AssetsBulkMoveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetsBulkMoveRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AssetsBulkMove(ctx context.Context, body AssetsBulkMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetsBulkMoveRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) VulnerabilitiesImportV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVulnerabilitiesImportV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) VulnerabilitiesImportV2(ctx context.Context, body VulnerabilitiesImportV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVulnerabilitiesImportV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AssetsListAssets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetsListAssetsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExportsAssetsRequestExportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportsAssetsRequestExportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExportsAssetsRequestExport(ctx context.Context, body ExportsAssetsRequestExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportsAssetsRequestExportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExportsAssetsExportStatusRecent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportsAssetsExportStatusRecentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExportsAssetsExportCancel(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportsAssetsExportCancelRequest(c.Server, exportUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExportsAssetsDownloadChunk(ctx context.Context, exportUuid string, chunkId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportsAssetsDownloadChunkRequest(c.Server, exportUuid, chunkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExportsAssetsExportStatus(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportsAssetsExportStatusRequest(c.Server, exportUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AssetsAssetInfo(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetsAssetInfoRequest(c.Server, assetUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AuditLogEvents(ctx context.Context, params *AuditLogEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuditLogEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoExportsComplianceCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoExportsComplianceCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoExportsComplianceCreate(ctx context.Context, body IoExportsComplianceCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoExportsComplianceCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoExportsComplianceCancel(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoExportsComplianceCancelRequest(c.Server, exportUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoExportsComplianceDownload(ctx context.Context, exportUuid string, chunkId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoExportsComplianceDownloadRequest(c.Server, exportUuid, chunkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoExportsComplianceStatus(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoExportsComplianceStatusRequest(c.Server, exportUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) CredentialsList(ctx context.Context, params *CredentialsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) CredentialsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) CredentialsCreate(ctx context.Context, body CredentialsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) CredentialsFileUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialsFileUploadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) CredentialsListCredentialTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialsListCredentialTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) CredentialsDelete(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialsDeleteRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) CredentialsDetails(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialsDetailsRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) CredentialsUpdateWithBody(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialsUpdateRequestWithBody(c.Server, uuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) CredentialsUpdate(ctx context.Context, uuid string, body CredentialsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCredentialsUpdateRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) EditorPluginDescription(ctx context.Context, policyId int32, familyId int32, pluginId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditorPluginDescriptionRequest(c.Server, policyId, familyId, pluginId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) EditorListTemplates(ctx context.Context, pType EditorListTemplatesParamsType, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditorListTemplatesRequest(c.Server, pType)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) EditorTemplateDetails(ctx context.Context, pType EditorTemplateDetailsParamsType, templateUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditorTemplateDetailsRequest(c.Server, pType, templateUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) EditorDetails(ctx context.Context, pType EditorDetailsParamsType, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditorDetailsRequest(c.Server, pType, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) EditorAudits(ctx context.Context, pType EditorAuditsParamsType, objectId int32, fileId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditorAuditsRequest(c.Server, pType, objectId, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExclusionsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExclusionsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExclusionsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExclusionsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExclusionsCreate(ctx context.Context, body ExclusionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExclusionsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExclusionsImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExclusionsImportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExclusionsImport(ctx context.Context, body ExclusionsImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExclusionsImportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExclusionsDelete(ctx context.Context, exclusionId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExclusionsDeleteRequest(c.Server, exclusionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExclusionsDetails(ctx context.Context, exclusionId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExclusionsDetailsRequest(c.Server, exclusionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExclusionsEditWithBody(ctx context.Context, exclusionId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExclusionsEditRequestWithBody(c.Server, exclusionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExclusionsEdit(ctx context.Context, exclusionId int32, body ExclusionsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExclusionsEditRequest(c.Server, exclusionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) FileUploadWithBody(ctx context.Context, params *FileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileUploadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoFiltersCredentialsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoFiltersCredentialsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoFiltersAgentsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoFiltersAgentsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoFiltersScanList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoFiltersScanListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoFiltersScanHistoryList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoFiltersScanHistoryListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoFiltersAssetsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoFiltersAssetsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoFiltersAssetsListV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoFiltersAssetsListV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoFiltersAssetsListV2(ctx context.Context, body IoFiltersAssetsListV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoFiltersAssetsListV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoFiltersVulnerabilitiesWorkbenchList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoFiltersVulnerabilitiesWorkbenchListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoFiltersVulnerabilitiesWorkbenchListV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoFiltersVulnerabilitiesWorkbenchListV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoFiltersVulnerabilitiesWorkbenchListV2(ctx context.Context, body IoFiltersVulnerabilitiesWorkbenchListV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoFiltersVulnerabilitiesWorkbenchListV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) FoldersList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFoldersListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) FoldersCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFoldersCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) FoldersCreate(ctx context.Context, body FoldersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFoldersCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) FoldersDelete(ctx context.Context, folderId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFoldersDeleteRequest(c.Server, folderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) FoldersEditWithBody(ctx context.Context, folderId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFoldersEditRequestWithBody(c.Server, folderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) FoldersEdit(ctx context.Context, folderId int32, body FoldersEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFoldersEditRequest(c.Server, folderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AssetsListImportJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetsListImportJobsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AssetsImportJobInfo(ctx context.Context, assetImportJobUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetsImportJobInfoRequest(c.Server, assetImportJobUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AssetsImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetsImportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AssetsImport(ctx context.Context, body AssetsImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssetsImportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) VulnerabilitiesImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVulnerabilitiesImportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) VulnerabilitiesImport(ctx context.Context, body VulnerabilitiesImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVulnerabilitiesImportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) NetworksList(ctx context.Context, params *NetworksListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworksListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) NetworksCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworksCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) NetworksCreate(ctx context.Context, body NetworksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworksCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) NetworksDelete(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworksDeleteRequest(c.Server, networkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) NetworksDetails(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworksDetailsRequest(c.Server, networkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) NetworksUpdateWithBody(ctx context.Context, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworksUpdateRequestWithBody(c.Server, networkId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) NetworksUpdate(ctx context.Context, networkId string, body NetworksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworksUpdateRequest(c.Server, networkId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) NetworksListAssignableScanners(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworksListAssignableScannersRequest(c.Server, networkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoNetworksAssetCountDetails(ctx context.Context, networkId string, numDays int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoNetworksAssetCountDetailsRequest(c.Server, networkId, numDays)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) NetworksListScanners(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworksListScannersRequest(c.Server, networkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) NetworksAssignScannerBulkWithBody(ctx context.Context, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworksAssignScannerBulkRequestWithBody(c.Server, networkId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) NetworksAssignScannerBulk(ctx context.Context, networkId string, body NetworksAssignScannerBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworksAssignScannerBulkRequest(c.Server, networkId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) NetworksAssignScanner(ctx context.Context, networkId string, scannerUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworksAssignScannerRequest(c.Server, networkId, scannerUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PermissionsList(ctx context.Context, objectType PermissionsListParamsObjectType, objectId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermissionsListRequest(c.Server, objectType, objectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PermissionsChangeWithBody(ctx context.Context, objectType PermissionsChangeParamsObjectType, objectId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermissionsChangeRequestWithBody(c.Server, objectType, objectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PermissionsChange(ctx context.Context, objectType PermissionsChangeParamsObjectType, objectId int32, body PermissionsChangeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermissionsChangeRequest(c.Server, objectType, objectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoPluginsFamiliesList(ctx context.Context, params *IoPluginsFamiliesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoPluginsFamiliesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoPluginsFamilyDetails(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoPluginsFamilyDetailsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoPluginsList(ctx context.Context, params *IoPluginsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoPluginsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoPluginsDetails(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoPluginsDetailsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PoliciesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPoliciesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PoliciesCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPoliciesCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PoliciesCreate(ctx context.Context, body PoliciesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPoliciesCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PoliciesImportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPoliciesImportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PoliciesImport(ctx context.Context, body PoliciesImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPoliciesImportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PoliciesDelete(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPoliciesDeleteRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PoliciesDetails(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPoliciesDetailsRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PoliciesConfigure(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPoliciesConfigureRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PoliciesCopy(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPoliciesCopyRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) PoliciesExport(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPoliciesExportRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannerGroupsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannerGroupsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannerGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannerGroupsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannerGroupsCreate(ctx context.Context, body ScannerGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannerGroupsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannerGroupsDelete(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannerGroupsDeleteRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannerGroupsDetails(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannerGroupsDetailsRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannerGroupsEditWithBody(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannerGroupsEditRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannerGroupsEdit(ctx context.Context, groupId int32, body ScannerGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannerGroupsEditRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoScannerGroupsListRoutes(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoScannerGroupsListRoutesRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoScannerGroupsUpdateRoutesWithBody(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoScannerGroupsUpdateRoutesRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoScannerGroupsUpdateRoutes(ctx context.Context, groupId int32, body IoScannerGroupsUpdateRoutesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoScannerGroupsUpdateRoutesRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannerGroupsListScanners(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannerGroupsListScannersRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannerGroupsDeleteScanner(ctx context.Context, groupId int32, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannerGroupsDeleteScannerRequest(c.Server, groupId, scannerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannerGroupsAddScanner(ctx context.Context, groupId int32, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannerGroupsAddScannerRequest(c.Server, groupId, scannerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannersList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannersListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) BulkAddAgentsWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddAgentsRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) BulkAddAgents(ctx context.Context, groupId string, body BulkAddAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkAddAgentsRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoAgentBulkOperationsGroupDirectiveWithBody(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoAgentBulkOperationsGroupDirectiveRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoAgentBulkOperationsGroupDirective(ctx context.Context, groupId int32, body IoAgentBulkOperationsGroupDirectiveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoAgentBulkOperationsGroupDirectiveRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) BulkRemoveAgentsWithBody(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkRemoveAgentsRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) BulkRemoveAgents(ctx context.Context, groupId int32, body BulkRemoveAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkRemoveAgentsRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) BulkTaskAgentGroupStatus(ctx context.Context, groupId int32, taskUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkTaskAgentGroupStatusRequest(c.Server, groupId, taskUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoAgentBulkOperationsAddToNetworkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoAgentBulkOperationsAddToNetworkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoAgentBulkOperationsAddToNetwork(ctx context.Context, body IoAgentBulkOperationsAddToNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoAgentBulkOperationsAddToNetworkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoAgentBulkOperationsDirectiveWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoAgentBulkOperationsDirectiveRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoAgentBulkOperationsDirective(ctx context.Context, body IoAgentBulkOperationsDirectiveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoAgentBulkOperationsDirectiveRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoAgentBulkOperationsRemoveFromNetworkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoAgentBulkOperationsRemoveFromNetworkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoAgentBulkOperationsRemoveFromNetwork(ctx context.Context, body IoAgentBulkOperationsRemoveFromNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoAgentBulkOperationsRemoveFromNetworkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) BulkUnlinkAgentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUnlinkAgentsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) BulkUnlinkAgents(ctx context.Context, body BulkUnlinkAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUnlinkAgentsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) BulkTaskAgentStatus(ctx context.Context, taskUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkTaskAgentStatusRequest(c.Server, taskUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannersDelete(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannersDeleteRequest(c.Server, scannerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannersDetails(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannersDetailsRequest(c.Server, scannerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannersEditWithBody(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannersEditRequestWithBody(c.Server, scannerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannersEdit(ctx context.Context, scannerId int32, body ScannersEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannersEditRequest(c.Server, scannerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentGroupsList(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentGroupsListRequest(c.Server, scannerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentGroupsCreateWithBody(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentGroupsCreateRequestWithBody(c.Server, scannerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentGroupsCreate(ctx context.Context, scannerId int32, body AgentGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentGroupsCreateRequest(c.Server, scannerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentGroupListAgents(ctx context.Context, scannerId int32, agentGroupId int32, params *AgentGroupListAgentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentGroupListAgentsRequest(c.Server, scannerId, agentGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentGroupsDelete(ctx context.Context, scannerId int32, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentGroupsDeleteRequest(c.Server, scannerId, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentGroupsDetails(ctx context.Context, scannerId int32, groupId int32, params *AgentGroupsDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentGroupsDetailsRequest(c.Server, scannerId, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentGroupsConfigureWithBody(ctx context.Context, scannerId int32, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentGroupsConfigureRequestWithBody(c.Server, scannerId, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentGroupsConfigure(ctx context.Context, scannerId int32, groupId int32, body AgentGroupsConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentGroupsConfigureRequest(c.Server, scannerId, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentGroupsDeleteAgent(ctx context.Context, scannerId int32, groupId int32, agentId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentGroupsDeleteAgentRequest(c.Server, scannerId, groupId, agentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentGroupsAddAgent(ctx context.Context, scannerId int32, groupId int32, agentId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentGroupsAddAgentRequest(c.Server, scannerId, groupId, agentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentsList(ctx context.Context, scannerId int32, params *AgentsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentsListRequest(c.Server, scannerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentConfigDetails(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentConfigDetailsRequest(c.Server, scannerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentConfigEditWithBody(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentConfigEditRequestWithBody(c.Server, scannerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentConfigEdit(ctx context.Context, scannerId int32, body AgentConfigEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentConfigEditRequest(c.Server, scannerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentExclusionsList(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentExclusionsListRequest(c.Server, scannerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentExclusionsCreateWithBody(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentExclusionsCreateRequestWithBody(c.Server, scannerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentExclusionsCreate(ctx context.Context, scannerId int32, body AgentExclusionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentExclusionsCreateRequest(c.Server, scannerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentExclusionsDelete(ctx context.Context, scannerId int32, exclusionId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentExclusionsDeleteRequest(c.Server, scannerId, exclusionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentExclusionsDetails(ctx context.Context, scannerId int32, exclusionId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentExclusionsDetailsRequest(c.Server, scannerId, exclusionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentExclusionsEditWithBody(ctx context.Context, scannerId int32, exclusionId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentExclusionsEditRequestWithBody(c.Server, scannerId, exclusionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentExclusionsEdit(ctx context.Context, scannerId int32, exclusionId int32, body AgentExclusionsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentExclusionsEditRequest(c.Server, scannerId, exclusionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentsDelete(ctx context.Context, scannerId int32, agentId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentsDeleteRequest(c.Server, scannerId, agentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) AgentsGet(ctx context.Context, scannerId int32, agentId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAgentsGetRequest(c.Server, scannerId, agentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannersGetAwsTargets(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannersGetAwsTargetsRequest(c.Server, scannerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannersGetScannerKey(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannersGetScannerKeyRequest(c.Server, scannerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannersToggleLinkStateWithBody(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannersToggleLinkStateRequestWithBody(c.Server, scannerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannersToggleLinkState(ctx context.Context, scannerId int32, body ScannersToggleLinkStateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannersToggleLinkStateRequest(c.Server, scannerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannersGetScans(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannersGetScansRequest(c.Server, scannerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannersControlScansWithBody(ctx context.Context, scannerId int32, scanUuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannersControlScansRequestWithBody(c.Server, scannerId, scanUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScannersControlScans(ctx context.Context, scannerId int32, scanUuid string, body ScannersControlScansJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannersControlScansRequest(c.Server, scannerId, scanUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansList(ctx context.Context, params *ScansListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansCreate(ctx context.Context, body ScansCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoScansCheckAutoTargetsWithBody(ctx context.Context, params *IoScansCheckAutoTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoScansCheckAutoTargetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoScansCheckAutoTargets(ctx context.Context, params *IoScansCheckAutoTargetsParams, body IoScansCheckAutoTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoScansCheckAutoTargetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansImportWithBody(ctx context.Context, params *ScansImportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansImportRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansImport(ctx context.Context, params *ScansImportParams, body ScansImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansImportRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoScansRemediationList(ctx context.Context, params *IoScansRemediationListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoScansRemediationListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoScansRemediationCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoScansRemediationCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoScansRemediationCreate(ctx context.Context, body IoScansRemediationCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoScansRemediationCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansTimezones(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansTimezonesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansDelete(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansDeleteRequest(c.Server, scanId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansDetails(ctx context.Context, scanId string, params *ScansDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansDetailsRequest(c.Server, scanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansConfigureWithBody(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansConfigureRequestWithBody(c.Server, scanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansConfigure(ctx context.Context, scanId string, body ScansConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansConfigureRequest(c.Server, scanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansAttachments(ctx context.Context, scanId string, attachmentId string, params *ScansAttachmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansAttachmentsRequest(c.Server, scanId, attachmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansCopyWithBody(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansCopyRequestWithBody(c.Server, scanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansCopy(ctx context.Context, scanId string, body ScansCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansCopyRequest(c.Server, scanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoScansCredentialsConvertWithBody(ctx context.Context, scanId int, credentialsId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoScansCredentialsConvertRequestWithBody(c.Server, scanId, credentialsId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoScansCredentialsConvert(ctx context.Context, scanId int, credentialsId int, body IoScansCredentialsConvertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoScansCredentialsConvertRequest(c.Server, scanId, credentialsId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansExportRequestWithBody(ctx context.Context, scanId string, params *ScansExportRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansExportRequestRequestWithBody(c.Server, scanId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansExportRequest(ctx context.Context, scanId string, params *ScansExportRequestParams, body ScansExportRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansExportRequestRequest(c.Server, scanId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansExportDownload(ctx context.Context, scanId string, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansExportDownloadRequest(c.Server, scanId, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansExportStatus(ctx context.Context, scanId string, fileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansExportStatusRequest(c.Server, scanId, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansHistory(ctx context.Context, scanId string, params *ScansHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansHistoryRequest(c.Server, scanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansDeleteHistory(ctx context.Context, scanId string, historyId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansDeleteHistoryRequest(c.Server, scanId, historyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansHistoryDetails(ctx context.Context, scanId string, historyUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansHistoryDetailsRequest(c.Server, scanId, historyUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansGetLatestStatus(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansGetLatestStatusRequest(c.Server, scanId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansLaunchWithBody(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansLaunchRequestWithBody(c.Server, scanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansLaunch(ctx context.Context, scanId string, body ScansLaunchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansLaunchRequest(c.Server, scanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansPause(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansPauseRequest(c.Server, scanId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansResume(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansResumeRequest(c.Server, scanId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansScheduleWithBody(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansScheduleRequestWithBody(c.Server, scanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansSchedule(ctx context.Context, scanId string, body ScansScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansScheduleRequest(c.Server, scanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansReadStatusWithBody(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansReadStatusRequestWithBody(c.Server, scanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansReadStatus(ctx context.Context, scanId string, body ScansReadStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansReadStatusRequest(c.Server, scanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansStop(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansStopRequest(c.Server, scanId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansHostDetails(ctx context.Context, scanUuid string, hostId int32, params *ScansHostDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansHostDetailsRequest(c.Server, scanUuid, hostId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ScansPluginOutput(ctx context.Context, scanUuid string, hostId int32, pluginId int32, params *ScansPluginOutputParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScansPluginOutputRequest(c.Server, scanUuid, hostId, pluginId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ServerProperties(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServerPropertiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ServerStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServerStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsAssignAssetTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsAssignAssetTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsAssignAssetTags(ctx context.Context, body TagsAssignAssetTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsAssignAssetTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsListAssetFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsListAssetFiltersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsListAssetTags(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsListAssetTagsRequest(c.Server, assetUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsListTagCategories(ctx context.Context, params *TagsListTagCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsListTagCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsCreateTagCategoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsCreateTagCategoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsCreateTagCategory(ctx context.Context, body TagsCreateTagCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsCreateTagCategoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsDeleteTagCategory(ctx context.Context, categoryUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsDeleteTagCategoryRequest(c.Server, categoryUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsTagCategoryDetails(ctx context.Context, categoryUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsTagCategoryDetailsRequest(c.Server, categoryUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsEditTagCategoryWithBody(ctx context.Context, categoryUuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsEditTagCategoryRequestWithBody(c.Server, categoryUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsEditTagCategory(ctx context.Context, categoryUuid string, body TagsEditTagCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsEditTagCategoryRequest(c.Server, categoryUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsListTagValues(ctx context.Context, params *TagsListTagValuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsListTagValuesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsCreateTagValueWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsCreateTagValueRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsCreateTagValue(ctx context.Context, body TagsCreateTagValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsCreateTagValueRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsDeleteTagValuesBulkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsDeleteTagValuesBulkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsDeleteTagValuesBulk(ctx context.Context, body TagsDeleteTagValuesBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsDeleteTagValuesBulkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsDeleteTagValue(ctx context.Context, valueUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsDeleteTagValueRequest(c.Server, valueUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsTagValueDetails(ctx context.Context, valueUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsTagValueDetailsRequest(c.Server, valueUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsUpdateTagValueWithBody(ctx context.Context, valueUuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsUpdateTagValueRequestWithBody(c.Server, valueUuid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TagsUpdateTagValue(ctx context.Context, valueUuid string, body TagsUpdateTagValueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTagsUpdateTagValueRequest(c.Server, valueUuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TargetGroupsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTargetGroupsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TargetGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTargetGroupsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TargetGroupsCreate(ctx context.Context, body TargetGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTargetGroupsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TargetGroupsDelete(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTargetGroupsDeleteRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TargetGroupsDetails(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTargetGroupsDetailsRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TargetGroupsEditWithBody(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTargetGroupsEditRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) TargetGroupsEdit(ctx context.Context, groupId int32, body TargetGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTargetGroupsEditRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV2AccessGroupsList(ctx context.Context, params *IoV2AccessGroupsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV2AccessGroupsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV2AccessGroupsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV2AccessGroupsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV2AccessGroupsCreate(ctx context.Context, body IoV2AccessGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV2AccessGroupsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV2AccessGroupsListFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV2AccessGroupsListFiltersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV2AccessGroupsListRuleFilters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV2AccessGroupsListRuleFiltersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV2AccessGroupsDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV2AccessGroupsDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV2AccessGroupsDetails(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV2AccessGroupsDetailsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV2AccessGroupsEditWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV2AccessGroupsEditRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) IoV2AccessGroupsEdit(ctx context.Context, id string, body IoV2AccessGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIoV2AccessGroupsEditRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExportsVulnsRequestExportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportsVulnsRequestExportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExportsVulnsRequestExport(ctx context.Context, body ExportsVulnsRequestExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportsVulnsRequestExportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExportsVulnsExportStatusRecent(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportsVulnsExportStatusRecentRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExportsVulnsExportCancel(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportsVulnsExportCancelRequest(c.Server, exportUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExportsVulnsDownloadChunk(ctx context.Context, exportUuid string, chunkId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportsVulnsDownloadChunkRequest(c.Server, exportUuid, chunkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) ExportsVulnsExportStatus(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportsVulnsExportStatusRequest(c.Server, exportUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesAssets(ctx context.Context, params *WorkbenchesAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesAssetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesAssetsVulnerabilities(ctx context.Context, params *WorkbenchesAssetsVulnerabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesAssetsVulnerabilitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesAssetInfo(ctx context.Context, assetId string, params *WorkbenchesAssetInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesAssetInfoRequest(c.Server, assetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesAssetVulnerabilities(ctx context.Context, assetId string, params *WorkbenchesAssetVulnerabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesAssetVulnerabilitiesRequest(c.Server, assetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesAssetVulnerabilityInfo(ctx context.Context, assetId string, pluginId int32, params *WorkbenchesAssetVulnerabilityInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesAssetVulnerabilityInfoRequest(c.Server, assetId, pluginId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesAssetVulnerabilityOutput(ctx context.Context, assetId string, pluginId int32, params *WorkbenchesAssetVulnerabilityOutputParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesAssetVulnerabilityOutputRequest(c.Server, assetId, pluginId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesAssetsDelete(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesAssetsDeleteRequest(c.Server, assetUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesAssetsActivity(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesAssetsActivityRequest(c.Server, assetUuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesExportRequest(ctx context.Context, params *WorkbenchesExportRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesExportRequestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesExportDownload(ctx context.Context, fileId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesExportDownloadRequest(c.Server, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesExportStatus(ctx context.Context, fileId int32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesExportStatusRequest(c.Server, fileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesVulnerabilities(ctx context.Context, params *WorkbenchesVulnerabilitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesVulnerabilitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesVulnerabilityInfo(ctx context.Context, pluginId int32, params *WorkbenchesVulnerabilityInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesVulnerabilityInfoRequest(c.Server, pluginId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

func (c *Client) WorkbenchesVulnerabilityOutput(ctx context.Context, pluginId int32, params *WorkbenchesVulnerabilityOutputParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkbenchesVulnerabilityOutputRequest(c.Server, pluginId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Do(req)
}

// NewIoV1AccessGroupsListRequest generates requests for IoV1AccessGroupsList
func NewIoV1AccessGroupsListRequest(server string, params *IoV1AccessGroupsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.F != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f", runtime.ParamLocationQuery, *params.F); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ft != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ft", runtime.ParamLocationQuery, *params.Ft); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.W != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "w", runtime.ParamLocationQuery, *params.W); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Wf != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wf", runtime.ParamLocationQuery, *params.Wf); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Fullypopulateresponse != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fullypopulateresponse", runtime.ParamLocationQuery, *params.Fullypopulateresponse); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoV1AccessGroupsCreateRequest calls the generic IoV1AccessGroupsCreate builder with application/json body
func NewIoV1AccessGroupsCreateRequest(server string, body IoV1AccessGroupsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoV1AccessGroupsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewIoV1AccessGroupsCreateRequestWithBody generates requests for IoV1AccessGroupsCreate with any type of body
func NewIoV1AccessGroupsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoV1AccessGroupsListFiltersRequest generates requests for IoV1AccessGroupsListFilters
func NewIoV1AccessGroupsListFiltersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-groups/filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoV1AccessGroupsListRuleFiltersRequest generates requests for IoV1AccessGroupsListRuleFilters
func NewIoV1AccessGroupsListRuleFiltersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-groups/rules/filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoV1AccessGroupsDeleteRequest generates requests for IoV1AccessGroupsDelete
func NewIoV1AccessGroupsDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoV1AccessGroupsDetailsRequest generates requests for IoV1AccessGroupsDetails
func NewIoV1AccessGroupsDetailsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoV1AccessGroupsEditRequest calls the generic IoV1AccessGroupsEdit builder with application/json body
func NewIoV1AccessGroupsEditRequest(server string, id string, body IoV1AccessGroupsEditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoV1AccessGroupsEditRequestWithBody(server, id, "application/json", bodyReader)
}

// NewIoV1AccessGroupsEditRequestWithBody generates requests for IoV1AccessGroupsEdit with any type of body
func NewIoV1AccessGroupsEditRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/access-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssetsBulkUpdateAcrRequest calls the generic AssetsBulkUpdateAcr builder with application/json body
func NewAssetsBulkUpdateAcrRequest(server string, body AssetsBulkUpdateAcrJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssetsBulkUpdateAcrRequestWithBody(server, "application/json", bodyReader)
}

// NewAssetsBulkUpdateAcrRequestWithBody generates requests for AssetsBulkUpdateAcr with any type of body
func NewAssetsBulkUpdateAcrRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/assets/bulk-jobs/acr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssetsBulkDeleteRequest calls the generic AssetsBulkDelete builder with application/json body
func NewAssetsBulkDeleteRequest(server string, body AssetsBulkDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssetsBulkDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewAssetsBulkDeleteRequestWithBody generates requests for AssetsBulkDelete with any type of body
func NewAssetsBulkDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/assets/bulk-jobs/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssetsBulkMoveRequest calls the generic AssetsBulkMove builder with application/json body
func NewAssetsBulkMoveRequest(server string, body AssetsBulkMoveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssetsBulkMoveRequestWithBody(server, "application/json", bodyReader)
}

// NewAssetsBulkMoveRequestWithBody generates requests for AssetsBulkMove with any type of body
func NewAssetsBulkMoveRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/assets/bulk-jobs/move-to-network")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVulnerabilitiesImportV2Request calls the generic VulnerabilitiesImportV2 builder with application/json body
func NewVulnerabilitiesImportV2Request(server string, body VulnerabilitiesImportV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVulnerabilitiesImportV2RequestWithBody(server, "application/json", bodyReader)
}

// NewVulnerabilitiesImportV2RequestWithBody generates requests for VulnerabilitiesImportV2 with any type of body
func NewVulnerabilitiesImportV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/vulnerabilities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssetsListAssetsRequest generates requests for AssetsListAssets
func NewAssetsListAssetsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportsAssetsRequestExportRequest calls the generic ExportsAssetsRequestExport builder with application/json body
func NewExportsAssetsRequestExportRequest(server string, body ExportsAssetsRequestExportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportsAssetsRequestExportRequestWithBody(server, "application/json", bodyReader)
}

// NewExportsAssetsRequestExportRequestWithBody generates requests for ExportsAssetsRequestExport with any type of body
func NewExportsAssetsRequestExportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExportsAssetsExportStatusRecentRequest generates requests for ExportsAssetsExportStatusRecent
func NewExportsAssetsExportStatusRecentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/export/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportsAssetsExportCancelRequest generates requests for ExportsAssetsExportCancel
func NewExportsAssetsExportCancelRequest(server string, exportUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "export_uuid", runtime.ParamLocationPath, exportUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/export/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportsAssetsDownloadChunkRequest generates requests for ExportsAssetsDownloadChunk
func NewExportsAssetsDownloadChunkRequest(server string, exportUuid string, chunkId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "export_uuid", runtime.ParamLocationPath, exportUuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "chunk_id", runtime.ParamLocationPath, chunkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/export/%s/chunks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportsAssetsExportStatusRequest generates requests for ExportsAssetsExportStatus
func NewExportsAssetsExportStatusRequest(server string, exportUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "export_uuid", runtime.ParamLocationPath, exportUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/export/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetsAssetInfoRequest generates requests for AssetsAssetInfo
func NewAssetsAssetInfoRequest(server string, assetUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_uuid", runtime.ParamLocationPath, assetUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuditLogEventsRequest generates requests for AuditLogEvents
func NewAuditLogEventsRequest(server string, params *AuditLogEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audit-log/v1/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.F != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f", runtime.ParamLocationQuery, *params.F); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoExportsComplianceCreateRequest calls the generic IoExportsComplianceCreate builder with application/json body
func NewIoExportsComplianceCreateRequest(server string, body IoExportsComplianceCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoExportsComplianceCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewIoExportsComplianceCreateRequestWithBody generates requests for IoExportsComplianceCreate with any type of body
func NewIoExportsComplianceCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compliance/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoExportsComplianceCancelRequest generates requests for IoExportsComplianceCancel
func NewIoExportsComplianceCancelRequest(server string, exportUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "export_uuid", runtime.ParamLocationPath, exportUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compliance/export/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoExportsComplianceDownloadRequest generates requests for IoExportsComplianceDownload
func NewIoExportsComplianceDownloadRequest(server string, exportUuid string, chunkId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "export_uuid", runtime.ParamLocationPath, exportUuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "chunk_id", runtime.ParamLocationPath, chunkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compliance/export/%s/chunks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoExportsComplianceStatusRequest generates requests for IoExportsComplianceStatus
func NewIoExportsComplianceStatusRequest(server string, exportUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "export_uuid", runtime.ParamLocationPath, exportUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/compliance/export/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCredentialsListRequest generates requests for CredentialsList
func NewCredentialsListRequest(server string, params *CredentialsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.F != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f", runtime.ParamLocationQuery, *params.F); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ft != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ft", runtime.ParamLocationQuery, *params.Ft); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ReferrerOwnerUuid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "referrer_owner_uuid", runtime.ParamLocationQuery, *params.ReferrerOwnerUuid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCredentialsCreateRequest calls the generic CredentialsCreate builder with application/json body
func NewCredentialsCreateRequest(server string, body CredentialsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCredentialsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewCredentialsCreateRequestWithBody generates requests for CredentialsCreate with any type of body
func NewCredentialsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCredentialsFileUploadRequestWithBody generates requests for CredentialsFileUpload with any type of body
func NewCredentialsFileUploadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credentials/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCredentialsListCredentialTypesRequest generates requests for CredentialsListCredentialTypes
func NewCredentialsListCredentialTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credentials/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCredentialsDeleteRequest generates requests for CredentialsDelete
func NewCredentialsDeleteRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credentials/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCredentialsDetailsRequest generates requests for CredentialsDetails
func NewCredentialsDetailsRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credentials/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCredentialsUpdateRequest calls the generic CredentialsUpdate builder with application/json body
func NewCredentialsUpdateRequest(server string, uuid string, body CredentialsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCredentialsUpdateRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewCredentialsUpdateRequestWithBody generates requests for CredentialsUpdate with any type of body
func NewCredentialsUpdateRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credentials/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditorPluginDescriptionRequest generates requests for EditorPluginDescription
func NewEditorPluginDescriptionRequest(server string, policyId int32, familyId int32, pluginId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "family_id", runtime.ParamLocationPath, familyId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editor/policy/%s/families/%s/plugins/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditorListTemplatesRequest generates requests for EditorListTemplates
func NewEditorListTemplatesRequest(server string, pType EditorListTemplatesParamsType) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editor/%s/templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditorTemplateDetailsRequest generates requests for EditorTemplateDetails
func NewEditorTemplateDetailsRequest(server string, pType EditorTemplateDetailsParamsType, templateUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_uuid", runtime.ParamLocationPath, templateUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editor/%s/templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditorDetailsRequest generates requests for EditorDetails
func NewEditorDetailsRequest(server string, pType EditorDetailsParamsType, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editor/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditorAuditsRequest generates requests for EditorAudits
func NewEditorAuditsRequest(server string, pType EditorAuditsParamsType, objectId int32, fileId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/editor/%s/%s/audits/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExclusionsListRequest generates requests for ExclusionsList
func NewExclusionsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exclusions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExclusionsCreateRequest calls the generic ExclusionsCreate builder with application/json body
func NewExclusionsCreateRequest(server string, body ExclusionsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExclusionsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewExclusionsCreateRequestWithBody generates requests for ExclusionsCreate with any type of body
func NewExclusionsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exclusions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExclusionsImportRequest calls the generic ExclusionsImport builder with application/json body
func NewExclusionsImportRequest(server string, body ExclusionsImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExclusionsImportRequestWithBody(server, "application/json", bodyReader)
}

// NewExclusionsImportRequestWithBody generates requests for ExclusionsImport with any type of body
func NewExclusionsImportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exclusions/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExclusionsDeleteRequest generates requests for ExclusionsDelete
func NewExclusionsDeleteRequest(server string, exclusionId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "exclusion_id", runtime.ParamLocationPath, exclusionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exclusions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExclusionsDetailsRequest generates requests for ExclusionsDetails
func NewExclusionsDetailsRequest(server string, exclusionId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "exclusion_id", runtime.ParamLocationPath, exclusionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exclusions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExclusionsEditRequest calls the generic ExclusionsEdit builder with application/json body
func NewExclusionsEditRequest(server string, exclusionId int32, body ExclusionsEditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExclusionsEditRequestWithBody(server, exclusionId, "application/json", bodyReader)
}

// NewExclusionsEditRequestWithBody generates requests for ExclusionsEdit with any type of body
func NewExclusionsEditRequestWithBody(server string, exclusionId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "exclusion_id", runtime.ParamLocationPath, exclusionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exclusions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFileUploadRequestWithBody generates requests for FileUpload with any type of body
func NewFileUploadRequestWithBody(server string, params *FileUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/file/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NoEnc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "no_enc", runtime.ParamLocationQuery, *params.NoEnc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoFiltersCredentialsListRequest generates requests for IoFiltersCredentialsList
func NewIoFiltersCredentialsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoFiltersAgentsListRequest generates requests for IoFiltersAgentsList
func NewIoFiltersAgentsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/scans/agents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoFiltersScanListRequest generates requests for IoFiltersScanList
func NewIoFiltersScanListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/scans/reports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoFiltersScanHistoryListRequest generates requests for IoFiltersScanHistoryList
func NewIoFiltersScanHistoryListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/scans/reports/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoFiltersAssetsListRequest generates requests for IoFiltersAssetsList
func NewIoFiltersAssetsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/workbenches/assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoFiltersAssetsListV2Request calls the generic IoFiltersAssetsListV2 builder with application/json body
func NewIoFiltersAssetsListV2Request(server string, body IoFiltersAssetsListV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoFiltersAssetsListV2RequestWithBody(server, "application/json", bodyReader)
}

// NewIoFiltersAssetsListV2RequestWithBody generates requests for IoFiltersAssetsListV2 with any type of body
func NewIoFiltersAssetsListV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/workbenches/assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoFiltersVulnerabilitiesWorkbenchListRequest generates requests for IoFiltersVulnerabilitiesWorkbenchList
func NewIoFiltersVulnerabilitiesWorkbenchListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/workbenches/vulnerabilities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoFiltersVulnerabilitiesWorkbenchListV2Request calls the generic IoFiltersVulnerabilitiesWorkbenchListV2 builder with application/json body
func NewIoFiltersVulnerabilitiesWorkbenchListV2Request(server string, body IoFiltersVulnerabilitiesWorkbenchListV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoFiltersVulnerabilitiesWorkbenchListV2RequestWithBody(server, "application/json", bodyReader)
}

// NewIoFiltersVulnerabilitiesWorkbenchListV2RequestWithBody generates requests for IoFiltersVulnerabilitiesWorkbenchListV2 with any type of body
func NewIoFiltersVulnerabilitiesWorkbenchListV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/filters/workbenches/vulnerabilities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFoldersListRequest generates requests for FoldersList
func NewFoldersListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFoldersCreateRequest calls the generic FoldersCreate builder with application/json body
func NewFoldersCreateRequest(server string, body FoldersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFoldersCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewFoldersCreateRequestWithBody generates requests for FoldersCreate with any type of body
func NewFoldersCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFoldersDeleteRequest generates requests for FoldersDelete
func NewFoldersDeleteRequest(server string, folderId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "folder_id", runtime.ParamLocationPath, folderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFoldersEditRequest calls the generic FoldersEdit builder with application/json body
func NewFoldersEditRequest(server string, folderId int32, body FoldersEditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFoldersEditRequestWithBody(server, folderId, "application/json", bodyReader)
}

// NewFoldersEditRequestWithBody generates requests for FoldersEdit with any type of body
func NewFoldersEditRequestWithBody(server string, folderId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "folder_id", runtime.ParamLocationPath, folderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAssetsListImportJobsRequest generates requests for AssetsListImportJobs
func NewAssetsListImportJobsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/import/asset-jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetsImportJobInfoRequest generates requests for AssetsImportJobInfo
func NewAssetsImportJobInfoRequest(server string, assetImportJobUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_import_job_uuid", runtime.ParamLocationPath, assetImportJobUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/import/asset-jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssetsImportRequest calls the generic AssetsImport builder with application/json body
func NewAssetsImportRequest(server string, body AssetsImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssetsImportRequestWithBody(server, "application/json", bodyReader)
}

// NewAssetsImportRequestWithBody generates requests for AssetsImport with any type of body
func NewAssetsImportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/import/assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVulnerabilitiesImportRequest calls the generic VulnerabilitiesImport builder with application/json body
func NewVulnerabilitiesImportRequest(server string, body VulnerabilitiesImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVulnerabilitiesImportRequestWithBody(server, "application/json", bodyReader)
}

// NewVulnerabilitiesImportRequestWithBody generates requests for VulnerabilitiesImport with any type of body
func NewVulnerabilitiesImportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/import/vulnerabilities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNetworksListRequest generates requests for NetworksList
func NewNetworksListRequest(server string, params *NetworksListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.F != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f", runtime.ParamLocationQuery, *params.F); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ft != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ft", runtime.ParamLocationQuery, *params.Ft); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeDeleted != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeDeleted", runtime.ParamLocationQuery, *params.IncludeDeleted); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNetworksCreateRequest calls the generic NetworksCreate builder with application/json body
func NewNetworksCreateRequest(server string, body NetworksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNetworksCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewNetworksCreateRequestWithBody generates requests for NetworksCreate with any type of body
func NewNetworksCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNetworksDeleteRequest generates requests for NetworksDelete
func NewNetworksDeleteRequest(server string, networkId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network_id", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNetworksDetailsRequest generates requests for NetworksDetails
func NewNetworksDetailsRequest(server string, networkId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network_id", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNetworksUpdateRequest calls the generic NetworksUpdate builder with application/json body
func NewNetworksUpdateRequest(server string, networkId string, body NetworksUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNetworksUpdateRequestWithBody(server, networkId, "application/json", bodyReader)
}

// NewNetworksUpdateRequestWithBody generates requests for NetworksUpdate with any type of body
func NewNetworksUpdateRequestWithBody(server string, networkId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network_id", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNetworksListAssignableScannersRequest generates requests for NetworksListAssignableScanners
func NewNetworksListAssignableScannersRequest(server string, networkId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network_id", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks/%s/assignable-scanners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoNetworksAssetCountDetailsRequest generates requests for IoNetworksAssetCountDetails
func NewIoNetworksAssetCountDetailsRequest(server string, networkId string, numDays int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network_id", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "num_days", runtime.ParamLocationPath, numDays)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks/%s/counts/assets-not-seen-in/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNetworksListScannersRequest generates requests for NetworksListScanners
func NewNetworksListScannersRequest(server string, networkId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network_id", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks/%s/scanners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNetworksAssignScannerBulkRequest calls the generic NetworksAssignScannerBulk builder with application/json body
func NewNetworksAssignScannerBulkRequest(server string, networkId string, body NetworksAssignScannerBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNetworksAssignScannerBulkRequestWithBody(server, networkId, "application/json", bodyReader)
}

// NewNetworksAssignScannerBulkRequestWithBody generates requests for NetworksAssignScannerBulk with any type of body
func NewNetworksAssignScannerBulkRequestWithBody(server string, networkId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network_id", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks/%s/scanners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNetworksAssignScannerRequest generates requests for NetworksAssignScanner
func NewNetworksAssignScannerRequest(server string, networkId string, scannerUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network_id", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scanner_uuid", runtime.ParamLocationPath, scannerUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks/%s/scanners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPermissionsListRequest generates requests for PermissionsList
func NewPermissionsListRequest(server string, objectType PermissionsListParamsObjectType, objectId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_type", runtime.ParamLocationPath, objectType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/permissions/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPermissionsChangeRequest calls the generic PermissionsChange builder with application/json body
func NewPermissionsChangeRequest(server string, objectType PermissionsChangeParamsObjectType, objectId int32, body PermissionsChangeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermissionsChangeRequestWithBody(server, objectType, objectId, "application/json", bodyReader)
}

// NewPermissionsChangeRequestWithBody generates requests for PermissionsChange with any type of body
func NewPermissionsChangeRequestWithBody(server string, objectType PermissionsChangeParamsObjectType, objectId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_type", runtime.ParamLocationPath, objectType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/permissions/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoPluginsFamiliesListRequest generates requests for IoPluginsFamiliesList
func NewIoPluginsFamiliesListRequest(server string, params *IoPluginsFamiliesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/families")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.All != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all", runtime.ParamLocationQuery, *params.All); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoPluginsFamilyDetailsRequest generates requests for IoPluginsFamilyDetails
func NewIoPluginsFamilyDetailsRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/families/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoPluginsListRequest generates requests for IoPluginsList
func NewIoPluginsListRequest(server string, params *IoPluginsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/plugin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.LastUpdated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_updated", runtime.ParamLocationQuery, *params.LastUpdated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoPluginsDetailsRequest generates requests for IoPluginsDetails
func NewIoPluginsDetailsRequest(server string, id int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plugins/plugin/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPoliciesListRequest generates requests for PoliciesList
func NewPoliciesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPoliciesCreateRequest calls the generic PoliciesCreate builder with application/json body
func NewPoliciesCreateRequest(server string, body PoliciesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPoliciesCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPoliciesCreateRequestWithBody generates requests for PoliciesCreate with any type of body
func NewPoliciesCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPoliciesImportRequest calls the generic PoliciesImport builder with application/json body
func NewPoliciesImportRequest(server string, body PoliciesImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPoliciesImportRequestWithBody(server, "application/json", bodyReader)
}

// NewPoliciesImportRequestWithBody generates requests for PoliciesImport with any type of body
func NewPoliciesImportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPoliciesDeleteRequest generates requests for PoliciesDelete
func NewPoliciesDeleteRequest(server string, policyId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPoliciesDetailsRequest generates requests for PoliciesDetails
func NewPoliciesDetailsRequest(server string, policyId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPoliciesConfigureRequest generates requests for PoliciesConfigure
func NewPoliciesConfigureRequest(server string, policyId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPoliciesCopyRequest generates requests for PoliciesCopy
func NewPoliciesCopyRequest(server string, policyId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s/copy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPoliciesExportRequest generates requests for PoliciesExport
func NewPoliciesExportRequest(server string, policyId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy_id", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/policies/%s/export", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannerGroupsListRequest generates requests for ScannerGroupsList
func NewScannerGroupsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanner-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannerGroupsCreateRequest calls the generic ScannerGroupsCreate builder with application/json body
func NewScannerGroupsCreateRequest(server string, body ScannerGroupsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScannerGroupsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewScannerGroupsCreateRequestWithBody generates requests for ScannerGroupsCreate with any type of body
func NewScannerGroupsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanner-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScannerGroupsDeleteRequest generates requests for ScannerGroupsDelete
func NewScannerGroupsDeleteRequest(server string, groupId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanner-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannerGroupsDetailsRequest generates requests for ScannerGroupsDetails
func NewScannerGroupsDetailsRequest(server string, groupId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanner-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannerGroupsEditRequest calls the generic ScannerGroupsEdit builder with application/json body
func NewScannerGroupsEditRequest(server string, groupId int32, body ScannerGroupsEditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScannerGroupsEditRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewScannerGroupsEditRequestWithBody generates requests for ScannerGroupsEdit with any type of body
func NewScannerGroupsEditRequestWithBody(server string, groupId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanner-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoScannerGroupsListRoutesRequest generates requests for IoScannerGroupsListRoutes
func NewIoScannerGroupsListRoutesRequest(server string, groupId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanner-groups/%s/routes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoScannerGroupsUpdateRoutesRequest calls the generic IoScannerGroupsUpdateRoutes builder with application/json body
func NewIoScannerGroupsUpdateRoutesRequest(server string, groupId int32, body IoScannerGroupsUpdateRoutesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoScannerGroupsUpdateRoutesRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewIoScannerGroupsUpdateRoutesRequestWithBody generates requests for IoScannerGroupsUpdateRoutes with any type of body
func NewIoScannerGroupsUpdateRoutesRequestWithBody(server string, groupId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanner-groups/%s/routes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScannerGroupsListScannersRequest generates requests for ScannerGroupsListScanners
func NewScannerGroupsListScannersRequest(server string, groupId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanner-groups/%s/scanners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannerGroupsDeleteScannerRequest generates requests for ScannerGroupsDeleteScanner
func NewScannerGroupsDeleteScannerRequest(server string, groupId int32, scannerId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanner-groups/%s/scanners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannerGroupsAddScannerRequest generates requests for ScannerGroupsAddScanner
func NewScannerGroupsAddScannerRequest(server string, groupId int32, scannerId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanner-groups/%s/scanners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannersListRequest generates requests for ScannersList
func NewScannersListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkAddAgentsRequest calls the generic BulkAddAgents builder with application/json body
func NewBulkAddAgentsRequest(server string, groupId string, body BulkAddAgentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkAddAgentsRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewBulkAddAgentsRequestWithBody generates requests for BulkAddAgents with any type of body
func NewBulkAddAgentsRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/null/agent-groups/%s/agents/_bulk/add", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoAgentBulkOperationsGroupDirectiveRequest calls the generic IoAgentBulkOperationsGroupDirective builder with application/json body
func NewIoAgentBulkOperationsGroupDirectiveRequest(server string, groupId int32, body IoAgentBulkOperationsGroupDirectiveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoAgentBulkOperationsGroupDirectiveRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewIoAgentBulkOperationsGroupDirectiveRequestWithBody generates requests for IoAgentBulkOperationsGroupDirective with any type of body
func NewIoAgentBulkOperationsGroupDirectiveRequestWithBody(server string, groupId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/null/agent-groups/%s/agents/_bulk/directive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkRemoveAgentsRequest calls the generic BulkRemoveAgents builder with application/json body
func NewBulkRemoveAgentsRequest(server string, groupId int32, body BulkRemoveAgentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkRemoveAgentsRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewBulkRemoveAgentsRequestWithBody generates requests for BulkRemoveAgents with any type of body
func NewBulkRemoveAgentsRequestWithBody(server string, groupId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/null/agent-groups/%s/agents/_bulk/remove", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkTaskAgentGroupStatusRequest generates requests for BulkTaskAgentGroupStatus
func NewBulkTaskAgentGroupStatusRequest(server string, groupId int32, taskUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "task_uuid", runtime.ParamLocationPath, taskUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/null/agent-groups/%s/agents/_bulk/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoAgentBulkOperationsAddToNetworkRequest calls the generic IoAgentBulkOperationsAddToNetwork builder with application/json body
func NewIoAgentBulkOperationsAddToNetworkRequest(server string, body IoAgentBulkOperationsAddToNetworkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoAgentBulkOperationsAddToNetworkRequestWithBody(server, "application/json", bodyReader)
}

// NewIoAgentBulkOperationsAddToNetworkRequestWithBody generates requests for IoAgentBulkOperationsAddToNetwork with any type of body
func NewIoAgentBulkOperationsAddToNetworkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/null/agents/_bulk/addToNetwork")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoAgentBulkOperationsDirectiveRequest calls the generic IoAgentBulkOperationsDirective builder with application/json body
func NewIoAgentBulkOperationsDirectiveRequest(server string, body IoAgentBulkOperationsDirectiveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoAgentBulkOperationsDirectiveRequestWithBody(server, "application/json", bodyReader)
}

// NewIoAgentBulkOperationsDirectiveRequestWithBody generates requests for IoAgentBulkOperationsDirective with any type of body
func NewIoAgentBulkOperationsDirectiveRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/null/agents/_bulk/directive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoAgentBulkOperationsRemoveFromNetworkRequest calls the generic IoAgentBulkOperationsRemoveFromNetwork builder with application/json body
func NewIoAgentBulkOperationsRemoveFromNetworkRequest(server string, body IoAgentBulkOperationsRemoveFromNetworkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoAgentBulkOperationsRemoveFromNetworkRequestWithBody(server, "application/json", bodyReader)
}

// NewIoAgentBulkOperationsRemoveFromNetworkRequestWithBody generates requests for IoAgentBulkOperationsRemoveFromNetwork with any type of body
func NewIoAgentBulkOperationsRemoveFromNetworkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/null/agents/_bulk/removeFromNetwork")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkUnlinkAgentsRequest calls the generic BulkUnlinkAgents builder with application/json body
func NewBulkUnlinkAgentsRequest(server string, body BulkUnlinkAgentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUnlinkAgentsRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUnlinkAgentsRequestWithBody generates requests for BulkUnlinkAgents with any type of body
func NewBulkUnlinkAgentsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/null/agents/_bulk/unlink")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkTaskAgentStatusRequest generates requests for BulkTaskAgentStatus
func NewBulkTaskAgentStatusRequest(server string, taskUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_uuid", runtime.ParamLocationPath, taskUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/null/agents/_bulk/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannersDeleteRequest generates requests for ScannersDelete
func NewScannersDeleteRequest(server string, scannerId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannersDetailsRequest generates requests for ScannersDetails
func NewScannersDetailsRequest(server string, scannerId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannersEditRequest calls the generic ScannersEdit builder with application/json body
func NewScannersEditRequest(server string, scannerId int32, body ScannersEditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScannersEditRequestWithBody(server, scannerId, "application/json", bodyReader)
}

// NewScannersEditRequestWithBody generates requests for ScannersEdit with any type of body
func NewScannersEditRequestWithBody(server string, scannerId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAgentGroupsListRequest generates requests for AgentGroupsList
func NewAgentGroupsListRequest(server string, scannerId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agent-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAgentGroupsCreateRequest calls the generic AgentGroupsCreate builder with application/json body
func NewAgentGroupsCreateRequest(server string, scannerId int32, body AgentGroupsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAgentGroupsCreateRequestWithBody(server, scannerId, "application/json", bodyReader)
}

// NewAgentGroupsCreateRequestWithBody generates requests for AgentGroupsCreate with any type of body
func NewAgentGroupsCreateRequestWithBody(server string, scannerId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agent-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAgentGroupListAgentsRequest generates requests for AgentGroupListAgents
func NewAgentGroupListAgentsRequest(server string, scannerId int32, agentGroupId int32, params *AgentGroupListAgentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "agent_group_id", runtime.ParamLocationPath, agentGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agent-groups/%s/agents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.F != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f", runtime.ParamLocationQuery, *params.F); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ft != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ft", runtime.ParamLocationQuery, *params.Ft); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.W != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "w", runtime.ParamLocationQuery, *params.W); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Wf != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wf", runtime.ParamLocationQuery, *params.Wf); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAgentGroupsDeleteRequest generates requests for AgentGroupsDelete
func NewAgentGroupsDeleteRequest(server string, scannerId int32, groupId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agent-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAgentGroupsDetailsRequest generates requests for AgentGroupsDetails
func NewAgentGroupsDetailsRequest(server string, scannerId int32, groupId int32, params *AgentGroupsDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agent-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.F != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f", runtime.ParamLocationQuery, *params.F); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ft != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ft", runtime.ParamLocationQuery, *params.Ft); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.W != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "w", runtime.ParamLocationQuery, *params.W); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Wf != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wf", runtime.ParamLocationQuery, *params.Wf); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAgentGroupsConfigureRequest calls the generic AgentGroupsConfigure builder with application/json body
func NewAgentGroupsConfigureRequest(server string, scannerId int32, groupId int32, body AgentGroupsConfigureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAgentGroupsConfigureRequestWithBody(server, scannerId, groupId, "application/json", bodyReader)
}

// NewAgentGroupsConfigureRequestWithBody generates requests for AgentGroupsConfigure with any type of body
func NewAgentGroupsConfigureRequestWithBody(server string, scannerId int32, groupId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agent-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAgentGroupsDeleteAgentRequest generates requests for AgentGroupsDeleteAgent
func NewAgentGroupsDeleteAgentRequest(server string, scannerId int32, groupId int32, agentId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "agent_id", runtime.ParamLocationPath, agentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agent-groups/%s/agents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAgentGroupsAddAgentRequest generates requests for AgentGroupsAddAgent
func NewAgentGroupsAddAgentRequest(server string, scannerId int32, groupId int32, agentId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "agent_id", runtime.ParamLocationPath, agentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agent-groups/%s/agents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAgentsListRequest generates requests for AgentsList
func NewAgentsListRequest(server string, scannerId int32, params *AgentsListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agents", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.F != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f", runtime.ParamLocationQuery, *params.F); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ft != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ft", runtime.ParamLocationQuery, *params.Ft); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.W != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "w", runtime.ParamLocationQuery, *params.W); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Wf != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wf", runtime.ParamLocationQuery, *params.Wf); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAgentConfigDetailsRequest generates requests for AgentConfigDetails
func NewAgentConfigDetailsRequest(server string, scannerId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agents/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAgentConfigEditRequest calls the generic AgentConfigEdit builder with application/json body
func NewAgentConfigEditRequest(server string, scannerId int32, body AgentConfigEditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAgentConfigEditRequestWithBody(server, scannerId, "application/json", bodyReader)
}

// NewAgentConfigEditRequestWithBody generates requests for AgentConfigEdit with any type of body
func NewAgentConfigEditRequestWithBody(server string, scannerId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agents/config", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAgentExclusionsListRequest generates requests for AgentExclusionsList
func NewAgentExclusionsListRequest(server string, scannerId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agents/exclusions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAgentExclusionsCreateRequest calls the generic AgentExclusionsCreate builder with application/json body
func NewAgentExclusionsCreateRequest(server string, scannerId int32, body AgentExclusionsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAgentExclusionsCreateRequestWithBody(server, scannerId, "application/json", bodyReader)
}

// NewAgentExclusionsCreateRequestWithBody generates requests for AgentExclusionsCreate with any type of body
func NewAgentExclusionsCreateRequestWithBody(server string, scannerId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agents/exclusions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAgentExclusionsDeleteRequest generates requests for AgentExclusionsDelete
func NewAgentExclusionsDeleteRequest(server string, scannerId int32, exclusionId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "exclusion_id", runtime.ParamLocationPath, exclusionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agents/exclusions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAgentExclusionsDetailsRequest generates requests for AgentExclusionsDetails
func NewAgentExclusionsDetailsRequest(server string, scannerId int32, exclusionId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "exclusion_id", runtime.ParamLocationPath, exclusionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agents/exclusions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAgentExclusionsEditRequest calls the generic AgentExclusionsEdit builder with application/json body
func NewAgentExclusionsEditRequest(server string, scannerId int32, exclusionId int32, body AgentExclusionsEditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAgentExclusionsEditRequestWithBody(server, scannerId, exclusionId, "application/json", bodyReader)
}

// NewAgentExclusionsEditRequestWithBody generates requests for AgentExclusionsEdit with any type of body
func NewAgentExclusionsEditRequestWithBody(server string, scannerId int32, exclusionId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "exclusion_id", runtime.ParamLocationPath, exclusionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agents/exclusions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAgentsDeleteRequest generates requests for AgentsDelete
func NewAgentsDeleteRequest(server string, scannerId int32, agentId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "agent_id", runtime.ParamLocationPath, agentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agents/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAgentsGetRequest generates requests for AgentsGet
func NewAgentsGetRequest(server string, scannerId int32, agentId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "agent_id", runtime.ParamLocationPath, agentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/agents/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannersGetAwsTargetsRequest generates requests for ScannersGetAwsTargets
func NewScannersGetAwsTargetsRequest(server string, scannerId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/aws-targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannersGetScannerKeyRequest generates requests for ScannersGetScannerKey
func NewScannersGetScannerKeyRequest(server string, scannerId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/key", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannersToggleLinkStateRequest calls the generic ScannersToggleLinkState builder with application/json body
func NewScannersToggleLinkStateRequest(server string, scannerId int32, body ScannersToggleLinkStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScannersToggleLinkStateRequestWithBody(server, scannerId, "application/json", bodyReader)
}

// NewScannersToggleLinkStateRequestWithBody generates requests for ScannersToggleLinkState with any type of body
func NewScannersToggleLinkStateRequestWithBody(server string, scannerId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/link", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScannersGetScansRequest generates requests for ScannersGetScans
func NewScannersGetScansRequest(server string, scannerId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/scans", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannersControlScansRequest calls the generic ScannersControlScans builder with application/json body
func NewScannersControlScansRequest(server string, scannerId int32, scanUuid string, body ScannersControlScansJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScannersControlScansRequestWithBody(server, scannerId, scanUuid, "application/json", bodyReader)
}

// NewScannersControlScansRequestWithBody generates requests for ScannersControlScans with any type of body
func NewScannersControlScansRequestWithBody(server string, scannerId int32, scanUuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scanner_id", runtime.ParamLocationPath, scannerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scan_uuid", runtime.ParamLocationPath, scanUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scanners/%s/scans/%s/control", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScansListRequest generates requests for ScansList
func NewScansListRequest(server string, params *ScansListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.FolderId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folder_id", runtime.ParamLocationQuery, *params.FolderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.LastModificationDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_modification_date", runtime.ParamLocationQuery, *params.LastModificationDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansCreateRequest calls the generic ScansCreate builder with application/json body
func NewScansCreateRequest(server string, body ScansCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScansCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewScansCreateRequestWithBody generates requests for ScansCreate with any type of body
func NewScansCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoScansCheckAutoTargetsRequest calls the generic IoScansCheckAutoTargets builder with application/json body
func NewIoScansCheckAutoTargetsRequest(server string, params *IoScansCheckAutoTargetsParams, body IoScansCheckAutoTargetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoScansCheckAutoTargetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewIoScansCheckAutoTargetsRequestWithBody generates requests for IoScansCheckAutoTargets with any type of body
func NewIoScansCheckAutoTargetsRequestWithBody(server string, params *IoScansCheckAutoTargetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/check-auto-targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MatchedResourceLimit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "matched_resource_limit", runtime.ParamLocationQuery, *params.MatchedResourceLimit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScansImportRequest calls the generic ScansImport builder with application/json body
func NewScansImportRequest(server string, params *ScansImportParams, body ScansImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScansImportRequestWithBody(server, params, "application/json", bodyReader)
}

// NewScansImportRequestWithBody generates requests for ScansImport with any type of body
func NewScansImportRequestWithBody(server string, params *ScansImportParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeAggregate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_aggregate", runtime.ParamLocationQuery, *params.IncludeAggregate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoScansRemediationListRequest generates requests for IoScansRemediationList
func NewIoScansRemediationListRequest(server string, params *IoScansRemediationListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/remediation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoScansRemediationCreateRequest calls the generic IoScansRemediationCreate builder with application/json body
func NewIoScansRemediationCreateRequest(server string, body IoScansRemediationCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoScansRemediationCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewIoScansRemediationCreateRequestWithBody generates requests for IoScansRemediationCreate with any type of body
func NewIoScansRemediationCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/remediation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScansTimezonesRequest generates requests for ScansTimezones
func NewScansTimezonesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/timezones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansDeleteRequest generates requests for ScansDelete
func NewScansDeleteRequest(server string, scanId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansDetailsRequest generates requests for ScansDetails
func NewScansDetailsRequest(server string, scanId string, params *ScansDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.HistoryId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "history_id", runtime.ParamLocationQuery, *params.HistoryId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.HistoryUuid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "history_uuid", runtime.ParamLocationQuery, *params.HistoryUuid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansConfigureRequest calls the generic ScansConfigure builder with application/json body
func NewScansConfigureRequest(server string, scanId string, body ScansConfigureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScansConfigureRequestWithBody(server, scanId, "application/json", bodyReader)
}

// NewScansConfigureRequestWithBody generates requests for ScansConfigure with any type of body
func NewScansConfigureRequestWithBody(server string, scanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScansAttachmentsRequest generates requests for ScansAttachments
func NewScansAttachmentsRequest(server string, scanId string, attachmentId string, params *ScansAttachmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "attachment_id", runtime.ParamLocationPath, attachmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/attachments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, params.Key); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansCopyRequest calls the generic ScansCopy builder with application/json body
func NewScansCopyRequest(server string, scanId string, body ScansCopyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScansCopyRequestWithBody(server, scanId, "application/json", bodyReader)
}

// NewScansCopyRequestWithBody generates requests for ScansCopy with any type of body
func NewScansCopyRequestWithBody(server string, scanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/copy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoScansCredentialsConvertRequest calls the generic IoScansCredentialsConvert builder with application/json body
func NewIoScansCredentialsConvertRequest(server string, scanId int, credentialsId int, body IoScansCredentialsConvertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoScansCredentialsConvertRequestWithBody(server, scanId, credentialsId, "application/json", bodyReader)
}

// NewIoScansCredentialsConvertRequestWithBody generates requests for IoScansCredentialsConvert with any type of body
func NewIoScansCredentialsConvertRequestWithBody(server string, scanId int, credentialsId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "credentials_id", runtime.ParamLocationPath, credentialsId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/credentials/%s/upgrade", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScansExportRequestRequest calls the generic ScansExportRequest builder with application/json body
func NewScansExportRequestRequest(server string, scanId string, params *ScansExportRequestParams, body ScansExportRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScansExportRequestRequestWithBody(server, scanId, params, "application/json", bodyReader)
}

// NewScansExportRequestRequestWithBody generates requests for ScansExportRequest with any type of body
func NewScansExportRequestRequestWithBody(server string, scanId string, params *ScansExportRequestParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/export", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.HistoryId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "history_id", runtime.ParamLocationQuery, *params.HistoryId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.HistoryUuid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "history_uuid", runtime.ParamLocationQuery, *params.HistoryUuid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScansExportDownloadRequest generates requests for ScansExportDownload
func NewScansExportDownloadRequest(server string, scanId string, fileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/export/%s/download", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansExportStatusRequest generates requests for ScansExportStatus
func NewScansExportStatusRequest(server string, scanId string, fileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/export/%s/status", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansHistoryRequest generates requests for ScansHistory
func NewScansHistoryRequest(server string, scanId string, params *ScansHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansDeleteHistoryRequest generates requests for ScansDeleteHistory
func NewScansDeleteHistoryRequest(server string, scanId string, historyId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "history_id", runtime.ParamLocationPath, historyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/history/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansHistoryDetailsRequest generates requests for ScansHistoryDetails
func NewScansHistoryDetailsRequest(server string, scanId string, historyUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "history_uuid", runtime.ParamLocationPath, historyUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/history/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansGetLatestStatusRequest generates requests for ScansGetLatestStatus
func NewScansGetLatestStatusRequest(server string, scanId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/latest-status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansLaunchRequest calls the generic ScansLaunch builder with application/json body
func NewScansLaunchRequest(server string, scanId string, body ScansLaunchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScansLaunchRequestWithBody(server, scanId, "application/json", bodyReader)
}

// NewScansLaunchRequestWithBody generates requests for ScansLaunch with any type of body
func NewScansLaunchRequestWithBody(server string, scanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/launch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScansPauseRequest generates requests for ScansPause
func NewScansPauseRequest(server string, scanId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/pause", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansResumeRequest generates requests for ScansResume
func NewScansResumeRequest(server string, scanId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/resume", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansScheduleRequest calls the generic ScansSchedule builder with application/json body
func NewScansScheduleRequest(server string, scanId string, body ScansScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScansScheduleRequestWithBody(server, scanId, "application/json", bodyReader)
}

// NewScansScheduleRequestWithBody generates requests for ScansSchedule with any type of body
func NewScansScheduleRequestWithBody(server string, scanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScansReadStatusRequest calls the generic ScansReadStatus builder with application/json body
func NewScansReadStatusRequest(server string, scanId string, body ScansReadStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScansReadStatusRequestWithBody(server, scanId, "application/json", bodyReader)
}

// NewScansReadStatusRequestWithBody generates requests for ScansReadStatus with any type of body
func NewScansReadStatusRequestWithBody(server string, scanId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScansStopRequest generates requests for ScansStop
func NewScansStopRequest(server string, scanId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_id", runtime.ParamLocationPath, scanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansHostDetailsRequest generates requests for ScansHostDetails
func NewScansHostDetailsRequest(server string, scanUuid string, hostId int32, params *ScansHostDetailsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_uuid", runtime.ParamLocationPath, scanUuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "host_id", runtime.ParamLocationPath, hostId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/hosts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.HistoryId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "history_id", runtime.ParamLocationQuery, *params.HistoryId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.HistoryUuid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "history_uuid", runtime.ParamLocationQuery, *params.HistoryUuid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScansPluginOutputRequest generates requests for ScansPluginOutput
func NewScansPluginOutputRequest(server string, scanUuid string, hostId int32, pluginId int32, params *ScansPluginOutputParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "scan_uuid", runtime.ParamLocationPath, scanUuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "host_id", runtime.ParamLocationPath, hostId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scans/%s/hosts/%s/plugins/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.HistoryId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "history_id", runtime.ParamLocationQuery, *params.HistoryId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.HistoryUuid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "history_uuid", runtime.ParamLocationQuery, *params.HistoryUuid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServerPropertiesRequest generates requests for ServerProperties
func NewServerPropertiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/server/properties")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServerStatusRequest generates requests for ServerStatus
func NewServerStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/server/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsAssignAssetTagsRequest calls the generic TagsAssignAssetTags builder with application/json body
func NewTagsAssignAssetTagsRequest(server string, body TagsAssignAssetTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsAssignAssetTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsAssignAssetTagsRequestWithBody generates requests for TagsAssignAssetTags with any type of body
func NewTagsAssignAssetTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/assets/assignments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsListAssetFiltersRequest generates requests for TagsListAssetFilters
func NewTagsListAssetFiltersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/assets/filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsListAssetTagsRequest generates requests for TagsListAssetTags
func NewTagsListAssetTagsRequest(server string, assetUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_uuid", runtime.ParamLocationPath, assetUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/assets/%s/assignments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsListTagCategoriesRequest generates requests for TagsListTagCategories
func NewTagsListTagCategoriesRequest(server string, params *TagsListTagCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.F != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f", runtime.ParamLocationQuery, *params.F); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ft != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ft", runtime.ParamLocationQuery, *params.Ft); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsCreateTagCategoryRequest calls the generic TagsCreateTagCategory builder with application/json body
func NewTagsCreateTagCategoryRequest(server string, body TagsCreateTagCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsCreateTagCategoryRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsCreateTagCategoryRequestWithBody generates requests for TagsCreateTagCategory with any type of body
func NewTagsCreateTagCategoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsDeleteTagCategoryRequest generates requests for TagsDeleteTagCategory
func NewTagsDeleteTagCategoryRequest(server string, categoryUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "category_uuid", runtime.ParamLocationPath, categoryUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsTagCategoryDetailsRequest generates requests for TagsTagCategoryDetails
func NewTagsTagCategoryDetailsRequest(server string, categoryUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "category_uuid", runtime.ParamLocationPath, categoryUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsEditTagCategoryRequest calls the generic TagsEditTagCategory builder with application/json body
func NewTagsEditTagCategoryRequest(server string, categoryUuid string, body TagsEditTagCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsEditTagCategoryRequestWithBody(server, categoryUuid, "application/json", bodyReader)
}

// NewTagsEditTagCategoryRequestWithBody generates requests for TagsEditTagCategory with any type of body
func NewTagsEditTagCategoryRequestWithBody(server string, categoryUuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "category_uuid", runtime.ParamLocationPath, categoryUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsListTagValuesRequest generates requests for TagsListTagValues
func NewTagsListTagValuesRequest(server string, params *TagsListTagValuesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/values")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.F != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f", runtime.ParamLocationQuery, *params.F); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ft != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ft", runtime.ParamLocationQuery, *params.Ft); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Wf != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wf", runtime.ParamLocationQuery, *params.Wf); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.W != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "w", runtime.ParamLocationQuery, *params.W); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsCreateTagValueRequest calls the generic TagsCreateTagValue builder with application/json body
func NewTagsCreateTagValueRequest(server string, body TagsCreateTagValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsCreateTagValueRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsCreateTagValueRequestWithBody generates requests for TagsCreateTagValue with any type of body
func NewTagsCreateTagValueRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/values")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsDeleteTagValuesBulkRequest calls the generic TagsDeleteTagValuesBulk builder with application/json body
func NewTagsDeleteTagValuesBulkRequest(server string, body TagsDeleteTagValuesBulkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsDeleteTagValuesBulkRequestWithBody(server, "application/json", bodyReader)
}

// NewTagsDeleteTagValuesBulkRequestWithBody generates requests for TagsDeleteTagValuesBulk with any type of body
func NewTagsDeleteTagValuesBulkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/values/delete-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTagsDeleteTagValueRequest generates requests for TagsDeleteTagValue
func NewTagsDeleteTagValueRequest(server string, valueUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "value_uuid", runtime.ParamLocationPath, valueUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/values/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsTagValueDetailsRequest generates requests for TagsTagValueDetails
func NewTagsTagValueDetailsRequest(server string, valueUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "value_uuid", runtime.ParamLocationPath, valueUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/values/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTagsUpdateTagValueRequest calls the generic TagsUpdateTagValue builder with application/json body
func NewTagsUpdateTagValueRequest(server string, valueUuid string, body TagsUpdateTagValueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTagsUpdateTagValueRequestWithBody(server, valueUuid, "application/json", bodyReader)
}

// NewTagsUpdateTagValueRequestWithBody generates requests for TagsUpdateTagValue with any type of body
func NewTagsUpdateTagValueRequestWithBody(server string, valueUuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "value_uuid", runtime.ParamLocationPath, valueUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/values/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTargetGroupsListRequest generates requests for TargetGroupsList
func NewTargetGroupsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/target-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTargetGroupsCreateRequest calls the generic TargetGroupsCreate builder with application/json body
func NewTargetGroupsCreateRequest(server string, body TargetGroupsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTargetGroupsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewTargetGroupsCreateRequestWithBody generates requests for TargetGroupsCreate with any type of body
func NewTargetGroupsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/target-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTargetGroupsDeleteRequest generates requests for TargetGroupsDelete
func NewTargetGroupsDeleteRequest(server string, groupId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/target-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTargetGroupsDetailsRequest generates requests for TargetGroupsDetails
func NewTargetGroupsDetailsRequest(server string, groupId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/target-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTargetGroupsEditRequest calls the generic TargetGroupsEdit builder with application/json body
func NewTargetGroupsEditRequest(server string, groupId int32, body TargetGroupsEditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTargetGroupsEditRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewTargetGroupsEditRequestWithBody generates requests for TargetGroupsEdit with any type of body
func NewTargetGroupsEditRequestWithBody(server string, groupId int32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/target-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoV2AccessGroupsListRequest generates requests for IoV2AccessGroupsList
func NewIoV2AccessGroupsListRequest(server string, params *IoV2AccessGroupsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.F != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "f", runtime.ParamLocationQuery, *params.F); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ft != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ft", runtime.ParamLocationQuery, *params.Ft); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.W != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "w", runtime.ParamLocationQuery, *params.W); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Wf != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "wf", runtime.ParamLocationQuery, *params.Wf); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Fullypopulateresponse != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fullypopulateresponse", runtime.ParamLocationQuery, *params.Fullypopulateresponse); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoV2AccessGroupsCreateRequest calls the generic IoV2AccessGroupsCreate builder with application/json body
func NewIoV2AccessGroupsCreateRequest(server string, body IoV2AccessGroupsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoV2AccessGroupsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewIoV2AccessGroupsCreateRequestWithBody generates requests for IoV2AccessGroupsCreate with any type of body
func NewIoV2AccessGroupsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIoV2AccessGroupsListFiltersRequest generates requests for IoV2AccessGroupsListFilters
func NewIoV2AccessGroupsListFiltersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-groups/filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoV2AccessGroupsListRuleFiltersRequest generates requests for IoV2AccessGroupsListRuleFilters
func NewIoV2AccessGroupsListRuleFiltersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-groups/rules/filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoV2AccessGroupsDeleteRequest generates requests for IoV2AccessGroupsDelete
func NewIoV2AccessGroupsDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoV2AccessGroupsDetailsRequest generates requests for IoV2AccessGroupsDetails
func NewIoV2AccessGroupsDetailsRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIoV2AccessGroupsEditRequest calls the generic IoV2AccessGroupsEdit builder with application/json body
func NewIoV2AccessGroupsEditRequest(server string, id string, body IoV2AccessGroupsEditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIoV2AccessGroupsEditRequestWithBody(server, id, "application/json", bodyReader)
}

// NewIoV2AccessGroupsEditRequestWithBody generates requests for IoV2AccessGroupsEdit with any type of body
func NewIoV2AccessGroupsEditRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/access-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExportsVulnsRequestExportRequest calls the generic ExportsVulnsRequestExport builder with application/json body
func NewExportsVulnsRequestExportRequest(server string, body ExportsVulnsRequestExportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportsVulnsRequestExportRequestWithBody(server, "application/json", bodyReader)
}

// NewExportsVulnsRequestExportRequestWithBody generates requests for ExportsVulnsRequestExport with any type of body
func NewExportsVulnsRequestExportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vulns/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExportsVulnsExportStatusRecentRequest generates requests for ExportsVulnsExportStatusRecent
func NewExportsVulnsExportStatusRecentRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vulns/export/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportsVulnsExportCancelRequest generates requests for ExportsVulnsExportCancel
func NewExportsVulnsExportCancelRequest(server string, exportUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "export_uuid", runtime.ParamLocationPath, exportUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vulns/export/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportsVulnsDownloadChunkRequest generates requests for ExportsVulnsDownloadChunk
func NewExportsVulnsDownloadChunkRequest(server string, exportUuid string, chunkId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "export_uuid", runtime.ParamLocationPath, exportUuid)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "chunk_id", runtime.ParamLocationPath, chunkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vulns/export/%s/chunks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportsVulnsExportStatusRequest generates requests for ExportsVulnsExportStatus
func NewExportsVulnsExportStatusRequest(server string, exportUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "export_uuid", runtime.ParamLocationPath, exportUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vulns/export/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesAssetsRequest generates requests for WorkbenchesAssets
func NewWorkbenchesAssetsRequest(server string, params *WorkbenchesAssetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DateRange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_range", runtime.ParamLocationQuery, *params.DateRange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.filter", runtime.ParamLocationQuery, *params.Filter0Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Quality != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.quality", runtime.ParamLocationQuery, *params.Filter0Quality); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Value != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.value", runtime.ParamLocationQuery, *params.Filter0Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSearchType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.search_type", runtime.ParamLocationQuery, *params.FilterSearchType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AllFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesAssetsVulnerabilitiesRequest generates requests for WorkbenchesAssetsVulnerabilities
func NewWorkbenchesAssetsVulnerabilitiesRequest(server string, params *WorkbenchesAssetsVulnerabilitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/assets/vulnerabilities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DateRange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_range", runtime.ParamLocationQuery, *params.DateRange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.filter", runtime.ParamLocationQuery, *params.Filter0Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Quality != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.quality", runtime.ParamLocationQuery, *params.Filter0Quality); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Value != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.value", runtime.ParamLocationQuery, *params.Filter0Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSearchType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.search_type", runtime.ParamLocationQuery, *params.FilterSearchType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesAssetInfoRequest generates requests for WorkbenchesAssetInfo
func NewWorkbenchesAssetInfoRequest(server string, assetId string, params *WorkbenchesAssetInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_id", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/assets/%s/info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AllFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all_fields", runtime.ParamLocationQuery, *params.AllFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesAssetVulnerabilitiesRequest generates requests for WorkbenchesAssetVulnerabilities
func NewWorkbenchesAssetVulnerabilitiesRequest(server string, assetId string, params *WorkbenchesAssetVulnerabilitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_id", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/assets/%s/vulnerabilities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DateRange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_range", runtime.ParamLocationQuery, *params.DateRange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.filter", runtime.ParamLocationQuery, *params.Filter0Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Quality != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.quality", runtime.ParamLocationQuery, *params.Filter0Quality); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Value != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.value", runtime.ParamLocationQuery, *params.Filter0Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSearchType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.search_type", runtime.ParamLocationQuery, *params.FilterSearchType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesAssetVulnerabilityInfoRequest generates requests for WorkbenchesAssetVulnerabilityInfo
func NewWorkbenchesAssetVulnerabilityInfoRequest(server string, assetId string, pluginId int32, params *WorkbenchesAssetVulnerabilityInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_id", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/assets/%s/vulnerabilities/%s/info", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DateRange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_range", runtime.ParamLocationQuery, *params.DateRange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.filter", runtime.ParamLocationQuery, *params.Filter0Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Quality != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.quality", runtime.ParamLocationQuery, *params.Filter0Quality); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Value != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.value", runtime.ParamLocationQuery, *params.Filter0Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSearchType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.search_type", runtime.ParamLocationQuery, *params.FilterSearchType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesAssetVulnerabilityOutputRequest generates requests for WorkbenchesAssetVulnerabilityOutput
func NewWorkbenchesAssetVulnerabilityOutputRequest(server string, assetId string, pluginId int32, params *WorkbenchesAssetVulnerabilityOutputParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_id", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/assets/%s/vulnerabilities/%s/outputs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DateRange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_range", runtime.ParamLocationQuery, *params.DateRange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.filter", runtime.ParamLocationQuery, *params.Filter0Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Quality != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.quality", runtime.ParamLocationQuery, *params.Filter0Quality); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Value != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.value", runtime.ParamLocationQuery, *params.Filter0Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSearchType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.search_type", runtime.ParamLocationQuery, *params.FilterSearchType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesAssetsDeleteRequest generates requests for WorkbenchesAssetsDelete
func NewWorkbenchesAssetsDeleteRequest(server string, assetUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_uuid", runtime.ParamLocationPath, assetUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/assets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesAssetsActivityRequest generates requests for WorkbenchesAssetsActivity
func NewWorkbenchesAssetsActivityRequest(server string, assetUuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "asset_uuid", runtime.ParamLocationPath, assetUuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/assets/%s/activity", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesExportRequestRequest generates requests for WorkbenchesExportRequest
func NewWorkbenchesExportRequestRequest(server string, params *WorkbenchesExportRequestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, params.Format); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "report", runtime.ParamLocationQuery, params.Report); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StartDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chapter", runtime.ParamLocationQuery, params.Chapter); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.DateRange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_range", runtime.ParamLocationQuery, *params.DateRange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.filter", runtime.ParamLocationQuery, *params.Filter0Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Quality != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.quality", runtime.ParamLocationQuery, *params.Filter0Quality); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Value != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.value", runtime.ParamLocationQuery, *params.Filter0Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSearchType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.search_type", runtime.ParamLocationQuery, *params.FilterSearchType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MinimumVulnInfo != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minimum_vuln_info", runtime.ParamLocationQuery, *params.MinimumVulnInfo); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PluginId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "plugin_id", runtime.ParamLocationQuery, *params.PluginId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AssetId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset_id", runtime.ParamLocationQuery, *params.AssetId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesExportDownloadRequest generates requests for WorkbenchesExportDownload
func NewWorkbenchesExportDownloadRequest(server string, fileId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/export/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesExportStatusRequest generates requests for WorkbenchesExportStatus
func NewWorkbenchesExportStatusRequest(server string, fileId int32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/export/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesVulnerabilitiesRequest generates requests for WorkbenchesVulnerabilities
func NewWorkbenchesVulnerabilitiesRequest(server string, params *WorkbenchesVulnerabilitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/vulnerabilities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Age != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "age", runtime.ParamLocationQuery, *params.Age); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Authenticated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authenticated", runtime.ParamLocationQuery, *params.Authenticated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DateRange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_range", runtime.ParamLocationQuery, *params.DateRange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exploitable != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exploitable", runtime.ParamLocationQuery, *params.Exploitable); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.filter", runtime.ParamLocationQuery, *params.Filter0Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Quality != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.quality", runtime.ParamLocationQuery, *params.Filter0Quality); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Value != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.value", runtime.ParamLocationQuery, *params.Filter0Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSearchType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.search_type", runtime.ParamLocationQuery, *params.FilterSearchType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Resolvable != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolvable", runtime.ParamLocationQuery, *params.Resolvable); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Severity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesVulnerabilityInfoRequest generates requests for WorkbenchesVulnerabilityInfo
func NewWorkbenchesVulnerabilityInfoRequest(server string, pluginId int32, params *WorkbenchesVulnerabilityInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/vulnerabilities/%s/info", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DateRange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_range", runtime.ParamLocationQuery, *params.DateRange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.filter", runtime.ParamLocationQuery, *params.Filter0Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Quality != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.quality", runtime.ParamLocationQuery, *params.Filter0Quality); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Value != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.value", runtime.ParamLocationQuery, *params.Filter0Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSearchType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.search_type", runtime.ParamLocationQuery, *params.FilterSearchType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkbenchesVulnerabilityOutputRequest generates requests for WorkbenchesVulnerabilityOutput
func NewWorkbenchesVulnerabilityOutputRequest(server string, pluginId int32, params *WorkbenchesVulnerabilityOutputParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plugin_id", runtime.ParamLocationPath, pluginId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workbenches/vulnerabilities/%s/outputs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DateRange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_range", runtime.ParamLocationQuery, *params.DateRange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.filter", runtime.ParamLocationQuery, *params.Filter0Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Quality != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.quality", runtime.ParamLocationQuery, *params.Filter0Quality); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter0Value != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.0.value", runtime.ParamLocationQuery, *params.Filter0Value); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterSearchType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.search_type", runtime.ParamLocationQuery, *params.FilterSearchType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// IoV1AccessGroupsList request
	IoV1AccessGroupsListWithResponse(ctx context.Context, params *IoV1AccessGroupsListParams, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsListResponse, error)

	// IoV1AccessGroupsCreate request with any body
	IoV1AccessGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsCreateResponse, error)

	IoV1AccessGroupsCreateWithResponse(ctx context.Context, body IoV1AccessGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsCreateResponse, error)

	// IoV1AccessGroupsListFilters request
	IoV1AccessGroupsListFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsListFiltersResponse, error)

	// IoV1AccessGroupsListRuleFilters request
	IoV1AccessGroupsListRuleFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsListRuleFiltersResponse, error)

	// IoV1AccessGroupsDelete request
	IoV1AccessGroupsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsDeleteResponse, error)

	// IoV1AccessGroupsDetails request
	IoV1AccessGroupsDetailsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsDetailsResponse, error)

	// IoV1AccessGroupsEdit request with any body
	IoV1AccessGroupsEditWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsEditResponse, error)

	IoV1AccessGroupsEditWithResponse(ctx context.Context, id string, body IoV1AccessGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsEditResponse, error)

	// AssetsBulkUpdateAcr request with any body
	AssetsBulkUpdateAcrWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetsBulkUpdateAcrResponse, error)

	AssetsBulkUpdateAcrWithResponse(ctx context.Context, body AssetsBulkUpdateAcrJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetsBulkUpdateAcrResponse, error)

	// AssetsBulkDelete request with any body
	AssetsBulkDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetsBulkDeleteResponse, error)

	AssetsBulkDeleteWithResponse(ctx context.Context, body AssetsBulkDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetsBulkDeleteResponse, error)

	// AssetsBulkMove request with any body
	AssetsBulkMoveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetsBulkMoveResponse, error)

	AssetsBulkMoveWithResponse(ctx context.Context, body AssetsBulkMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetsBulkMoveResponse, error)

	// VulnerabilitiesImportV2 request with any body
	VulnerabilitiesImportV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VulnerabilitiesImportV2Response, error)

	VulnerabilitiesImportV2WithResponse(ctx context.Context, body VulnerabilitiesImportV2JSONRequestBody, reqEditors ...RequestEditorFn) (*VulnerabilitiesImportV2Response, error)

	// AssetsListAssets request
	AssetsListAssetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AssetsListAssetsResponse, error)

	// ExportsAssetsRequestExport request with any body
	ExportsAssetsRequestExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportsAssetsRequestExportResponse, error)

	ExportsAssetsRequestExportWithResponse(ctx context.Context, body ExportsAssetsRequestExportJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportsAssetsRequestExportResponse, error)

	// ExportsAssetsExportStatusRecent request
	ExportsAssetsExportStatusRecentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportsAssetsExportStatusRecentResponse, error)

	// ExportsAssetsExportCancel request
	ExportsAssetsExportCancelWithResponse(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*ExportsAssetsExportCancelResponse, error)

	// ExportsAssetsDownloadChunk request
	ExportsAssetsDownloadChunkWithResponse(ctx context.Context, exportUuid string, chunkId int32, reqEditors ...RequestEditorFn) (*ExportsAssetsDownloadChunkResponse, error)

	// ExportsAssetsExportStatus request
	ExportsAssetsExportStatusWithResponse(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*ExportsAssetsExportStatusResponse, error)

	// AssetsAssetInfo request
	AssetsAssetInfoWithResponse(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*AssetsAssetInfoResponse, error)

	// AuditLogEvents request
	AuditLogEventsWithResponse(ctx context.Context, params *AuditLogEventsParams, reqEditors ...RequestEditorFn) (*AuditLogEventsResponse, error)

	// IoExportsComplianceCreate request with any body
	IoExportsComplianceCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoExportsComplianceCreateResponse, error)

	IoExportsComplianceCreateWithResponse(ctx context.Context, body IoExportsComplianceCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IoExportsComplianceCreateResponse, error)

	// IoExportsComplianceCancel request
	IoExportsComplianceCancelWithResponse(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*IoExportsComplianceCancelResponse, error)

	// IoExportsComplianceDownload request
	IoExportsComplianceDownloadWithResponse(ctx context.Context, exportUuid string, chunkId int32, reqEditors ...RequestEditorFn) (*IoExportsComplianceDownloadResponse, error)

	// IoExportsComplianceStatus request
	IoExportsComplianceStatusWithResponse(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*IoExportsComplianceStatusResponse, error)

	// CredentialsList request
	CredentialsListWithResponse(ctx context.Context, params *CredentialsListParams, reqEditors ...RequestEditorFn) (*CredentialsListResponse, error)

	// CredentialsCreate request with any body
	CredentialsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CredentialsCreateResponse, error)

	CredentialsCreateWithResponse(ctx context.Context, body CredentialsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CredentialsCreateResponse, error)

	// CredentialsFileUpload request with any body
	CredentialsFileUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CredentialsFileUploadResponse, error)

	// CredentialsListCredentialTypes request
	CredentialsListCredentialTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CredentialsListCredentialTypesResponse, error)

	// CredentialsDelete request
	CredentialsDeleteWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*CredentialsDeleteResponse, error)

	// CredentialsDetails request
	CredentialsDetailsWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*CredentialsDetailsResponse, error)

	// CredentialsUpdate request with any body
	CredentialsUpdateWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CredentialsUpdateResponse, error)

	CredentialsUpdateWithResponse(ctx context.Context, uuid string, body CredentialsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CredentialsUpdateResponse, error)

	// EditorPluginDescription request
	EditorPluginDescriptionWithResponse(ctx context.Context, policyId int32, familyId int32, pluginId int32, reqEditors ...RequestEditorFn) (*EditorPluginDescriptionResponse, error)

	// EditorListTemplates request
	EditorListTemplatesWithResponse(ctx context.Context, pType EditorListTemplatesParamsType, reqEditors ...RequestEditorFn) (*EditorListTemplatesResponse, error)

	// EditorTemplateDetails request
	EditorTemplateDetailsWithResponse(ctx context.Context, pType EditorTemplateDetailsParamsType, templateUuid string, reqEditors ...RequestEditorFn) (*EditorTemplateDetailsResponse, error)

	// EditorDetails request
	EditorDetailsWithResponse(ctx context.Context, pType EditorDetailsParamsType, id int32, reqEditors ...RequestEditorFn) (*EditorDetailsResponse, error)

	// EditorAudits request
	EditorAuditsWithResponse(ctx context.Context, pType EditorAuditsParamsType, objectId int32, fileId int32, reqEditors ...RequestEditorFn) (*EditorAuditsResponse, error)

	// ExclusionsList request
	ExclusionsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExclusionsListResponse, error)

	// ExclusionsCreate request with any body
	ExclusionsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExclusionsCreateResponse, error)

	ExclusionsCreateWithResponse(ctx context.Context, body ExclusionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ExclusionsCreateResponse, error)

	// ExclusionsImport request with any body
	ExclusionsImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExclusionsImportResponse, error)

	ExclusionsImportWithResponse(ctx context.Context, body ExclusionsImportJSONRequestBody, reqEditors ...RequestEditorFn) (*ExclusionsImportResponse, error)

	// ExclusionsDelete request
	ExclusionsDeleteWithResponse(ctx context.Context, exclusionId int32, reqEditors ...RequestEditorFn) (*ExclusionsDeleteResponse, error)

	// ExclusionsDetails request
	ExclusionsDetailsWithResponse(ctx context.Context, exclusionId int32, reqEditors ...RequestEditorFn) (*ExclusionsDetailsResponse, error)

	// ExclusionsEdit request with any body
	ExclusionsEditWithBodyWithResponse(ctx context.Context, exclusionId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExclusionsEditResponse, error)

	ExclusionsEditWithResponse(ctx context.Context, exclusionId int32, body ExclusionsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*ExclusionsEditResponse, error)

	// FileUpload request with any body
	FileUploadWithBodyWithResponse(ctx context.Context, params *FileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FileUploadResponse, error)

	// IoFiltersCredentialsList request
	IoFiltersCredentialsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoFiltersCredentialsListResponse, error)

	// IoFiltersAgentsList request
	IoFiltersAgentsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoFiltersAgentsListResponse, error)

	// IoFiltersScanList request
	IoFiltersScanListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoFiltersScanListResponse, error)

	// IoFiltersScanHistoryList request
	IoFiltersScanHistoryListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoFiltersScanHistoryListResponse, error)

	// IoFiltersAssetsList request
	IoFiltersAssetsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoFiltersAssetsListResponse, error)

	// IoFiltersAssetsListV2 request with any body
	IoFiltersAssetsListV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoFiltersAssetsListV2Response, error)

	IoFiltersAssetsListV2WithResponse(ctx context.Context, body IoFiltersAssetsListV2JSONRequestBody, reqEditors ...RequestEditorFn) (*IoFiltersAssetsListV2Response, error)

	// IoFiltersVulnerabilitiesWorkbenchList request
	IoFiltersVulnerabilitiesWorkbenchListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoFiltersVulnerabilitiesWorkbenchListResponse, error)

	// IoFiltersVulnerabilitiesWorkbenchListV2 request with any body
	IoFiltersVulnerabilitiesWorkbenchListV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoFiltersVulnerabilitiesWorkbenchListV2Response, error)

	IoFiltersVulnerabilitiesWorkbenchListV2WithResponse(ctx context.Context, body IoFiltersVulnerabilitiesWorkbenchListV2JSONRequestBody, reqEditors ...RequestEditorFn) (*IoFiltersVulnerabilitiesWorkbenchListV2Response, error)

	// FoldersList request
	FoldersListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FoldersListResponse, error)

	// FoldersCreate request with any body
	FoldersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FoldersCreateResponse, error)

	FoldersCreateWithResponse(ctx context.Context, body FoldersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FoldersCreateResponse, error)

	// FoldersDelete request
	FoldersDeleteWithResponse(ctx context.Context, folderId int32, reqEditors ...RequestEditorFn) (*FoldersDeleteResponse, error)

	// FoldersEdit request with any body
	FoldersEditWithBodyWithResponse(ctx context.Context, folderId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FoldersEditResponse, error)

	FoldersEditWithResponse(ctx context.Context, folderId int32, body FoldersEditJSONRequestBody, reqEditors ...RequestEditorFn) (*FoldersEditResponse, error)

	// AssetsListImportJobs request
	AssetsListImportJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AssetsListImportJobsResponse, error)

	// AssetsImportJobInfo request
	AssetsImportJobInfoWithResponse(ctx context.Context, assetImportJobUuid string, reqEditors ...RequestEditorFn) (*AssetsImportJobInfoResponse, error)

	// AssetsImport request with any body
	AssetsImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetsImportResponse, error)

	AssetsImportWithResponse(ctx context.Context, body AssetsImportJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetsImportResponse, error)

	// VulnerabilitiesImport request with any body
	VulnerabilitiesImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VulnerabilitiesImportResponse, error)

	VulnerabilitiesImportWithResponse(ctx context.Context, body VulnerabilitiesImportJSONRequestBody, reqEditors ...RequestEditorFn) (*VulnerabilitiesImportResponse, error)

	// NetworksList request
	NetworksListWithResponse(ctx context.Context, params *NetworksListParams, reqEditors ...RequestEditorFn) (*NetworksListResponse, error)

	// NetworksCreate request with any body
	NetworksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NetworksCreateResponse, error)

	NetworksCreateWithResponse(ctx context.Context, body NetworksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*NetworksCreateResponse, error)

	// NetworksDelete request
	NetworksDeleteWithResponse(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*NetworksDeleteResponse, error)

	// NetworksDetails request
	NetworksDetailsWithResponse(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*NetworksDetailsResponse, error)

	// NetworksUpdate request with any body
	NetworksUpdateWithBodyWithResponse(ctx context.Context, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NetworksUpdateResponse, error)

	NetworksUpdateWithResponse(ctx context.Context, networkId string, body NetworksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NetworksUpdateResponse, error)

	// NetworksListAssignableScanners request
	NetworksListAssignableScannersWithResponse(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*NetworksListAssignableScannersResponse, error)

	// IoNetworksAssetCountDetails request
	IoNetworksAssetCountDetailsWithResponse(ctx context.Context, networkId string, numDays int, reqEditors ...RequestEditorFn) (*IoNetworksAssetCountDetailsResponse, error)

	// NetworksListScanners request
	NetworksListScannersWithResponse(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*NetworksListScannersResponse, error)

	// NetworksAssignScannerBulk request with any body
	NetworksAssignScannerBulkWithBodyWithResponse(ctx context.Context, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NetworksAssignScannerBulkResponse, error)

	NetworksAssignScannerBulkWithResponse(ctx context.Context, networkId string, body NetworksAssignScannerBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*NetworksAssignScannerBulkResponse, error)

	// NetworksAssignScanner request
	NetworksAssignScannerWithResponse(ctx context.Context, networkId string, scannerUuid string, reqEditors ...RequestEditorFn) (*NetworksAssignScannerResponse, error)

	// PermissionsList request
	PermissionsListWithResponse(ctx context.Context, objectType PermissionsListParamsObjectType, objectId int32, reqEditors ...RequestEditorFn) (*PermissionsListResponse, error)

	// PermissionsChange request with any body
	PermissionsChangeWithBodyWithResponse(ctx context.Context, objectType PermissionsChangeParamsObjectType, objectId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermissionsChangeResponse, error)

	PermissionsChangeWithResponse(ctx context.Context, objectType PermissionsChangeParamsObjectType, objectId int32, body PermissionsChangeJSONRequestBody, reqEditors ...RequestEditorFn) (*PermissionsChangeResponse, error)

	// IoPluginsFamiliesList request
	IoPluginsFamiliesListWithResponse(ctx context.Context, params *IoPluginsFamiliesListParams, reqEditors ...RequestEditorFn) (*IoPluginsFamiliesListResponse, error)

	// IoPluginsFamilyDetails request
	IoPluginsFamilyDetailsWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*IoPluginsFamilyDetailsResponse, error)

	// IoPluginsList request
	IoPluginsListWithResponse(ctx context.Context, params *IoPluginsListParams, reqEditors ...RequestEditorFn) (*IoPluginsListResponse, error)

	// IoPluginsDetails request
	IoPluginsDetailsWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*IoPluginsDetailsResponse, error)

	// PoliciesList request
	PoliciesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PoliciesListResponse, error)

	// PoliciesCreate request with any body
	PoliciesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PoliciesCreateResponse, error)

	PoliciesCreateWithResponse(ctx context.Context, body PoliciesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PoliciesCreateResponse, error)

	// PoliciesImport request with any body
	PoliciesImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PoliciesImportResponse, error)

	PoliciesImportWithResponse(ctx context.Context, body PoliciesImportJSONRequestBody, reqEditors ...RequestEditorFn) (*PoliciesImportResponse, error)

	// PoliciesDelete request
	PoliciesDeleteWithResponse(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*PoliciesDeleteResponse, error)

	// PoliciesDetails request
	PoliciesDetailsWithResponse(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*PoliciesDetailsResponse, error)

	// PoliciesConfigure request
	PoliciesConfigureWithResponse(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*PoliciesConfigureResponse, error)

	// PoliciesCopy request
	PoliciesCopyWithResponse(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*PoliciesCopyResponse, error)

	// PoliciesExport request
	PoliciesExportWithResponse(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*PoliciesExportResponse, error)

	// ScannerGroupsList request
	ScannerGroupsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScannerGroupsListResponse, error)

	// ScannerGroupsCreate request with any body
	ScannerGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScannerGroupsCreateResponse, error)

	ScannerGroupsCreateWithResponse(ctx context.Context, body ScannerGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScannerGroupsCreateResponse, error)

	// ScannerGroupsDelete request
	ScannerGroupsDeleteWithResponse(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*ScannerGroupsDeleteResponse, error)

	// ScannerGroupsDetails request
	ScannerGroupsDetailsWithResponse(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*ScannerGroupsDetailsResponse, error)

	// ScannerGroupsEdit request with any body
	ScannerGroupsEditWithBodyWithResponse(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScannerGroupsEditResponse, error)

	ScannerGroupsEditWithResponse(ctx context.Context, groupId int32, body ScannerGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*ScannerGroupsEditResponse, error)

	// IoScannerGroupsListRoutes request
	IoScannerGroupsListRoutesWithResponse(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*IoScannerGroupsListRoutesResponse, error)

	// IoScannerGroupsUpdateRoutes request with any body
	IoScannerGroupsUpdateRoutesWithBodyWithResponse(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoScannerGroupsUpdateRoutesResponse, error)

	IoScannerGroupsUpdateRoutesWithResponse(ctx context.Context, groupId int32, body IoScannerGroupsUpdateRoutesJSONRequestBody, reqEditors ...RequestEditorFn) (*IoScannerGroupsUpdateRoutesResponse, error)

	// ScannerGroupsListScanners request
	ScannerGroupsListScannersWithResponse(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*ScannerGroupsListScannersResponse, error)

	// ScannerGroupsDeleteScanner request
	ScannerGroupsDeleteScannerWithResponse(ctx context.Context, groupId int32, scannerId int32, reqEditors ...RequestEditorFn) (*ScannerGroupsDeleteScannerResponse, error)

	// ScannerGroupsAddScanner request
	ScannerGroupsAddScannerWithResponse(ctx context.Context, groupId int32, scannerId int32, reqEditors ...RequestEditorFn) (*ScannerGroupsAddScannerResponse, error)

	// ScannersList request
	ScannersListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScannersListResponse, error)

	// BulkAddAgents request with any body
	BulkAddAgentsWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddAgentsResponse, error)

	BulkAddAgentsWithResponse(ctx context.Context, groupId string, body BulkAddAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkAddAgentsResponse, error)

	// IoAgentBulkOperationsGroupDirective request with any body
	IoAgentBulkOperationsGroupDirectiveWithBodyWithResponse(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsGroupDirectiveResponse, error)

	IoAgentBulkOperationsGroupDirectiveWithResponse(ctx context.Context, groupId int32, body IoAgentBulkOperationsGroupDirectiveJSONRequestBody, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsGroupDirectiveResponse, error)

	// BulkRemoveAgents request with any body
	BulkRemoveAgentsWithBodyWithResponse(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkRemoveAgentsResponse, error)

	BulkRemoveAgentsWithResponse(ctx context.Context, groupId int32, body BulkRemoveAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkRemoveAgentsResponse, error)

	// BulkTaskAgentGroupStatus request
	BulkTaskAgentGroupStatusWithResponse(ctx context.Context, groupId int32, taskUuid string, reqEditors ...RequestEditorFn) (*BulkTaskAgentGroupStatusResponse, error)

	// IoAgentBulkOperationsAddToNetwork request with any body
	IoAgentBulkOperationsAddToNetworkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsAddToNetworkResponse, error)

	IoAgentBulkOperationsAddToNetworkWithResponse(ctx context.Context, body IoAgentBulkOperationsAddToNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsAddToNetworkResponse, error)

	// IoAgentBulkOperationsDirective request with any body
	IoAgentBulkOperationsDirectiveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsDirectiveResponse, error)

	IoAgentBulkOperationsDirectiveWithResponse(ctx context.Context, body IoAgentBulkOperationsDirectiveJSONRequestBody, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsDirectiveResponse, error)

	// IoAgentBulkOperationsRemoveFromNetwork request with any body
	IoAgentBulkOperationsRemoveFromNetworkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsRemoveFromNetworkResponse, error)

	IoAgentBulkOperationsRemoveFromNetworkWithResponse(ctx context.Context, body IoAgentBulkOperationsRemoveFromNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsRemoveFromNetworkResponse, error)

	// BulkUnlinkAgents request with any body
	BulkUnlinkAgentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUnlinkAgentsResponse, error)

	BulkUnlinkAgentsWithResponse(ctx context.Context, body BulkUnlinkAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUnlinkAgentsResponse, error)

	// BulkTaskAgentStatus request
	BulkTaskAgentStatusWithResponse(ctx context.Context, taskUuid string, reqEditors ...RequestEditorFn) (*BulkTaskAgentStatusResponse, error)

	// ScannersDelete request
	ScannersDeleteWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*ScannersDeleteResponse, error)

	// ScannersDetails request
	ScannersDetailsWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*ScannersDetailsResponse, error)

	// ScannersEdit request with any body
	ScannersEditWithBodyWithResponse(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScannersEditResponse, error)

	ScannersEditWithResponse(ctx context.Context, scannerId int32, body ScannersEditJSONRequestBody, reqEditors ...RequestEditorFn) (*ScannersEditResponse, error)

	// AgentGroupsList request
	AgentGroupsListWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*AgentGroupsListResponse, error)

	// AgentGroupsCreate request with any body
	AgentGroupsCreateWithBodyWithResponse(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AgentGroupsCreateResponse, error)

	AgentGroupsCreateWithResponse(ctx context.Context, scannerId int32, body AgentGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AgentGroupsCreateResponse, error)

	// AgentGroupListAgents request
	AgentGroupListAgentsWithResponse(ctx context.Context, scannerId int32, agentGroupId int32, params *AgentGroupListAgentsParams, reqEditors ...RequestEditorFn) (*AgentGroupListAgentsResponse, error)

	// AgentGroupsDelete request
	AgentGroupsDeleteWithResponse(ctx context.Context, scannerId int32, groupId int32, reqEditors ...RequestEditorFn) (*AgentGroupsDeleteResponse, error)

	// AgentGroupsDetails request
	AgentGroupsDetailsWithResponse(ctx context.Context, scannerId int32, groupId int32, params *AgentGroupsDetailsParams, reqEditors ...RequestEditorFn) (*AgentGroupsDetailsResponse, error)

	// AgentGroupsConfigure request with any body
	AgentGroupsConfigureWithBodyWithResponse(ctx context.Context, scannerId int32, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AgentGroupsConfigureResponse, error)

	AgentGroupsConfigureWithResponse(ctx context.Context, scannerId int32, groupId int32, body AgentGroupsConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*AgentGroupsConfigureResponse, error)

	// AgentGroupsDeleteAgent request
	AgentGroupsDeleteAgentWithResponse(ctx context.Context, scannerId int32, groupId int32, agentId int32, reqEditors ...RequestEditorFn) (*AgentGroupsDeleteAgentResponse, error)

	// AgentGroupsAddAgent request
	AgentGroupsAddAgentWithResponse(ctx context.Context, scannerId int32, groupId int32, agentId int32, reqEditors ...RequestEditorFn) (*AgentGroupsAddAgentResponse, error)

	// AgentsList request
	AgentsListWithResponse(ctx context.Context, scannerId int32, params *AgentsListParams, reqEditors ...RequestEditorFn) (*AgentsListResponse, error)

	// AgentConfigDetails request
	AgentConfigDetailsWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*AgentConfigDetailsResponse, error)

	// AgentConfigEdit request with any body
	AgentConfigEditWithBodyWithResponse(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AgentConfigEditResponse, error)

	AgentConfigEditWithResponse(ctx context.Context, scannerId int32, body AgentConfigEditJSONRequestBody, reqEditors ...RequestEditorFn) (*AgentConfigEditResponse, error)

	// AgentExclusionsList request
	AgentExclusionsListWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*AgentExclusionsListResponse, error)

	// AgentExclusionsCreate request with any body
	AgentExclusionsCreateWithBodyWithResponse(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AgentExclusionsCreateResponse, error)

	AgentExclusionsCreateWithResponse(ctx context.Context, scannerId int32, body AgentExclusionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AgentExclusionsCreateResponse, error)

	// AgentExclusionsDelete request
	AgentExclusionsDeleteWithResponse(ctx context.Context, scannerId int32, exclusionId int32, reqEditors ...RequestEditorFn) (*AgentExclusionsDeleteResponse, error)

	// AgentExclusionsDetails request
	AgentExclusionsDetailsWithResponse(ctx context.Context, scannerId int32, exclusionId int32, reqEditors ...RequestEditorFn) (*AgentExclusionsDetailsResponse, error)

	// AgentExclusionsEdit request with any body
	AgentExclusionsEditWithBodyWithResponse(ctx context.Context, scannerId int32, exclusionId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AgentExclusionsEditResponse, error)

	AgentExclusionsEditWithResponse(ctx context.Context, scannerId int32, exclusionId int32, body AgentExclusionsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*AgentExclusionsEditResponse, error)

	// AgentsDelete request
	AgentsDeleteWithResponse(ctx context.Context, scannerId int32, agentId int32, reqEditors ...RequestEditorFn) (*AgentsDeleteResponse, error)

	// AgentsGet request
	AgentsGetWithResponse(ctx context.Context, scannerId int32, agentId int32, reqEditors ...RequestEditorFn) (*AgentsGetResponse, error)

	// ScannersGetAwsTargets request
	ScannersGetAwsTargetsWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*ScannersGetAwsTargetsResponse, error)

	// ScannersGetScannerKey request
	ScannersGetScannerKeyWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*ScannersGetScannerKeyResponse, error)

	// ScannersToggleLinkState request with any body
	ScannersToggleLinkStateWithBodyWithResponse(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScannersToggleLinkStateResponse, error)

	ScannersToggleLinkStateWithResponse(ctx context.Context, scannerId int32, body ScannersToggleLinkStateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScannersToggleLinkStateResponse, error)

	// ScannersGetScans request
	ScannersGetScansWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*ScannersGetScansResponse, error)

	// ScannersControlScans request with any body
	ScannersControlScansWithBodyWithResponse(ctx context.Context, scannerId int32, scanUuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScannersControlScansResponse, error)

	ScannersControlScansWithResponse(ctx context.Context, scannerId int32, scanUuid string, body ScannersControlScansJSONRequestBody, reqEditors ...RequestEditorFn) (*ScannersControlScansResponse, error)

	// ScansList request
	ScansListWithResponse(ctx context.Context, params *ScansListParams, reqEditors ...RequestEditorFn) (*ScansListResponse, error)

	// ScansCreate request with any body
	ScansCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansCreateResponse, error)

	ScansCreateWithResponse(ctx context.Context, body ScansCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansCreateResponse, error)

	// IoScansCheckAutoTargets request with any body
	IoScansCheckAutoTargetsWithBodyWithResponse(ctx context.Context, params *IoScansCheckAutoTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoScansCheckAutoTargetsResponse, error)

	IoScansCheckAutoTargetsWithResponse(ctx context.Context, params *IoScansCheckAutoTargetsParams, body IoScansCheckAutoTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*IoScansCheckAutoTargetsResponse, error)

	// ScansImport request with any body
	ScansImportWithBodyWithResponse(ctx context.Context, params *ScansImportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansImportResponse, error)

	ScansImportWithResponse(ctx context.Context, params *ScansImportParams, body ScansImportJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansImportResponse, error)

	// IoScansRemediationList request
	IoScansRemediationListWithResponse(ctx context.Context, params *IoScansRemediationListParams, reqEditors ...RequestEditorFn) (*IoScansRemediationListResponse, error)

	// IoScansRemediationCreate request with any body
	IoScansRemediationCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoScansRemediationCreateResponse, error)

	IoScansRemediationCreateWithResponse(ctx context.Context, body IoScansRemediationCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IoScansRemediationCreateResponse, error)

	// ScansTimezones request
	ScansTimezonesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScansTimezonesResponse, error)

	// ScansDelete request
	ScansDeleteWithResponse(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*ScansDeleteResponse, error)

	// ScansDetails request
	ScansDetailsWithResponse(ctx context.Context, scanId string, params *ScansDetailsParams, reqEditors ...RequestEditorFn) (*ScansDetailsResponse, error)

	// ScansConfigure request with any body
	ScansConfigureWithBodyWithResponse(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansConfigureResponse, error)

	ScansConfigureWithResponse(ctx context.Context, scanId string, body ScansConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansConfigureResponse, error)

	// ScansAttachments request
	ScansAttachmentsWithResponse(ctx context.Context, scanId string, attachmentId string, params *ScansAttachmentsParams, reqEditors ...RequestEditorFn) (*ScansAttachmentsResponse, error)

	// ScansCopy request with any body
	ScansCopyWithBodyWithResponse(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansCopyResponse, error)

	ScansCopyWithResponse(ctx context.Context, scanId string, body ScansCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansCopyResponse, error)

	// IoScansCredentialsConvert request with any body
	IoScansCredentialsConvertWithBodyWithResponse(ctx context.Context, scanId int, credentialsId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoScansCredentialsConvertResponse, error)

	IoScansCredentialsConvertWithResponse(ctx context.Context, scanId int, credentialsId int, body IoScansCredentialsConvertJSONRequestBody, reqEditors ...RequestEditorFn) (*IoScansCredentialsConvertResponse, error)

	// ScansExportRequest request with any body
	ScansExportRequestWithBodyWithResponse(ctx context.Context, scanId string, params *ScansExportRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansExportRequestResponse, error)

	ScansExportRequestWithResponse(ctx context.Context, scanId string, params *ScansExportRequestParams, body ScansExportRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansExportRequestResponse, error)

	// ScansExportDownload request
	ScansExportDownloadWithResponse(ctx context.Context, scanId string, fileId string, reqEditors ...RequestEditorFn) (*ScansExportDownloadResponse, error)

	// ScansExportStatus request
	ScansExportStatusWithResponse(ctx context.Context, scanId string, fileId string, reqEditors ...RequestEditorFn) (*ScansExportStatusResponse, error)

	// ScansHistory request
	ScansHistoryWithResponse(ctx context.Context, scanId string, params *ScansHistoryParams, reqEditors ...RequestEditorFn) (*ScansHistoryResponse, error)

	// ScansDeleteHistory request
	ScansDeleteHistoryWithResponse(ctx context.Context, scanId string, historyId int32, reqEditors ...RequestEditorFn) (*ScansDeleteHistoryResponse, error)

	// ScansHistoryDetails request
	ScansHistoryDetailsWithResponse(ctx context.Context, scanId string, historyUuid string, reqEditors ...RequestEditorFn) (*ScansHistoryDetailsResponse, error)

	// ScansGetLatestStatus request
	ScansGetLatestStatusWithResponse(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*ScansGetLatestStatusResponse, error)

	// ScansLaunch request with any body
	ScansLaunchWithBodyWithResponse(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansLaunchResponse, error)

	ScansLaunchWithResponse(ctx context.Context, scanId string, body ScansLaunchJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansLaunchResponse, error)

	// ScansPause request
	ScansPauseWithResponse(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*ScansPauseResponse, error)

	// ScansResume request
	ScansResumeWithResponse(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*ScansResumeResponse, error)

	// ScansSchedule request with any body
	ScansScheduleWithBodyWithResponse(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansScheduleResponse, error)

	ScansScheduleWithResponse(ctx context.Context, scanId string, body ScansScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansScheduleResponse, error)

	// ScansReadStatus request with any body
	ScansReadStatusWithBodyWithResponse(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansReadStatusResponse, error)

	ScansReadStatusWithResponse(ctx context.Context, scanId string, body ScansReadStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansReadStatusResponse, error)

	// ScansStop request
	ScansStopWithResponse(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*ScansStopResponse, error)

	// ScansHostDetails request
	ScansHostDetailsWithResponse(ctx context.Context, scanUuid string, hostId int32, params *ScansHostDetailsParams, reqEditors ...RequestEditorFn) (*ScansHostDetailsResponse, error)

	// ScansPluginOutput request
	ScansPluginOutputWithResponse(ctx context.Context, scanUuid string, hostId int32, pluginId int32, params *ScansPluginOutputParams, reqEditors ...RequestEditorFn) (*ScansPluginOutputResponse, error)

	// ServerProperties request
	ServerPropertiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ServerPropertiesResponse, error)

	// ServerStatus request
	ServerStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ServerStatusResponse, error)

	// TagsAssignAssetTags request with any body
	TagsAssignAssetTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsAssignAssetTagsResponse, error)

	TagsAssignAssetTagsWithResponse(ctx context.Context, body TagsAssignAssetTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsAssignAssetTagsResponse, error)

	// TagsListAssetFilters request
	TagsListAssetFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TagsListAssetFiltersResponse, error)

	// TagsListAssetTags request
	TagsListAssetTagsWithResponse(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*TagsListAssetTagsResponse, error)

	// TagsListTagCategories request
	TagsListTagCategoriesWithResponse(ctx context.Context, params *TagsListTagCategoriesParams, reqEditors ...RequestEditorFn) (*TagsListTagCategoriesResponse, error)

	// TagsCreateTagCategory request with any body
	TagsCreateTagCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsCreateTagCategoryResponse, error)

	TagsCreateTagCategoryWithResponse(ctx context.Context, body TagsCreateTagCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsCreateTagCategoryResponse, error)

	// TagsDeleteTagCategory request
	TagsDeleteTagCategoryWithResponse(ctx context.Context, categoryUuid string, reqEditors ...RequestEditorFn) (*TagsDeleteTagCategoryResponse, error)

	// TagsTagCategoryDetails request
	TagsTagCategoryDetailsWithResponse(ctx context.Context, categoryUuid string, reqEditors ...RequestEditorFn) (*TagsTagCategoryDetailsResponse, error)

	// TagsEditTagCategory request with any body
	TagsEditTagCategoryWithBodyWithResponse(ctx context.Context, categoryUuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsEditTagCategoryResponse, error)

	TagsEditTagCategoryWithResponse(ctx context.Context, categoryUuid string, body TagsEditTagCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsEditTagCategoryResponse, error)

	// TagsListTagValues request
	TagsListTagValuesWithResponse(ctx context.Context, params *TagsListTagValuesParams, reqEditors ...RequestEditorFn) (*TagsListTagValuesResponse, error)

	// TagsCreateTagValue request with any body
	TagsCreateTagValueWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsCreateTagValueResponse, error)

	TagsCreateTagValueWithResponse(ctx context.Context, body TagsCreateTagValueJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsCreateTagValueResponse, error)

	// TagsDeleteTagValuesBulk request with any body
	TagsDeleteTagValuesBulkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsDeleteTagValuesBulkResponse, error)

	TagsDeleteTagValuesBulkWithResponse(ctx context.Context, body TagsDeleteTagValuesBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsDeleteTagValuesBulkResponse, error)

	// TagsDeleteTagValue request
	TagsDeleteTagValueWithResponse(ctx context.Context, valueUuid string, reqEditors ...RequestEditorFn) (*TagsDeleteTagValueResponse, error)

	// TagsTagValueDetails request
	TagsTagValueDetailsWithResponse(ctx context.Context, valueUuid string, reqEditors ...RequestEditorFn) (*TagsTagValueDetailsResponse, error)

	// TagsUpdateTagValue request with any body
	TagsUpdateTagValueWithBodyWithResponse(ctx context.Context, valueUuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsUpdateTagValueResponse, error)

	TagsUpdateTagValueWithResponse(ctx context.Context, valueUuid string, body TagsUpdateTagValueJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsUpdateTagValueResponse, error)

	// TargetGroupsList request
	TargetGroupsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TargetGroupsListResponse, error)

	// TargetGroupsCreate request with any body
	TargetGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TargetGroupsCreateResponse, error)

	TargetGroupsCreateWithResponse(ctx context.Context, body TargetGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TargetGroupsCreateResponse, error)

	// TargetGroupsDelete request
	TargetGroupsDeleteWithResponse(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*TargetGroupsDeleteResponse, error)

	// TargetGroupsDetails request
	TargetGroupsDetailsWithResponse(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*TargetGroupsDetailsResponse, error)

	// TargetGroupsEdit request with any body
	TargetGroupsEditWithBodyWithResponse(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TargetGroupsEditResponse, error)

	TargetGroupsEditWithResponse(ctx context.Context, groupId int32, body TargetGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*TargetGroupsEditResponse, error)

	// IoV2AccessGroupsList request
	IoV2AccessGroupsListWithResponse(ctx context.Context, params *IoV2AccessGroupsListParams, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsListResponse, error)

	// IoV2AccessGroupsCreate request with any body
	IoV2AccessGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsCreateResponse, error)

	IoV2AccessGroupsCreateWithResponse(ctx context.Context, body IoV2AccessGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsCreateResponse, error)

	// IoV2AccessGroupsListFilters request
	IoV2AccessGroupsListFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsListFiltersResponse, error)

	// IoV2AccessGroupsListRuleFilters request
	IoV2AccessGroupsListRuleFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsListRuleFiltersResponse, error)

	// IoV2AccessGroupsDelete request
	IoV2AccessGroupsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsDeleteResponse, error)

	// IoV2AccessGroupsDetails request
	IoV2AccessGroupsDetailsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsDetailsResponse, error)

	// IoV2AccessGroupsEdit request with any body
	IoV2AccessGroupsEditWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsEditResponse, error)

	IoV2AccessGroupsEditWithResponse(ctx context.Context, id string, body IoV2AccessGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsEditResponse, error)

	// ExportsVulnsRequestExport request with any body
	ExportsVulnsRequestExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportsVulnsRequestExportResponse, error)

	ExportsVulnsRequestExportWithResponse(ctx context.Context, body ExportsVulnsRequestExportJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportsVulnsRequestExportResponse, error)

	// ExportsVulnsExportStatusRecent request
	ExportsVulnsExportStatusRecentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportsVulnsExportStatusRecentResponse, error)

	// ExportsVulnsExportCancel request
	ExportsVulnsExportCancelWithResponse(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*ExportsVulnsExportCancelResponse, error)

	// ExportsVulnsDownloadChunk request
	ExportsVulnsDownloadChunkWithResponse(ctx context.Context, exportUuid string, chunkId int32, reqEditors ...RequestEditorFn) (*ExportsVulnsDownloadChunkResponse, error)

	// ExportsVulnsExportStatus request
	ExportsVulnsExportStatusWithResponse(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*ExportsVulnsExportStatusResponse, error)

	// WorkbenchesAssets request
	WorkbenchesAssetsWithResponse(ctx context.Context, params *WorkbenchesAssetsParams, reqEditors ...RequestEditorFn) (*WorkbenchesAssetsResponse, error)

	// WorkbenchesAssetsVulnerabilities request
	WorkbenchesAssetsVulnerabilitiesWithResponse(ctx context.Context, params *WorkbenchesAssetsVulnerabilitiesParams, reqEditors ...RequestEditorFn) (*WorkbenchesAssetsVulnerabilitiesResponse, error)

	// WorkbenchesAssetInfo request
	WorkbenchesAssetInfoWithResponse(ctx context.Context, assetId string, params *WorkbenchesAssetInfoParams, reqEditors ...RequestEditorFn) (*WorkbenchesAssetInfoResponse, error)

	// WorkbenchesAssetVulnerabilities request
	WorkbenchesAssetVulnerabilitiesWithResponse(ctx context.Context, assetId string, params *WorkbenchesAssetVulnerabilitiesParams, reqEditors ...RequestEditorFn) (*WorkbenchesAssetVulnerabilitiesResponse, error)

	// WorkbenchesAssetVulnerabilityInfo request
	WorkbenchesAssetVulnerabilityInfoWithResponse(ctx context.Context, assetId string, pluginId int32, params *WorkbenchesAssetVulnerabilityInfoParams, reqEditors ...RequestEditorFn) (*WorkbenchesAssetVulnerabilityInfoResponse, error)

	// WorkbenchesAssetVulnerabilityOutput request
	WorkbenchesAssetVulnerabilityOutputWithResponse(ctx context.Context, assetId string, pluginId int32, params *WorkbenchesAssetVulnerabilityOutputParams, reqEditors ...RequestEditorFn) (*WorkbenchesAssetVulnerabilityOutputResponse, error)

	// WorkbenchesAssetsDelete request
	WorkbenchesAssetsDeleteWithResponse(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*WorkbenchesAssetsDeleteResponse, error)

	// WorkbenchesAssetsActivity request
	WorkbenchesAssetsActivityWithResponse(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*WorkbenchesAssetsActivityResponse, error)

	// WorkbenchesExportRequest request
	WorkbenchesExportRequestWithResponse(ctx context.Context, params *WorkbenchesExportRequestParams, reqEditors ...RequestEditorFn) (*WorkbenchesExportRequestResponse, error)

	// WorkbenchesExportDownload request
	WorkbenchesExportDownloadWithResponse(ctx context.Context, fileId int32, reqEditors ...RequestEditorFn) (*WorkbenchesExportDownloadResponse, error)

	// WorkbenchesExportStatus request
	WorkbenchesExportStatusWithResponse(ctx context.Context, fileId int32, reqEditors ...RequestEditorFn) (*WorkbenchesExportStatusResponse, error)

	// WorkbenchesVulnerabilities request
	WorkbenchesVulnerabilitiesWithResponse(ctx context.Context, params *WorkbenchesVulnerabilitiesParams, reqEditors ...RequestEditorFn) (*WorkbenchesVulnerabilitiesResponse, error)

	// WorkbenchesVulnerabilityInfo request
	WorkbenchesVulnerabilityInfoWithResponse(ctx context.Context, pluginId int32, params *WorkbenchesVulnerabilityInfoParams, reqEditors ...RequestEditorFn) (*WorkbenchesVulnerabilityInfoResponse, error)

	// WorkbenchesVulnerabilityOutput request
	WorkbenchesVulnerabilityOutputWithResponse(ctx context.Context, pluginId int32, params *WorkbenchesVulnerabilityOutputParams, reqEditors ...RequestEditorFn) (*WorkbenchesVulnerabilityOutputResponse, error)
}

type IoV1AccessGroupsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccessGroups *struct {
			// Specifies whether the access group is the system-provided All Assets access group:
			//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) endpoint.
			//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
			AllAssets *bool `json:"all_assets,omitempty"`

			// Specifies whether assets in the access group can be viewed by all or only some users in your organization:
			//  - If `true`, all users in your organization have Can View access to the assets defined in the rules parameter. If `true` in a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request, Tenable.io ignores any principal parameters in the request.
			//  - If `false`, only specified users have Can View access to the assets defined in the rules parameter. You define which users or user groups have access in the principals parameter of a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request.
			//
			// **Note:** If a [PUT /access-groups/{id}]ref:io-v1-access-groups-edit) endpoint request sets this parameter to `true` for an access group where the parameter was previously set to `false`, Tenable.io removes all principal data previously associated with the access group.
			AllUsers *bool `json:"all_users,omitempty"`

			// The UUID of your Tenable.io instance.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the access group was created.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the access group.
			CreatedByName *string `json:"created_by_name,omitempty"`

			// The UUID of the user who created the access group.
			CreatedByUuid *string `json:"created_by_uuid,omitempty"`

			// The UUID of the access group.
			Id *string `json:"id,omitempty"`

			// The name of the access group. This name must be:
			// * Unique within your Tenable.io instance.
			// * A maximum of 255 characters.
			// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
			Name *string `json:"name,omitempty"`

			// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
			ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

			// The status of the process evaluating and assigning assets to the access group. Possible values are:
			//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
			//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
			//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
			Status *string `json:"status,omitempty"`

			// An ISO timestamp indicating the time and date on which the access group was last modified.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last modified the access group.
			UpdatedByName *string `json:"updated_by_name,omitempty"`

			// The UUID of the user who last modified the access group.
			UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`
		} `json:"access_groups,omitempty"`
		Pagination *struct {
			// The number of records requested (or the default value if omitted from the request).
			Limit *int32 `json:"limit,omitempty"`

			// The starting record you requested (or zero if omitted).
			Offset *int32 `json:"offset,omitempty"`

			// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
			Sort *[]struct {
				// The field on which Tenable.io sorted the results.
				Name *string `json:"name,omitempty"`

				// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
				Order *string `json:"order,omitempty"`
			} `json:"sort,omitempty"`

			// The total number of records matching your search criteria.
			Total *int32 `json:"total,omitempty"`
		} `json:"pagination,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoV1AccessGroupsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV1AccessGroupsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV1AccessGroupsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Specifies whether the access group is the system-provided All Assets access group:
		//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) endpoint.
		//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
		AllAssets *bool `json:"all_assets,omitempty"`

		// Specifies whether assets in the access group can be viewed by all or only some users in your organization:
		//  - If `true`, all users in your organization have Can View access to the assets defined in the rules parameter. If `true` in a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request, Tenable.io ignores any principal parameters in the request.
		//  - If `false`, only specified users have Can View access to the assets defined in the rules parameter. You define which users or user groups have access in the principals parameter of a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request.
		//
		// **Note:** If a [PUT /access-groups/{id}]ref:io-v1-access-groups-edit) endpoint request sets this parameter to `true` for an access group where the parameter was previously set to `false`, Tenable.io removes all principal data previously associated with the access group.
		AllUsers *bool `json:"all_users,omitempty"`

		// The UUID of your Tenable.io instance.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// An ISO timestamp indicating the date and time on which the access group was created.
		CreatedAt *string `json:"created_at,omitempty"`

		// The name of the user who created the access group.
		CreatedByName *string `json:"created_by_name,omitempty"`

		// The UUID of the user who created the access group.
		CreatedByUuid *string `json:"created_by_uuid,omitempty"`

		// The UUID of the access group.
		Id *string `json:"id,omitempty"`

		// The name of the access group. This name must be:
		// * Unique within your Tenable.io instance.
		// * A maximum of 255 characters.
		// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
		Name *string `json:"name,omitempty"`

		// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
		ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

		// The status of the process evaluating and assigning assets to the access group. Possible values are:
		//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
		//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
		//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
		Status *string `json:"status,omitempty"`

		// An ISO timestamp indicating the time and date on which the access group was last modified.
		UpdatedAt *string `json:"updated_at,omitempty"`

		// The name of the user who last modified the access group.
		UpdatedByName *string `json:"updated_by_name,omitempty"`

		// The UUID of the user who last modified the access group.
		UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoV1AccessGroupsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV1AccessGroupsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV1AccessGroupsListFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The filters and operators for each field you can use when constructing filter (`f` parameter) values in the [GET /access-groups](ref:io-v1-access-groups-list) endpoint.
		Filters *[]struct {
			// Indicates how the parameter appears in the Tenable.io user interface.
			Control *string `json:"control,omitempty"`

			// Corresponds to the field component of the `f` parameter.
			Name *string `json:"name,omitempty"`

			// Corresponds to the operator component of the `f` parameter.
			Operators *[]string `json:"operators,omitempty"`

			// The name of the parameter as it appears in the Tenable.io user interface.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filters,omitempty"`

		// The fields you can use when constructing `sort` parameter values for the [GET /access-groups](ref:io-v1-access-groups-list) endpoint.
		Sort *[]struct {
			// The names of the fields you can use when constructing `sort` parameter values for the [GET /access-groups](ref:io-v1-access-groups-list) endpoint.
			SortableFields *string `json:"sortable_fields,omitempty"`
		} `json:"sort,omitempty"`

		// The fields you can use as a wildcard (`wf` parameter) value in the [GET /access-groups](ref:io-v1-access-groups-list) endpoint.
		WildcardFields *[]string `json:"wildcard_fields,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoV1AccessGroupsListFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV1AccessGroupsListFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV1AccessGroupsListRuleFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// An array specifying values to use when constructing an asset rule for the [POST /access-groups](ref:io-v1-access-groups-create) and [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) methods.
		Filters *[]struct {
			// Indicates how the field appears in the Tenable.io user interface.
			Control *string `json:"control,omitempty"`

			// The name of the filter parameter. Corresponds to the asset rule type.
			Name *string `json:"name,omitempty"`

			// The operator that specifies how Tenable.io matches the terms value to asset data. Corresponds to the operator component of the rules parameter. Possible operators include:
			// * eqTenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
			// * matchTenable.io matches the rule to assets based a partial match of the specified term.
			// * startsTenable.io matches the rule to assets that start with the specified term.
			// * endsTenable.io matches the rule to assets that end with the specified term.
			//  * set-hasTenable.io matches the rule to assets based on an exact match of the specified `tag_uuid`.
			//
			// For a complete list of operators by rule type, use the [GET /access-groups/filters](ref:io-v1-access-groups-list-filters) endpoint.
			Operators *[]string `json:"operators,omitempty"`

			// The name of the field as it appears in the Tenable.io user interface.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filters,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoV1AccessGroupsListRuleFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV1AccessGroupsListRuleFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV1AccessGroupsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IoV1AccessGroupsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV1AccessGroupsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV1AccessGroupsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Specifies whether the access group is the system-provided All Assets access group:
		//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) endpoint.
		//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
		AllAssets *bool `json:"all_assets,omitempty"`

		// Specifies whether assets in the access group can be viewed by all or only some users in your organization:
		//  - If `true`, all users in your organization have Can View access to the assets defined in the rules parameter. If `true` in a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request, Tenable.io ignores any principal parameters in the request.
		//  - If `false`, only specified users have Can View access to the assets defined in the rules parameter. You define which users or user groups have access in the principals parameter of a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request.
		//
		// **Note:** If a [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) endpoint request sets this parameter to `true` for an access group where the parameter was previously set to `false`, Tenable.io removes all principal data previously associated with the access group.
		AllUsers *bool `json:"all_users,omitempty"`

		// The UUID of your Tenable.io instance.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// An ISO timestamp indicating the date and time on which the access group was created.
		CreatedAt *string `json:"created_at,omitempty"`

		// The name of the user who created the access group.
		CreatedByName *string `json:"created_by_name,omitempty"`

		// The UUID of the user who created the access group.
		CreatedByUuid *string `json:"created_by_uuid,omitempty"`

		// The UUID of the access group.
		Id *string `json:"id,omitempty"`

		// The name of the access group. This name must be:
		// * Unique within your Tenable.io instance.
		// * A maximum of 255 characters.
		// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
		Name *string `json:"name,omitempty"`

		// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
		Principals *[]struct {
			// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
			PrincipalId *string `json:"principal_id,omitempty"`

			// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
			PrincipalName *string `json:"principal_name,omitempty"`

			// (Required) The type of principal. Valid values include:
			//  - userGrants access to the user you specify.
			//  - groupGrants access to all users assigned to the user group you specify.
			Type *string `json:"type,omitempty"`
		} `json:"principals,omitempty"`

		// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
		ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

		// An array of asset rules. Tenable.io uses these rules to assign assets to the access group. You can specify a maximum of 1,000 rules for an individual access group. If you specify multiple rules for an access group, Tenable.io assigns an asset to the access group if the asset matches any of the rules. You can only add rules to access groups if the `all_assets` parameter is set to `false`.
		Rules *[]struct {
			// The operator that specifies how Tenable.io matches the terms value to asset data.
			//
			// Possible operators include:
			//  - eqTenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
			//  - matchTenable.io matches the rule to assets based a partial match of the specified term.
			//  - startsTenable.io matches the rule to assets that start with the specified term.
			//  - endsTenable.io matches the rule to assets that end with the specified term.
			//  - set-hasTenable.io matches the rule to assets based on an exact match of the specified `tag_uuid`.
			//
			// For a complete list of operators by rule type, use the [GET /access-groups/rules/filters](ref:io-v1-access-groups-list-rule-filters) endpoint.
			Operator *string `json:"operator,omitempty"`

			// The values that Tenable.io uses to match an asset to the rule. A term must correspond to the rule type.
			//
			// For example:
			//  - If the rule type is `aws_account`, the term is an AWS account ID.
			//  - If the rule type is `fqdn`, the term is a hostname or a fully-qualified domain name (FQDN).
			//  - If the rule type is `ipv4`, the term is an individual IPv4 address, a range of IPv4 addresses (for example, 192.0.2.57-192.0.2.60), or a CIDR range (for example, 192.0.2.57/24).
			//
			// For a complete list of supported values by rule type, use the [GET /access-groups/rules/filters](ref:io-v1-access-groups-list-rule-filters) endpoint.
			//
			// If you specify multiple terms values, Tenable.io includes an asset in the access group if the asset's attributes match any of the terms in the rule.
			// <br >You can specify up to 100,000 terms per asset rule.
			Terms *[]string `json:"terms,omitempty"`

			// The type of asset rule. The asset rule type corresponds to the type of data you can specify in the `terms` parameter. For a complete list of supported rule types, use the [GET /access-groups/filters](ref:io-v1-access-groups-list-filters) endpoint.
			Type *string `json:"type,omitempty"`
		} `json:"rules,omitempty"`

		// The status of the process evaluating and assigning assets to the access group. Possible values are:
		//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
		//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
		//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
		Status *string `json:"status,omitempty"`

		// An ISO timestamp indicating the time and date on which the access group was last modified.
		UpdatedAt *string `json:"updated_at,omitempty"`

		// The name of the user who last modified the access group.
		UpdatedByName *string `json:"updated_by_name,omitempty"`

		// The UUID of the user who last modified the access group.
		UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoV1AccessGroupsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV1AccessGroupsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV1AccessGroupsEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Specifies whether the access group is the system-provided All Assets access group:
		//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) endpoint.
		//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
		AllAssets *bool `json:"all_assets,omitempty"`

		// Specifies whether assets in the access group can be viewed by all or only some users in your organization:
		//  - If `true`, all users in your organization have Can View access to the assets defined in the rules parameter. If `true` in a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request, Tenable.io ignores any principal parameters in the request.
		//  - If `false`, only specified users have Can View access to the assets defined in the rules parameter. You define which users or user groups have access in the principals parameter of a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request.
		//
		// **Note:** If a [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) endpoint request sets this parameter to `true` for an access group where the parameter was previously set to `false`, Tenable.io removes all principal data previously associated with the access group.
		AllUsers *bool `json:"all_users,omitempty"`

		// The UUID of your Tenable.io instance.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// An ISO timestamp indicating the date and time on which the access group was created.
		CreatedAt *string `json:"created_at,omitempty"`

		// The name of the user who created the access group.
		CreatedByName *string `json:"created_by_name,omitempty"`

		// The UUID of the user who created the access group.
		CreatedByUuid *string `json:"created_by_uuid,omitempty"`

		// The UUID of the access group.
		Id *string `json:"id,omitempty"`

		// The name of the access group. This name must be:
		// * Unique within your Tenable.io instance.
		// * A maximum of 255 characters.
		// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
		Name *string `json:"name,omitempty"`

		// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
		Principals *[]struct {
			// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
			PrincipalId *string `json:"principal_id,omitempty"`

			// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
			PrincipalName *string `json:"principal_name,omitempty"`

			// (Required) The type of principal. Valid values include:
			//  - userGrants access to the user you specify.
			//  - groupGrants access to all users assigned to the user group you specify.
			Type *string `json:"type,omitempty"`
		} `json:"principals,omitempty"`

		// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
		ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

		// An array of asset rules. Tenable.io uses these rules to assign assets to the access group. You can specify a maximum of 1,000 rules for an individual access group. If you specify multiple rules for an access group, Tenable.io assigns an asset to the access group if the asset matches any of the rules. You can only add rules to access groups if the `all_assets` parameter is set to `false`.
		Rules *[]struct {
			// The operator that specifies how Tenable.io matches the terms value to asset data.
			//
			// Possible operators include:
			//  - eqTenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
			//  - matchTenable.io matches the rule to assets based a partial match of the specified term.
			//  - startsTenable.io matches the rule to assets that start with the specified term.
			//  - endsTenable.io matches the rule to assets that end with the specified term.
			//  - set-hasTenable.io matches the rule to assets based on an exact match of the specified `tag_uuid`.
			//
			// For a complete list of operators by rule type, use the [GET /access-groups/rules/filters](ref:io-v1-access-groups-list-rule-filters) endpoint.
			Operator *string `json:"operator,omitempty"`

			// The values that Tenable.io uses to match an asset to the rule. A term must correspond to the rule type.
			//
			// For example:
			//  - If the rule type is `aws_account`, the term is an AWS account ID.
			//  - If the rule type is `fqdn`, the term is a hostname or a fully-qualified domain name (FQDN).
			//  - If the rule type is `ipv4`, the term is an individual IPv4 address, a range of IPv4 addresses (for example, 192.0.2.57-192.0.2.60), or a CIDR range (for example, 192.0.2.57/24).
			//
			// For a complete list of supported values by rule type, use the [GET /access-groups/rules/filters](ref:io-v1-access-groups-list-rule-filters) endpoint.
			//
			// If you specify multiple terms values, Tenable.io includes an asset in the access group if the asset's attributes match any of the terms in the rule.
			// <br >You can specify up to 100,000 terms per asset rule.
			Terms *[]string `json:"terms,omitempty"`

			// The type of asset rule. The asset rule type corresponds to the type of data you can specify in the `terms` parameter. For a complete list of supported rule types, use the [GET /access-groups/filters](ref:io-v1-access-groups-list-filters) endpoint.
			Type *string `json:"type,omitempty"`
		} `json:"rules,omitempty"`

		// The status of the process evaluating and assigning assets to the access group. Possible values are:
		//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
		//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
		//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
		Status *string `json:"status,omitempty"`

		// An ISO timestamp indicating the time and date on which the access group was last modified.
		UpdatedAt *string `json:"updated_at,omitempty"`

		// The name of the user who last modified the access group.
		UpdatedByName *string `json:"updated_by_name,omitempty"`

		// The UUID of the user who last modified the access group.
		UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoV1AccessGroupsEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV1AccessGroupsEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetsBulkUpdateAcrResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AssetsBulkUpdateAcrResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetsBulkUpdateAcrResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetsBulkDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// The number of assets affected by the operation.
		AssetCount *int `json:"asset_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetsBulkDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetsBulkDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetsBulkMoveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// The number of assets affected by the operation.
		AssetCount *int `json:"asset_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetsBulkMoveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetsBulkMoveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VulnerabilitiesImportV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// This attribute is always empty. An empty value does not indicate an error condition.
		JobUuid *string `json:"job_uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r VulnerabilitiesImportV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VulnerabilitiesImportV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetsListAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A list of assets with details.
		Assets *[]struct {
			// The key drivers that Tenable uses to calculate an asset's Tenable-provided ACR. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			AcrDrivers *[]struct {
				// The type of characteristic.
				DriverName *string `json:"driver_name,omitempty"`

				// The characteristic value.
				DriverValue *[]string `json:"driver_value,omitempty"`
			} `json:"acr_drivers,omitempty"`

			// The Asset Criticality Rating (ACR) for the asset. With Lumin, Tenable assigns an ACR to each asset on your network to represent the asset's relative risk as an integer from 1 to 10. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			AcrScore *int `json:"acr_score,omitempty"`

			// The names of any Nessus agents that scanned and identified the asset.
			AgentName *[]string `json:"agent_name,omitempty"`

			// The name of the virtual machine instance in AWS EC2.
			AwsEc2Name *[]string `json:"aws_ec2_name,omitempty"`

			// The Asset Exposure Score (AES) for the asset. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			ExposureScore *int `json:"exposure_score,omitempty"`

			// A list of fully-qualified domain names (FQDNs) for the asset.
			Fqdn *[]string `json:"fqdn,omitempty"`

			// A value specifying whether a Nessus agent scan detected the asset (`true`).
			HasAgent *bool `json:"has_agent,omitempty"`

			// The UUID of the asset. Use this value as the unique key for the asset.
			Id *string `json:"id,omitempty"`

			// A list of IPv4 addresses for the asset.
			Ipv4 *[]string `json:"ipv4,omitempty"`

			// A list of IPv6 addresses for the asset.
			Ipv6 *[]string `json:"ipv6,omitempty"`

			// The IPv4 address, IPv6 address, or FQDN that the scanner last used to evaluate the asset.
			LastScanTarget *string `json:"last_scan_target,omitempty"`

			// The ISO timestamp of the scan that most recently detected the asset.
			LastSeen *string `json:"last_seen,omitempty"`

			// A list of MAC addresses for the asset.
			MacAddress *[]string `json:"mac_address,omitempty"`

			// The NetBIOS name for the asset.
			NetbiosName *[]string `json:"netbios_name,omitempty"`

			// The operating systems that scans have associated with the asset record.
			OperatingSystem *[]string `json:"operating_system,omitempty"`

			// Information about how often scans ran against the asset during specified intervals. This attribute is only present if you have a Lumin license.
			ScanFrequency *[]struct {
				// The number of times that a scan ran against the asset during the specified interval.
				Frequency *int `json:"frequency,omitempty"`

				// The number of days over which Tenable searches for scans involving the asset.
				Interval *int `json:"interval,omitempty"`

				// Indicates whether the asset was licensed at the time of the identified scans.
				Licensed *bool `json:"licensed,omitempty"`
			} `json:"scan_frequency,omitempty"`

			// The sources of the scans that identified the asset.
			Sources *[][]struct {
				// The ISO timestamp when the source first reported the asset.
				FirstSeen *string `json:"first_seen,omitempty"`

				// The ISO timestamp when the source last reported the asset.
				LastSeen *string `json:"last_seen,omitempty"`

				// The name of the entity that reported the asset details. Sources can include sensors, connectors, and API imports. Source names can be customized by your organization (for example, you specify a name when you import asset records). If your organization does not customize source names, system-generated names include:
				//  - AWSYou obtained the asset data from an Amazon Web Services connector.
				//  - NESSUS_AGENTYou obtained the asset data obtained from a Nessus agent scan.
				//  - PVSYou obtained the asset data from a Nessus Network Monitor (NNM) scan.
				//  - NESSUS_SCANYou obtained the asset data from a Nessus scan.
				//  - WASYou obtained the asset data from a  Web Application Scanning scan.
				Name *string `json:"name,omitempty"`
			} `json:"sources,omitempty"`
		} `json:"assets,omitempty"`

		// The total number of assets in your Tenable.io instance.
		Total *int `json:"total,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetsListAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetsListAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportsAssetsRequestExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The UUID of the assets export job.
		ExportUuid *string `json:"export_uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExportsAssetsRequestExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportsAssetsRequestExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportsAssetsExportStatusRecentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Exports *[]struct {
			// The Unix timestamp when the export job was created.
			Created *int `json:"created,omitempty"`

			// The filters used in the export job request. For a list of possible filters, see the [POST /vulns/export](ref:exports-vulns-export-request-export) and [POST /assets/export](ref:exports-assets-request-export) endpoints.
			Filters *map[string]interface{} `json:"filters,omitempty"`

			// The number of chunks that have been processed and are available for download.
			FinishedChunks *int `json:"finished_chunks,omitempty"`

			// The number of assets contained in each export chunk.
			NumAssetsPerChunk *int `json:"num_assets_per_chunk,omitempty"`

			// The status of the export request. Possible values include:
			//  - QUEUEDTenable.io has queued the export request until it completes other requests currently in process.
			//  - PROCESSINGTenable.io has started processing the export request.
			//  - FINISHEDTenable.io has completed processing the export request. The list of chunks is complete.
			//  - CANCELLEDAn administrator has cancelled the export request.
			//  - ERRORTenable.io encountered an error while processing the export request. Tenable recommends that you retry the request. If the status persists on retry, contact Support.
			Status *string `json:"status,omitempty"`

			// The total number of chunks associated with the export job as a whole.
			TotalChunks *int `json:"total_chunks,omitempty"`

			// The UUID for the export request.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"exports,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExportsAssetsExportStatusRecentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportsAssetsExportStatusRecentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportsAssetsExportCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Text describing the export job status, `CANCELLED`.
		Status *string `json:"status,omitempty"`
	}
	JSON400 *struct {
		// Text describing the error condition Tenable.io encountered. Possible values include:
		//
		//  - Cannot cancel a completed job
		//  - Export UUID is invalid
		Message *string `json:"message,omitempty"`

		// The HTTP error code.
		Status *int `json:"status,omitempty"`
	}
	JSON404 *struct {
		// Text describing the error condition Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP error code.
		Status *int `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExportsAssetsExportCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportsAssetsExportCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportsAssetsDownloadChunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The Asset Criticality Rating (ACR) for the asset. With Lumin, Tenable assigns an ACR to each asset on your network to represent the asset's relative risk as an integer from 1 to 10. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
		//
		// This attribute is only present if you have a Lumin license.
		AcrScore *string `json:"acr_score,omitempty"`

		// The names of any Nessus agents that scanned and identified the asset.
		AgentNames *[]string `json:"agent_names,omitempty"`

		// The unique identifier of the Nessus agent that identified the asset.
		AgentUuid *string `json:"agent_uuid,omitempty"`

		// The availability zone where Amazon Web Services hosts the virtual machine instance, for example, `us-east-1a``. Availability zones are subdivisions of AWS regions. For more information, see "Regions and Availability Zones" in the AWS documentation.
		AwsAvailabilityZone *string `json:"aws_availability_zone,omitempty"`

		// The unique identifier of the Linux AMI image in Amazon Elastic Compute Cloud (Amazon EC2). For more information, see the Amazon Elastic Compute Cloud Documentation.
		AwsEc2InstanceAmiId *string `json:"aws_ec2_instance_ami_id,omitempty"`

		// The virtual machine instance's group in AWS.
		AwsEc2InstanceGroupName *string `json:"aws_ec2_instance_group_name,omitempty"`

		// The unique identifier of the Linux instance in Amazon EC2. For more information, see the Amazon Elastic Compute Cloud Documentation.
		AwsEc2InstanceId *string `json:"aws_ec2_instance_id,omitempty"`

		// The state of the virtual machine instance in AWS at the time of the scan.
		AwsEc2InstanceStateName *string `json:"aws_ec2_instance_state_name,omitempty"`

		// The type of instance in AWS EC2.
		AwsEc2InstanceType *string `json:"aws_ec2_instance_type,omitempty"`

		// The name of the virtual machine instance in AWS EC2.
		AwsEc2Name *string `json:"aws_ec2_name,omitempty"`

		// The product code associated with the AMI used to launch the virtual machine instance in AWS EC2.
		AwsEc2ProductCode *string `json:"aws_ec2_product_code,omitempty"`

		// The canonical user identifier for the AWS account associated with the virtual machine instance. For example, `79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be`. For more information, see AWS Account Identifiers in the AWS documentation.
		AwsOwnerId *string `json:"aws_owner_id,omitempty"`

		// The region where AWS hosts the virtual machine instance, for example, `us-east-1`. For more information, see "Regions and Availability Zones" in the AWS documentation.
		AwsRegion *string `json:"aws_region,omitempty"`

		// The unique identifier of the AWS subnet where the virtual machine instance was running at the time of the scan.
		AwsSubnetId *string `json:"aws_subnet_id,omitempty"`

		// The unique identifier for the virtual public cloud that hosts the AWS virtual machine instance. For more information, see the Amazon Virtual Private Cloud User Guide.
		AwsVpcId *string `json:"aws_vpc_id,omitempty"`

		// The unique identifier of the resource in the Azure Resource Manager. For more information, see the Azure Resource Manager Documentation.
		AzureResourceId *string `json:"azure_resource_id,omitempty"`

		// The unique identifier of the Microsoft Azure virtual machine instance. For more information, see "Accessing and Using Azure VM Unique ID" in the Microsoft Azure documentation.
		AzureVmId *string `json:"azure_vm_id,omitempty"`

		// The unique identifiers of the asset in HCL BigFix. For more information, see the HCL BigFix documentation.
		BigfixAssetId *string `json:"bigfix_asset_id,omitempty"`

		// The BIOS UUID of the asset.
		BiosUuid *string `json:"bios_uuid,omitempty"`

		// The time and date when Tenable.io created the asset record.
		CreatedAt *string `json:"created_at,omitempty"`

		// The time and date when a user deleted the asset record. When a user deletes an asset record, Tenable.io retains the record until the asset ages out of the license count.
		DeletedAt *string `json:"deleted_at,omitempty"`

		// The user who deleted the asset record.
		DeletedBy *string `json:"deleted_by,omitempty"`

		// The Asset Exposure Score (AES) for the asset. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
		//
		// This attribute is only present if you have a Lumin license.
		ExposureScore *string `json:"exposure_score,omitempty"`

		// The time and date of the first scan run against the asset.
		FirstScanTime *string `json:"first_scan_time,omitempty"`

		// The time and date when a scan first identified the asset.
		FirstSeen *string `json:"first_seen,omitempty"`

		// The fully-qualified domain names that scans have associated with the asset record.
		Fqdns *[]string `json:"fqdns,omitempty"`

		// The zone where the virtual machine instance runs in GCP. For more information, see "Regions and Zones" in the GCP documentation.
		GcpInstanceId *string `json:"gcp_instance_id,omitempty"`

		// The unique identifier of the virtual machine instance in Google Cloud Platform (GCP).
		GcpProjectId *string `json:"gcp_project_id,omitempty"`

		// The customized name of the project to which the virtual machine instance belongs in GCP. For more information see "Creating and Managing Projects" in the GCP documentation.
		GcpZone *string `json:"gcp_zone,omitempty"`

		// Specifies whether a Nessus agent scan identified the asset.
		HasAgent *bool `json:"has_agent,omitempty"`

		// Specifies whether the asset has plugin results associated with it.
		HasPluginResults *bool `json:"has_plugin_results,omitempty"`

		// The hostnames that scans have associated with the asset record.
		Hostnames *[]string `json:"hostnames,omitempty"`

		// The UUID of the asset in Tenable.io. Use this value as the unique key for the asset.
		Id *string `json:"id,omitempty"`

		// A list of Common Platform Enumeration (CPE) values that represent software applications a scan identified as present on an asset. This attribute supports the CPE 2.2 format. For more information, see the "Component Syntax" section of the [CPE Specification, Version 2.2](https://cpe.mitre.org/files/cpe-specification_2.2.pdf). For assets identified in Tenable scans, this attribute contains data only if a scan using [Nessus Plugin ID 45590](https://www.tenable.com/plugins/nessus/45590) has evaluated the asset.
		//
		// **Note:** If no scan detects an application within 30 days of the scan that originally detected the application, Tenable.io considers the detection of that application expired. As a result, the next time a scan evaluates the asset, Tenable.io removes the expired application from the installed_software attribute. This activity is logged as a `remove` type of `attribute_change` update in the asset activity log.
		InstalledSoftware *[]string `json:"installed_software,omitempty"`

		// The IPv4 addresses that scans have associated with the asset record.
		Ipv4s *[]string `json:"ipv4s,omitempty"`

		// The IPv6 addresses that scans have associated with the asset record.
		Ipv6s *[]string `json:"ipv6s,omitempty"`

		// The time and date of the last credentialed scan run on the asset.
		LastAuthenticatedScanDate *string `json:"last_authenticated_scan_date,omitempty"`

		// The time and date of the last scan that identified the asset as licensed. Tenable.io categorizes an asset as licensed if a scan of that asset has returned results from a non-discovery plugin within the last 90 days.
		LastLicensedScanDate *string `json:"last_licensed_scan_date,omitempty"`

		// The UUID of the scan configuration used during the last scan of the asset.
		LastScanId *string `json:"last_scan_id,omitempty"`

		// The time and date of the last scan run against the asset.
		LastScanTime *string `json:"last_scan_time,omitempty"`

		// The `schedule_uuid` for the last scan of the asset.
		LastScheduleId *string `json:"last_schedule_id,omitempty"`

		// The time and date of the scan that most recently identified the asset.
		LastSeen *string `json:"last_seen,omitempty"`

		// The MAC addresses that scans have associated with the asset record.
		MacAddresses *[]string `json:"mac_addresses,omitempty"`

		// The manufacturer's unique identifiers of the Trusted Platform Module (TPM) associated with the asset.
		ManufacturerTpmIds *[]string `json:"manufacturer_tpm_ids,omitempty"`

		// The unique identifier of the McAfee ePO agent that identified the asset. For more information, see the McAfee documentation.
		McafeeEpoAgentGuid *string `json:"mcafee_epo_agent_guid,omitempty"`

		// The unique identifier of the asset in McAfee ePolicy Orchestrator (ePO). For more information, see the McAfee documentation.
		McafeeEpoGuid *string `json:"mcafee_epo_guid,omitempty"`

		// The NetBIOS names that scans have associated with the asset record.
		NetbiosNames *[]string `json:"netbios_names,omitempty"`

		// The ID of the network object associated with scanners that identified the asset. The default network ID is `00000000-0000-0000-0000-000000000000`. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkId *string `json:"network_id,omitempty"`

		// The network interfaces that scans identified on the asset.
		NetworkInterfaces *[]struct {
			// One or more FQDN belonging to the interface.
			Fqdn *[]string `json:"fqdn,omitempty"`

			// One or more IPv4 addresses belonging to the interface.
			Ipv4 *[]string `json:"ipv4,omitempty"`

			// One or more IPv6 addresses belonging to the interface.
			Ipv6 *[]string `json:"ipv6,omitempty"`

			// The MAC addresses of the interface.
			MacAddress *[]string `json:"mac_address,omitempty"`

			// The name of the interface.
			Name *string `json:"name,omitempty"`
		} `json:"network_interfaces,omitempty"`

		// The ID of the network object associated with scanners that identified the asset. The default network name is `Default`. All other network names are user-defined. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkName *string `json:"network_name,omitempty"`

		// The operating systems that scans have associated with the asset record.
		OperatingSystems *[]string `json:"operating_systems,omitempty"`

		// The Asset ID of the asset in Qualys. For more information, see the Qualys documentation.
		//
		// **Note:** Tenable is enabling Qualys asset import for customers in a rolling fashion. For more information, contact your Tenable representative.
		QualysAssetIds *[]string `json:"qualys_asset_ids,omitempty"`

		// The Host ID of the asset in Qualys. For more information, see the Qualys documentation.
		//
		// **Note:** Tenable is enabling Qualys asset import for customers in a rolling fashion. For more information, contact your Tenable representative.
		QualysHostIds *[]string `json:"qualys_host_ids,omitempty"`

		// The unique record identifier of the asset in ServiceNow. For more information, see the ServiceNow documentation.
		ServicenowSysid *string `json:"servicenow_sysid,omitempty"`

		// The sources of the scans that identified the asset.
		Sources *[]struct {
			// The ISO timestamp when the source first reported the asset.
			FirstSeen *string `json:"first_seen,omitempty"`

			// The ISO timestamp when the source last reported the asset.
			LastSeen *string `json:"last_seen,omitempty"`

			// The name of the entity that reported the asset details. Sources can include sensors, connectors, and API imports. Source names can be customized by your organization (for example, you specify a name when you import asset records). If your organization does not customize source names, system-generated names include:
			//  - AWSYou obtained the asset data from an Amazon Web Services connector.
			//  - NESSUS_AGENTYou obtained the asset data obtained from a Nessus agent scan.
			//  - PVSYou obtained the asset data from a Nessus Network Monitor (NNM) scan.
			//  - NESSUS_SCANYou obtained the asset data from a Nessus scan.
			//  - WASYou obtained the asset data from a  Web Application Scanning scan.
			Name *string `json:"name,omitempty"`
		} `json:"sources,omitempty"`

		// The SSH key fingerprints that scans have associated with the asset record.
		SshFingerprints *[]string `json:"ssh_fingerprints,omitempty"`

		// The hardware keys for the asset in Symantec Endpoint Protection.
		SymantecEpHardwareKeys *[]string `json:"symantec_ep_hardware_keys,omitempty"`

		// The system types as reported by Plugin ID 54615. Possible values include `router`, `general-purpose`, `scan-host`, and `embedded`.
		SystemTypes *[]string `json:"system_types,omitempty"`

		// Category tags assigned to the asset in Tenable.io.
		Tags *[]struct {
			// The ISO timestamp when the tag was assigned to the asset.
			AddedAt *string `json:"added_at,omitempty"`

			// The UUID of the user who assigned the tag to the asset.
			AddedBy *string `json:"added_by,omitempty"`

			// The tag category(the first half of the category:value pair).
			Key *string `json:"key,omitempty"`

			// The UUID of the tag.
			Uuid *string `json:"uuid,omitempty"`

			// The tag value (the second half of the category:value pair).
			Value *string `json:"value,omitempty"`
		} `json:"tags,omitempty"`

		// The time and date when a user terminated the Amazon Web Service (AWS) virtual machine instance of the asset.
		TerminatedAt *string `json:"terminated_at,omitempty"`

		// The user who terminated the AWSinstance of the asset.
		TerminatedBy *string `json:"terminated_by,omitempty"`

		// The time and date when the asset record was last updated.
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExportsAssetsDownloadChunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportsAssetsDownloadChunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportsAssetsExportStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A comma-separated list of completed chunks available for download.
		ChunksAvailable *[]int32 `json:"chunks_available,omitempty"`

		// Information about the export job.
		Status *struct {
			// A list of completed chunks available for download.
			ChunksAvailable *[]int32 `json:"chunks_available,omitempty"`

			// The status of the export request. Possible values include:
			//  - QUEUEDTenable.io has queued the export request until it completes other requests currently in process.
			//  - PROCESSINGTenable.io has started processing the export request.
			//  - FINISHEDTenable.io has completed processing the export request. The list of chunks is complete.
			//  - CANCELLEDAn administrator has cancelled the export request.
			//  - ERRORTenable.io encountered an error while processing the export request. Tenable recommends that you retry the request. If the status persists on retry, contact Support.
			Status *string `json:"status,omitempty"`
		} `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExportsAssetsExportStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportsAssetsExportStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetsAssetInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The key drivers that Tenable uses to calculate an asset's Tenable-provided ACR. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
		//
		// This attribute is only present if you have a Lumin license.
		AcrDrivers *[]struct {
			// The type of characteristic.
			DriverName *string `json:"driver_name,omitempty"`

			// The characteristic value.
			DriverValue *[]string `json:"driver_value,omitempty"`
		} `json:"acr_drivers,omitempty"`

		// The Asset Criticality Rating (ACR) for the asset. Tenable assigns an ACR to each asset on your network to represent the asset's relative risk as an integer from 1 to 10. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
		//
		// This attribute is only present if you have a Lumin license.
		AcrScore *int `json:"acr_score,omitempty"`

		// The names of any Nessus agents that scanned and identified the asset.
		AgentName *[]string `json:"agent_name,omitempty"`

		// The availability zone where Amazon Web Services hosts the virtual machine instance, for example, `us-east-1a`. Availability zones are subdivisions of AWS regions. For more information, see Regions and Availability Zones in the AWS documentation.
		AwsAvailabilityZone *[]string `json:"aws_availability_zone,omitempty"`

		// The unique identifier of the Linux AMI image in Amazon Elastic Compute Cloud (Amazon EC2). For more information, see the Amazon Elastic Compute Cloud Documentation.
		AwsEc2InstanceAmiId *[]string `json:"aws_ec2_instance_ami_id,omitempty"`

		// The virtual machine instance's group in AWS.
		AwsEc2InstanceGroupName *[]string `json:"aws_ec2_instance_group_name,omitempty"`

		// The unique identifier of the Linux instance in Amazon EC2. For more information, see the Amazon Elastic Compute Cloud Documentation.
		AwsEc2InstanceId *[]string `json:"aws_ec2_instance_id,omitempty"`

		// The state of the virtual machine instance in AWS at the time of the scan. For more information on instance states, see the AWS documentation.
		AwsEc2InstanceStateName *[]string `json:"aws_ec2_instance_state_name,omitempty"`

		// The type of instance in AWS EC2.
		AwsEc2InstanceType *[]string `json:"aws_ec2_instance_type,omitempty"`

		// The name of the virtual machine instance in AWS EC2.
		AwsEc2Name *[]string `json:"aws_ec2_name,omitempty"`

		// The product code associated with the AMI used to launch the virtual machine instance in AWS EC2.
		AwsEc2ProductCode *[]string `json:"aws_ec2_product_code,omitempty"`

		// The canonical user identifier for the AWS account associated with the virtual machine instance. For example, `79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be`. For more information, see AWS Account Identifiers in the AWS documentation.
		AwsOwnerId *[]string `json:"aws_owner_id,omitempty"`

		// The region where AWS hosts the virtual machine instance, for example, `us-east-1`. For more information, see Regions and Availability Zones in the AWS documentation.
		AwsRegion *[]string `json:"aws_region,omitempty"`

		// The unique identifier of the AWS subnet where the virtual machine instance was running at the time of the scan.
		AwsSubnetId *[]string `json:"aws_subnet_id,omitempty"`

		// The unique identifier for the public cloud that hosts the AWS virtual machine instance. For more information, see the Amazon Virtual Private Cloud User Guide.
		AwsVpcId *[]string `json:"aws_vpc_id,omitempty"`

		// The unique identifier of the resource in the Azure Resource Manager. For more information, see the Azure Resource Manager Documentation.
		AzureResourceId *[]string `json:"azure_resource_id,omitempty"`

		// The unique identifier of the Microsoft Azure virtual machine instance. For more information, see "Accessing and Using Azure VM Unique ID" in the Microsoft Azure documentation.
		AzureVmId *[]string `json:"azure_vm_id,omitempty"`

		// The BIOS UUID that scans have associated with the asset.
		BiosUuid *[]string `json:"bios_uuid,omitempty"`

		// The time and date when Tenable.io created the asset record.
		CreatedAt *string `json:"created_at,omitempty"`

		// The Asset Exposure Score (AES) for the asset. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
		ExposureScore *int `json:"exposure_score,omitempty"`

		// The time and date when a scan first identified the asset.
		FirstSeen *string `json:"first_seen,omitempty"`

		// The fully-qualified domain names that scans have associated with the asset record.
		Fqdn *[]string `json:"fqdn,omitempty"`

		// The unique identifier of the virtual machine instance in GCP.
		GcpInstanceId *[]string `json:"gcp_instance_id,omitempty"`

		// The customized name of the project to which the virtual machine instance belongs in Google Cloud Platform (GCP). For more information, see "Creating and Managing Projects" in the GCP documentation.
		GcpProjectId *[]string `json:"gcp_project_id,omitempty"`

		// The zone where the virtual machine instance runs in GCP. For more information, see "Regions and Zones" in the GCP documentation.
		GcpZone *[]string `json:"gcp_zone,omitempty"`

		// Indicates if a Nessus agent scan detected the asset.
		HasAgent *bool `json:"has_agent,omitempty"`

		// The hostnames that scans have associated with the asset record.
		Hostname *[]string `json:"hostname,omitempty"`

		// The UUID of the asset. Use this value as the unique key for the asset.
		Id *string `json:"id,omitempty"`

		// A list of Common Platform Enumeration (CPE) values that represent software applications a scan identified as present on an asset. This attribute supports the CPE 2.2 format. For more information, see the "Component Syntax" section of the [CPE Specification, Version 2.2](https://cpe.mitre.org/files/cpe-specification_2.2.pdf). For assets identified in Tenable scans, this attribute contains data only if a scan using [Nessus Plugin ID 45590](https://www.tenable.com/plugins/nessus/45590) has evaluated the asset.
		//
		// **Note:** If no scan detects an application within 30 days of the scan that originally detected the application, Tenable.io considers the detection of that application expired. As a result, the next time a scan evaluates the asset, Tenable.io removes the expired application from the installed_software attribute. This activity is logged as a `remove` type of `attribute_change` update in the asset activity log.
		InstalledSoftware *[]string `json:"installed_software,omitempty"`

		// The IPv4 addresses that scans have associated with the asset record.
		Ipv4 *[]string `json:"ipv4,omitempty"`

		// The IPv6 addresses that scans have associated with the asset record.
		Ipv6 *[]string `json:"ipv6,omitempty"`

		// The time and date of the last credentialed scan run on the asset.
		LastAuthenticatedScanDate *string `json:"last_authenticated_scan_date,omitempty"`

		// The time and date of the last scan that identified the asset as licensed. Tenable.io categorizes an asset as licensed if a scan of that asset has returned results from a non-discovery plugin within the last 90 days.
		LastLicensedScanDate *string `json:"last_licensed_scan_date,omitempty"`

		// The IPv4 address, IPv6 address, or FQDN that the scanner last used to evaluate the asset.
		LastScanTarget *string `json:"last_scan_target,omitempty"`

		// The time and date of the scan that most recently identified the asset.
		LastSeen *string `json:"last_seen,omitempty"`

		// The MAC addresses that scans have associated with the asset record.
		MacAddress *[]string `json:"mac_address,omitempty"`

		// The unique identifier of the McAfee ePO agent that identified the asset. For more information, see the McAfee documentation.
		McafeeEpoAgentGuid *[]string `json:"mcafee_epo_agent_guid,omitempty"`

		// The unique identifier of the asset in McAfee ePolicy Orchestrator (ePO). For more information, see the McAfee documentation.
		McafeeEpoGuid *[]string `json:"mcafee_epo_guid,omitempty"`

		// The NetBIOS names that scans have associated with the asset record.
		NetbiosName *[]string `json:"netbios_name,omitempty"`

		// The ID of the network object to which the asset belongs. For more information, see [Manage Networks](doc:manage-networks-tio).
		NetworkId *[]string `json:"network_id,omitempty"`

		// The operating systems that scans have associated with the asset record.
		OperatingSystem *[]string `json:"operating_system,omitempty"`

		// The Asset ID of the asset in Qualys. For more information, see the Qualys documentation.
		QualysAssetId *[]string `json:"qualys_asset_id,omitempty"`

		// The Host ID of the asset in Qualys. For more information, see the Qualys documentation.
		QualysHostId *[]string `json:"qualys_host_id,omitempty"`

		// Information about how often scans ran against the asset during specified intervals.
		ScanFrequency *[]struct {
			// The number of times that a scan ran against the asset during the specified interval.
			Frequency *int `json:"frequency,omitempty"`

			// The number of days over which Tenable searches for scans involving the asset.
			Interval *int `json:"interval,omitempty"`

			// Indicates whether the asset was licensed at the time of the identified scans.
			Licensed *bool `json:"licensed,omitempty"`
		} `json:"scan_frequency,omitempty"`

		// The unique record identifier of the asset in ServiceNow. For more information, see the ServiceNow documentation.
		ServicenowSysid *[]string `json:"servicenow_sysid,omitempty"`

		// The sources of the scans that identified the asset.
		Sources *[][]struct {
			// The ISO timestamp when the source first reported the asset.
			FirstSeen *string `json:"first_seen,omitempty"`

			// The ISO timestamp when the source last reported the asset.
			LastSeen *string `json:"last_seen,omitempty"`

			// The name of the entity that reported the asset details. Sources can include sensors, connectors, and API imports. Source names can be customized by your organization (for example, you specify a name when you import asset records). If your organization does not customize source names, system-generated names include:
			//  - AWSYou obtained the asset data from an Amazon Web Services connector.
			//  - NESSUS_AGENTYou obtained the asset data obtained from a Nessus agent scan.
			//  - PVSYou obtained the asset data from a Nessus Network Monitor (NNM) scan.
			//  - NESSUS_SCANYou obtained the asset data from a Nessus scan.
			//  - WASYou obtained the asset data from a  Web Application Scanning scan.
			Name *string `json:"name,omitempty"`
		} `json:"sources,omitempty"`

		// The SSH key fingerprints that scans have associated with the asset record.
		SshFingerprint *[]string `json:"ssh_fingerprint,omitempty"`

		// The system types as reported by Plugin ID 54615. Possible values include `router`, `general-purpose`, `scan-host`, and `embedded`.
		SystemType *[]string `json:"system_type,omitempty"`

		// Category tags assigned to the asset in Tenable.io.
		Tags *[]struct {
			// The ISO timestamp when the tag was assigned to the asset.
			AddedAt *string `json:"added_at,omitempty"`

			// The UUID of the user who assigned the tag to the asset.
			AddedBy *string `json:"added_by,omitempty"`

			// The tag category(the first half of the category:value pair).
			TagKey *string `json:"tag_key,omitempty"`

			// The UUID of the tag.
			TagUuid *string `json:"tag_uuid,omitempty"`

			// The tag value (the second half of the category:value pair).
			TagValue *string `json:"tag_value,omitempty"`
		} `json:"tags,omitempty"`

		// The UUID of the agent if an agent is present on the asset. If no agent is present on the asset, then the UUID is a unique identifier assigned by Tenable.io during a credentialed scan when the [Create unique identifier on hosts scanned with credentials](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/Classic/AdvancedSettings.htm) option is enabled. Note that no UUID is set for uncredentialed, non-agent scans.
		TenableUuid *[]string `json:"tenable_uuid,omitempty"`

		// The time and date when the asset record was last updated.
		UpdatedAt *string `json:"updated_at,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetsAssetInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetsAssetInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuditLogEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// The action that was taken by the user.
		Action *string `json:"action,omitempty"`
		Actor  *struct {
			// The UUID of the user that took the action.
			Id *string `json:"id,omitempty"`

			// The username of the user that took the action.
			Name *string `json:"name,omitempty"`
		} `json:"actor,omitempty"`

		// Indicates whether the action taken was creating (c), reading (r), updating (u), or deleting (d) an entity.
		Crud *string `json:"crud,omitempty"`

		// A description of the event.
		Description *string `json:"description,omitempty"`
		Fields      *struct {
			Pair *struct {
				// A key. The exact string varies based on the action that was taken.
				Key *string `json:"key,omitempty"`

				// A value that corresponds to a key. The value varies based on the request of the action that was taken.
				Value *string `json:"value,omitempty"`
			} `json:"pair,omitempty"`
		} `json:"fields,omitempty"`

		// The unique ID of the event.
		Id *string `json:"id,omitempty"`

		// Indicates whether the action was performed anonymously.
		IsAnonymous *bool `json:"is_anonymous,omitempty"`

		// Indicates whether the action the user took succeeded or failed. Tenable.io logs an event regardless of whether a user action succeeds.
		IsFailure *bool `json:"is_failure,omitempty"`

		// The date and time the event occured in ISO 8601 format.
		Received *string `json:"received,omitempty"`
		Target   *struct {
			// The UUID of the target entity. For example, a user UUID.
			Id *string `json:"id,omitempty"`

			// The name of the target entity. For example, a username.
			Name *string `json:"name,omitempty"`

			// The type of entity that was the target of the action. For example, a user.
			Type *string `json:"type,omitempty"`
		} `json:"target,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AuditLogEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuditLogEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoExportsComplianceCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The UUID of the compliance export job.
		ExportUuid *string `json:"export_uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoExportsComplianceCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoExportsComplianceCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoExportsComplianceCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IoExportsComplianceCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoExportsComplianceCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoExportsComplianceDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// The actual value (integer, string, or table) evaluated from the compliance check. For example, if a password length compliance check requires passwords to be 8 characters long, but the evaluated value was 7 then `7` is the actual value. For manual checks, this field will contain the output of the command that was executed.
		ActualValue *string `json:"actual_value,omitempty"`

		// The UUID of the asset on which the compliance check was executed.
		AssetUuid *string `json:"asset_uuid,omitempty"`

		// The name of the audit file containing the compliance check.
		AuditFile *string `json:"audit_file,omitempty"`

		// An error message if the compliance evaluation fails.
		CheckError *string `json:"check_error,omitempty"`

		// The unique identifier for the compliance finding.
		CheckId *string `json:"check_id,omitempty"`

		// Full text description of the compliance check.
		CheckInfo *string `json:"check_info,omitempty"`

		// The descriptive name of the compliance check.
		CheckName *string `json:"check_name,omitempty"`

		// The type of database if the compliance check assessed a database.
		DbType *string `json:"db_type,omitempty"`

		// The desired value (integer or string) for the compliance check. For example, if a password length compliance check requires passwords to be 8 characters long then `8` is the expected value. For manual checks, this field will contain the command used for the compliance check.
		ExpectedValue *string `json:"expected_value,omitempty"`

		// The Unix timestamp when a compliance scan first assessed the asset with the compliance check.
		FirstSeen *int64 `json:"first_seen,omitempty"`

		// The Unix timestamp when a compliance scan last assessed the asset with the compliance check.
		LastSeen *int64 `json:"last_seen,omitempty"`

		// The unique ID of the compliance plugin.
		PluginId *int `json:"plugin_id,omitempty"`

		// The name of the profile for the benchmark standard.
		ProfileName *string `json:"profile_name,omitempty"`

		// Industry references for the compliance check.
		Reference *[]struct {
			// The specific control within the compliance framework.
			Control *string `json:"control,omitempty"`

			// The name of the compliance framework.
			Framework *string `json:"framework,omitempty"`
		} `json:"reference,omitempty"`

		// Links to external websites that contain reference information about the compliance check.
		SeeAlso *string `json:"see_also,omitempty"`

		// Remediation information for the compliance check.
		Solution *string `json:"solution,omitempty"`

		// Indicates the result of the compliance check for the given asset.
		//
		// Possible values include:
		//  - PASSEDReturned if the asset has passed the compliance check.
		//  - FAILEDReturned if the asset has failed the compliance check.
		//  - WARNINGReturned in cases where there is no definable passing criteria; for example, an audit where you must verify that members of the administrator group are appropriate for your organization.
		//  - SKIPPEDReturned if the plugin determines that the check is not applicable to the asset. It can also be returned in other various cases; for example, when a check requires that a direct command be run to gather data on an offline network device or if a check contains commands that won't run on the specified OS.
		//  - UNKOWNReturned when a status cannot be determined for the OVAL check. This status is set by the OVAL engine.
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoExportsComplianceDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoExportsComplianceDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoExportsComplianceStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A comma-separated list of completed chunks available for download.
		ChunksAvailable *[]int32 `json:"chunks_available,omitempty"`

		// The status of the compliance export request. Possible values include:
		//  - PROCESSINGTenable.io has started processing the compliance export request.
		//  - FINISHEDTenable.io has completed processing the export request, the list of chunks is complete, and all chunks are available for download.
		//  - READYSome chunks are now available for download, but Tenable.io is still processing the export request.
		//  - CANCELLEDAn administrator has canceled the export request.
		//  - ERRORTenable.io encountered an error while processing the export request. Tenable recommends that you retry the request. If the status persists on retry, contact Support.
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoExportsComplianceStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoExportsComplianceStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CredentialsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Credentials *[]struct {
			Category *struct {
				// The system name that uniquely identifies the credential category.
				Id *string `json:"id,omitempty"`

				// The display name for the credential category in the user interface.
				Name *string `json:"name,omitempty"`
			} `json:"category,omitempty"`
			CreatedBy *struct {
				// The name of the user who created the credential.
				DisplayName *string `json:"display_name,omitempty"`

				// The ID of the user who created the credential.
				Id *int `json:"id,omitempty"`
			} `json:"created_by,omitempty"`

			// The date (in Unix time) when the managed credential object was created.
			CreatedDate *string `json:"created_date,omitempty"`

			// The definition of the managed credential object. You can specify the description when you create or update the managed credential.
			Description *string `json:"description,omitempty"`
			LastUsedBy  *struct {
				// The name of the user who last used the credential in a scan.
				DisplayName *string `json:"display_name,omitempty"`

				// The ID of the user who last used the credential in a scan.
				Id *int `json:"id,omitempty"`
			} `json:"last_used_by,omitempty"`

			// The name of the managed credential object. You specify the name when you create or update the managed credential.
			Name *string `json:"name,omitempty"`

			// A value specifying the permissions granted to the user or user group for the credential. For possible values, see "Credential Roles" in [Permissions](doc:permissions).
			Permissions *int `json:"permissions,omitempty"`
			Type        *struct {
				// The system name that uniquely identifies the credential type.
				Id *string `json:"id,omitempty"`

				// The display name for the credential type in the user interface.
				Name *string `json:"name,omitempty"`
			} `json:"type,omitempty"`

			// The permissions for the managed credential that are assigned to the user account submitting the API request. For possible values, see "Credential Roles" in [Permissions](doc:permissions).
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the managed credential object.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"credentials,omitempty"`
		Pagination *struct {
			// The number of records requested (or the default value if omitted from the request).
			Limit *int32 `json:"limit,omitempty"`

			// The starting record you requested (or zero if omitted).
			Offset *int32 `json:"offset,omitempty"`

			// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
			Sort *[]struct {
				// The field on which Tenable.io sorted the results.
				Name *string `json:"name,omitempty"`

				// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
				Order *string `json:"order,omitempty"`
			} `json:"sort,omitempty"`

			// The total number of records matching your search criteria.
			Total *int32 `json:"total,omitempty"`
		} `json:"pagination,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CredentialsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CredentialsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CredentialsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The UUID of the new managed credential object.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CredentialsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CredentialsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CredentialsFileUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The name of the uploaded file. If the file with the same name already exists, Tenable.io appends an underscore with a number, for example ssh_private_key_1.txt. Use this attribute value when referencing the file for subsequent requests.
		Fileuploaded *string `json:"fileuploaded,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CredentialsFileUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CredentialsFileUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CredentialsListCredentialTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Credentials *[]struct {
			// The display name for the category in the user interface.
			Category *string `json:"category,omitempty"`

			// A value specifying whether the list of credential types in the category appears as expanded by default in the user interface.
			DefaultExpand *bool `json:"default_expand,omitempty"`

			// The system name that uniquely identifies the category in Tenable.io.
			Id *string `json:"id,omitempty"`

			// Supported configuration settings for an individual credential type.
			Types *[]struct {
				// The configuration settings for a credential type. For a definition of object attributes, see [Determine Settings for a Credential Type](docs/determine-settings-for-credential-type).
				Configuration *[]struct {
					// Not supported as a parameter in managed credentials.
					AltIds *string `json:"alt_ids,omitempty"`

					// The option that appears as selected by default in the user interface.
					Default *string `json:"default,omitempty"`

					// The system name for the credential parameter. Use this value as the parameter name in request messages configuring credentials.
					Id *string `json:"id,omitempty"`

					// The display name for the credential configuration in the user interface.
					Name *string `json:"name,omitempty"`

					// The supported options for the credential parameter.
					Options *[]struct {
						// The system name for the option.
						Id *string `json:"id,omitempty"`

						// The additional inputs that are required if the user selects this option in the user interface. If the inputs parameter is empty (`\[\]`), selecting the option does not require additional user input.
						Inputs *[]struct {
							// Not supported as a parameter in managed credentials.
							Callback *string `json:"callback,omitempty"`

							// The number of text box rows that appear by default when the input type is `key-value`.
							DefaultRowCount *int `json:"default-row-count,omitempty"`

							// A value specifying whether the user interface hides the value by default when the input type is `key-value`. If `true`, dots appear instead of characters as you type the value in the user interface.
							HideValues *bool `json:"hide-values,omitempty"`

							// Helpful information about the input required, for example, "PEM formatted certificate". Hints appear in the user interface, but can contain information that is relevant to API requests.
							Hint *string `json:"hint,omitempty"`

							// The system name for the input. Use this value as the input name in request messages when configuring credentials.
							Id *string `json:"id,omitempty"`

							// The display name of the option in the user interface.
							Name *string `json:"name,omitempty"`

							// An example of the input value. This value appears as example text in the user interface.
							//
							// This attribute is only present for credential parameters that require text input in the interface.
							//
							// In cases where the input type is `key-value`, this attribute can be an array of strings.
							Placeholder *string `json:"placeholder,omitempty"`

							// A regular expression defining the valid input for the parameter in the user interface.
							Regex *string `json:"regex,omitempty"`

							// A value specifying whether the input is required (`true`) or optional (`false`).
							Required *bool `json:"required,omitempty"`

							// The type of input prompt in the user interface. Possible values include:
							//  - passwordPrompts for input via text box.
							//  - textPrompts for input via text box.
							//  - selectPrompts for input via selectable options.
							//  - filePrompts user to upload file of input data.
							//  - togglePrompts user to select one of two mutually-exclusive options in toggle format.
							//  - checkboxPrompts user to select options via checkboxes. Checkboxes can represent enabling a single option or can allow users to select from multiple, mutually-exclusive options.
							//  - key-value Prompts for text entry of a key-value pair via two text boxes.
							Type *string `json:"type,omitempty"`
						} `json:"inputs,omitempty"`

						// The display name of the option in the user interface.
						Name *string `json:"name,omitempty"`
					} `json:"options,omitempty"`

					// An example of the parameter value. This value appears as example text in the user interface.
					//
					// This attribute is only present for credential parameters that require text input in the user interface.
					Placeholder *string `json:"placeholder,omitempty"`

					// Not supported as a parameter in managed credentials.
					Preferences *[]string `json:"preferences,omitempty"`

					// A value specifying whether the configuration parameter is required (`true`) or optional (`false`). If this attribute is absent, the parameter is optional.
					Required *bool `json:"required,omitempty"`

					// The parameter input type. This attribute reflects how the user interface prompts for parameter input. Possible values include:
					//  - passwordPrompts for input via text box.
					//  - textPrompts for input via text box.
					//  - selectPrompts for input via selectable options.
					//  - filePrompts user to upload file of input data.
					//  - togglePrompts user to toggle an option on or off.
					//  - checkboxPrompts user to select options via checkboxes. Checkboxes can represent enabling a single option or can allow users to select from multiple, mutually-exclusive options.
					Type *string `json:"type,omitempty"`
				} `json:"configuration,omitempty"`

				// A value specifying whether the configuration settings appear expanded by default in the user interface.
				ExpandSettings *bool `json:"expand_settings,omitempty"`

				// The system name that uniquely identifies the credential type.
				Id *string `json:"id,omitempty"`

				// The maximum number of instances of this credential type that Tenable.io supports for an individual scan or policy.
				Max *int `json:"max,omitempty"`

				// The display name for the credential type in the user interface.
				Name *string `json:"name,omitempty"`
			} `json:"types,omitempty"`
		} `json:"credentials,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CredentialsListCredentialTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CredentialsListCredentialTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CredentialsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Deleted *bool `json:"deleted,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CredentialsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CredentialsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CredentialsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A value specifying how a user creates a managed credential in the user interface. If `true`, the user created the credential during the scan configuration. If `false`, the user created the credential independently from scan configuration.
		AdHoc    *bool `json:"ad_hoc,omitempty"`
		Category *struct {
			// The system name that uniquely identifies the credential category.
			Id *string `json:"id,omitempty"`

			// The display name for the credential category in the user interface.
			Name *string `json:"name,omitempty"`
		} `json:"category,omitempty"`

		// The definition of the managed credential object. You specify the description when you create or update the managed credential.
		Description *string `json:"description,omitempty"`

		// The name of the managed credential object. You specify the name when you create or update the managed credential.
		Name        *string `json:"name,omitempty"`
		Permissions *[]struct {
			// The UUID of the user or user group granted permissions for the managed credential.
			//
			// This parameter is required when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
			GranteeUuid *string `json:"grantee_uuid,omitempty"`

			// The name of the user or user group that you want to grant permissions for the managed credential.
			//
			// This parameter is optional when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
			Name *string `json:"name,omitempty"`

			// A value specifying the permissions granted to the user or user group for the credential. Possible values are:
			//  - 32The user can view credential information and use the credential in scans. Corresponds to the **Can Use** permission in the user interface.
			//  - 64The user can view and edit credential settings, delete the credential, and use the credential in scans. Corresponds to the **Can Edit** permission in the user interface.
			//
			// This parameter is required when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
			Permissions *int `json:"permissions,omitempty"`

			// A value specifying whether the grantee is a user (`user`) or a user group (`group`).
			//
			// This parameter is required when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
			Type *N200PermissionsType `json:"type,omitempty"`
		} `json:"permissions,omitempty"`

		// The configuration settings for the credential. The parameters of this object vary depending on the credential type. For more information, see [Determine Settings for a Credential Type](doc:determine-settings-for-credential-type).
		Settings *map[string]interface{} `json:"settings,omitempty"`
		Type     *struct {
			// The system name that uniquely identifies the credential type.
			Id *string `json:"id,omitempty"`

			// The display name for the credential type in the user interface.
			Name *string `json:"name,omitempty"`
		} `json:"type,omitempty"`

		// The permissions for the managed credential that are assigned to the user account submitting the API request. For possible values, see "Credential Roles" in [Permissions](doc:permissions).
		UserPermissions *int `json:"user_permissions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CredentialsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CredentialsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CredentialsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Updated *bool `json:"updated,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CredentialsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CredentialsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditorPluginDescriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The detailed information for a Tenable.io plugin.
		Plugindescription *struct {
			// The attributes of the plugin, including synopsis, description, solution, and risk information.
			Pluginattributes *map[string]interface{} `json:"pluginattributes,omitempty"`

			// The name of the plugin family.
			Pluginfamily *string `json:"pluginfamily,omitempty"`

			// The ID of the plugin.
			Pluginid *int `json:"pluginid,omitempty"`

			// The name of the plugin.
			Pluginname *string `json:"pluginname,omitempty"`

			// The severity level of the vulnerabilities targeted by the plugin
			Severity *string `json:"severity,omitempty"`
		} `json:"plugindescription,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EditorPluginDescriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditorPluginDescriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditorListTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Templates []struct {
			// If `true`, the template is only available on the cloud.
			CloudOnly *bool `json:"cloud_only,omitempty"`

			// The description of the template.
			Desc *string `json:"desc,omitempty"`

			// If `true`, the template can only be used for agent scans.
			IsAgent *bool `json:"is_agent,omitempty"`

			// If `true`, the template can be used for Web Application Scanning only.
			IsWas *bool `json:"is_was,omitempty"`

			// If `true`, can only be used by manager.
			ManagerOnly *bool `json:"manager_only,omitempty"`

			// The short name of the template.
			Name *string `json:"name,omitempty"`

			// If `true`, the template is only available for subscribers.
			SubscriptionOnly *bool `json:"subscription_only,omitempty"`

			// The long name of the template.
			Title *string `json:"title,omitempty"`

			// If `true`, the template is not supported.
			Unsupported *bool `json:"unsupported,omitempty"`

			// The UUID for the template. Use this value to specify the template when creating scans and policies.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"templates,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EditorListTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditorListTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditorTemplateDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Plugins options enables you to select security checks by Plugin Family or individual plugins checks.
		Compliance *map[string]interface{} `json:"compliance,omitempty"`

		// Credentials that grant the scanner access to the target system without requiring an agent. Credentialed scans can perform a wider variety of checks than non-credentialed scans, which can result in more accurate scan results. This facilitates scanning of a very large network to determine local exposures or compliance violations. You can configure credentials for Cloud Services, Database, Host, Miscellaneous, Mobile Device Management, and Plaintext Authentication.
		Credentials      *map[string]interface{} `json:"credentials,omitempty"`
		FilterAttributes *[]struct {
			Control *struct {
				// A list of options if the input is a dropdown.
				Options *[]map[string]interface{} `json:"options,omitempty"`

				// The placeholder for the input.
				ReadableRegest *string `json:"readable_regest,omitempty"`

				// A regex for checking the value of the input.
				Regex *string `json:"regex,omitempty"`

				// The input type (entry or dropdown).
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// The short name of the filter.
			Name *string `json:"name,omitempty"`

			// The comparison options for the filter.
			Operators *[]map[string]interface{} `json:"operators,omitempty"`

			// The long name of the filter.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filter_attributes,omitempty"`

		// If `true`, the template is for agent scans.
		IsAgent *bool `json:"is_agent,omitempty"`

		// If `true`, the template can be used for Web Application Scanning only. For Vulnerability Management templates, this value is always `null`.
		IsWas *bool `json:"is_was,omitempty"`

		// The short name of the template.
		Name *string `json:"name,omitempty"`

		// The settings for compliance audit checks.
		Plugins *map[string]interface{} `json:"plugins,omitempty"`

		// Scan or policy settings organized into the Basic, Discovery, Assessment, Report, and Advanced configuration categories.
		Settings *struct {
			// The Advanced settings provide increased control over scan efficiency and the operations of a scan, as well as the ability to enabled plugin debugging.
			Advanced *map[string]interface{} `json:"advanced,omitempty"`

			// You can use Assessment settings to configure how a scan identifies vulnerabilities, as well as what vulnerabilities are identified. This includes identifying malware, assessing the vulnerability of a system to brute force attacks, and the susceptibility of web applications.
			Assessment *map[string]interface{} `json:"assessment,omitempty"`

			// The Basic scan settings are used to specify certain organizational and security-related aspects of the scan or policy, including the name of the scan, its targets, whether the scan is scheduled, and who has access to the scan, among other settings.
			Basic *map[string]interface{} `json:"basic,omitempty"`

			// The Discovery settings relate to discovery and port scanning, including port ranges and methods.
			Discovery *map[string]interface{} `json:"discovery,omitempty"`
		} `json:"settings,omitempty"`

		// The long name of the template.
		Title *string `json:"title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EditorTemplateDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditorTemplateDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditorDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Plugins options enables you to select security checks by Plugin Family or individual plugins checks.
		Compliance *map[string]interface{} `json:"compliance,omitempty"`

		// Credentials that grant the scanner access to the target system without requiring an agent. Credentialed scans can perform a wider variety of checks than non-credentialed scans, which can result in more accurate scan results. This facilitates scanning of a very large network to determine local exposures or compliance violations. You can configure credentials for Cloud Services, Database, Host, Miscellaneous, Mobile Device Management, and Plaintext Authentication.
		Credentials      *map[string]interface{} `json:"credentials,omitempty"`
		FilterAttributes *[]struct {
			Control *struct {
				// A list of options if the input is a dropdown.
				Options *[]map[string]interface{} `json:"options,omitempty"`

				// The placeholder for the input.
				ReadableRegest *string `json:"readable_regest,omitempty"`

				// A regex for checking the value of the input.
				Regex *string `json:"regex,omitempty"`

				// The input type (entry or dropdown).
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// The short name of the filter.
			Name *string `json:"name,omitempty"`

			// The comparison options for the filter.
			Operators *[]map[string]interface{} `json:"operators,omitempty"`

			// The long name of the filter.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filter_attributes,omitempty"`

		// Indicates whether the scan or user-defined template (policy) can be used for agent scans.
		IsAgent *bool `json:"is_agent,omitempty"`

		// Indicates whether the scan or user-defined template (policy) can be used in Tenable.io Web Application Scanning.
		IsWas *bool `json:"is_was,omitempty"`

		// For scans, the standard text, `custom`. For user-defined templates (policies), the system name for the Tenable-provided template used to create the scan or user-defined template.
		Name *string `json:"name,omitempty"`

		// The username of the owner of the scan or user-defined template (policy).
		Owner *string `json:"owner,omitempty"`

		// The settings for compliance audit checks.
		Plugins *map[string]interface{} `json:"plugins,omitempty"`

		// Scan or policy settings organized into the Basic, Discovery, Assessment, Report, and Advanced configuration categories.
		Settings *struct {
			// The Advanced settings provide increased control over scan efficiency and the operations of a scan, as well as the ability to enabled plugin debugging.
			Advanced *map[string]interface{} `json:"advanced,omitempty"`

			// You can use Assessment settings to configure how a scan identifies vulnerabilities, as well as what vulnerabilities are identified. This includes identifying malware, assessing the vulnerability of a system to brute force attacks, and the susceptibility of web applications.
			Assessment *map[string]interface{} `json:"assessment,omitempty"`

			// The Basic scan settings are used to specify certain organizational and security-related aspects of the scan or policy, including the name of the scan, its targets, whether the scan is scheduled, and who has access to the scan, among other settings.
			Basic *map[string]interface{} `json:"basic,omitempty"`

			// The Discovery settings relate to discovery and port scanning, including port ranges and methods.
			Discovery *map[string]interface{} `json:"discovery,omitempty"`
		} `json:"settings,omitempty"`

		// For scans, the standard text, `Custom Scan`. For user-defined templates (policies), the name of the Tenable-provided template used to create the user-defined template.
		Title *string `json:"title,omitempty"`

		// The scan or policy permissions that the requesting user has for the specified scan or user-defined template (policy). For more information, see [Permissions](doc:permissions).
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the scan or user-defined template (policy).
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EditorDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditorDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditorAuditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EditorAuditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditorAuditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExclusionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// The creation date of the exclusion in Unix time.
		CreationDate *int `json:"creation_date,omitempty"`

		// The description of the exclusion.
		Description *string `json:"description,omitempty"`

		// The unique ID of the exclusion.
		Id *int `json:"id,omitempty"`

		// The last modification date for the exclusion in Unix time.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The targets that you want excluded from scans. Specify multiple targets as a comma-separated string. Targets can be in the following formats:
		//  - an individual IPv4 address (192.0.2.1)
		//  - a range of IPv4 addresses (192.0.2.1-192.0.2.255)
		//  - CIDR notation (192.0.2.0/24)
		//  - a fully-qualified domain name (FQDN) (host.domain.com)
		Members *string `json:"members,omitempty"`

		// The name of the exclusion.
		Name *string `json:"name,omitempty"`

		// The ID of the network object associated with scanners where Tenable.io applies the exclusion. The default network ID is `00000000-0000-0000-0000-000000000000`. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkId *string `json:"network_id,omitempty"`

		// The schedule parameters for the exclusion.
		Schedule *struct {
			// If `true`, the exclusion schedule is active.
			Enabled *bool `json:"enabled,omitempty"`

			// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
			Endtime *string `json:"endtime,omitempty"`

			// The recurrence rules for the exclusion.
			Rrules *struct {
				// The day of the month to repeat a MONTHLY freq rule on.
				Bymonthday *int `json:"bymonthday,omitempty"`

				// A comma-separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
				Byweekday *string `json:"byweekday,omitempty"`

				// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
				Freq *string `json:"freq,omitempty"`

				// The interval of the rule.
				Interval *int `json:"interval,omitempty"`
			} `json:"rrules,omitempty"`

			// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
			Starttime *string `json:"starttime,omitempty"`

			// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
			Timezone *string `json:"timezone,omitempty"`
		} `json:"schedule,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExclusionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExclusionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExclusionsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The creation date of the exclusion in Unix time.
		CreationDate *int `json:"creation_date,omitempty"`

		// The description of the exclusion.
		Description *string `json:"description,omitempty"`

		// The unique ID of the exclusion.
		Id *int `json:"id,omitempty"`

		// The last modification date for the exclusion in Unix time.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The targets that you want excluded from scans. Specify multiple targets as a comma-separated string. Targets can be in the following formats:
		//  - an individual IPv4 address (192.0.2.1)
		//  - a range of IPv4 addresses (192.0.2.1-192.0.2.255)
		//  - CIDR notation (192.0.2.0/24)
		//  - a fully-qualified domain name (FQDN) (host.domain.com)
		Members *string `json:"members,omitempty"`

		// The name of the exclusion.
		Name *string `json:"name,omitempty"`

		// The ID of the network object associated with scanners where Tenable.io applies the exclusion. The default network ID is `00000000-0000-0000-0000-000000000000`. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkId *string `json:"network_id,omitempty"`

		// The schedule parameters for the exclusion.
		Schedule *struct {
			// If `true`, the exclusion schedule is active.
			Enabled *bool `json:"enabled,omitempty"`

			// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
			Endtime *string `json:"endtime,omitempty"`

			// The recurrence rules for the exclusion.
			Rrules *struct {
				// The day of the month to repeat a MONTHLY freq rule on.
				Bymonthday *int `json:"bymonthday,omitempty"`

				// A comma-separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
				Byweekday *string `json:"byweekday,omitempty"`

				// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
				Freq *string `json:"freq,omitempty"`

				// The interval of the rule.
				Interval *int `json:"interval,omitempty"`
			} `json:"rrules,omitempty"`

			// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
			Starttime *string `json:"starttime,omitempty"`

			// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
			Timezone *string `json:"timezone,omitempty"`
		} `json:"schedule,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExclusionsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExclusionsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExclusionsImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ExclusionsImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExclusionsImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExclusionsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ExclusionsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExclusionsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExclusionsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The creation date of the exclusion in Unix time.
		CreationDate *int `json:"creation_date,omitempty"`

		// The description of the exclusion.
		Description *string `json:"description,omitempty"`

		// The unique ID of the exclusion.
		Id *int `json:"id,omitempty"`

		// The last modification date for the exclusion in Unix time.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The targets that you want excluded from scans. Specify multiple targets as a comma-separated string. Targets can be in the following formats:
		//  - an individual IPv4 address (192.0.2.1)
		//  - a range of IPv4 addresses (192.0.2.1-192.0.2.255)
		//  - CIDR notation (192.0.2.0/24)
		//  - a fully-qualified domain name (FQDN) (host.domain.com)
		Members *string `json:"members,omitempty"`

		// The name of the exclusion.
		Name *string `json:"name,omitempty"`

		// The ID of the network object associated with scanners where Tenable.io applies the exclusion. The default network ID is `00000000-0000-0000-0000-000000000000`. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkId *string `json:"network_id,omitempty"`

		// The schedule parameters for the exclusion.
		Schedule *struct {
			// If `true`, the exclusion schedule is active.
			Enabled *bool `json:"enabled,omitempty"`

			// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
			Endtime *string `json:"endtime,omitempty"`

			// The recurrence rules for the exclusion.
			Rrules *struct {
				// The day of the month to repeat a MONTHLY freq rule on.
				Bymonthday *int `json:"bymonthday,omitempty"`

				// A comma-separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
				Byweekday *string `json:"byweekday,omitempty"`

				// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
				Freq *string `json:"freq,omitempty"`

				// The interval of the rule.
				Interval *int `json:"interval,omitempty"`
			} `json:"rrules,omitempty"`

			// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
			Starttime *string `json:"starttime,omitempty"`

			// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
			Timezone *string `json:"timezone,omitempty"`
		} `json:"schedule,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExclusionsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExclusionsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExclusionsEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ExclusionsEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExclusionsEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The name of the uploaded file. If the file with the same name already exists, Tenable.io appends an underscore with a number. For example, `scan-targets_1.txt`. Use this attribute value when referencing the file for subsequent requests.
		Fileuploaded *string `json:"fileuploaded,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FileUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoFiltersCredentialsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A list of filters available for the record type.
		Filters *[]struct {
			Control *struct {
				// Provides a human-readable "hint" which describes what the filter string should look like.
				ReadableRegex *string `json:"readable_regex,omitempty"`

				// A regex which can be used by a user interface to validate input.
				Regex *string `json:"regex,omitempty"`

				// The type of UI control which represents the filter.
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
			GroupName *string `json:"group_name,omitempty"`

			// The field name to be used in request query strings when applying the filter.
			Name *string `json:"name,omitempty"`

			// Strings which represent the comparison operations which can be used for the filter.
			Operators *[]string `json:"operators,omitempty"`

			// The filter's display label.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filters,omitempty"`

		// The sorting parameters supported for data returned by the endpoint.
		Sort *struct {
			// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
			MaxSortFields *int `json:"max_sort_fields,omitempty"`

			// Fields by which the returned list of records may be sorted.
			SortableFields *[]string `json:"sortable_fields,omitempty"`
		} `json:"sort,omitempty"`

		// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
		WildcardFields *[]string `json:"wildcard_fields,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoFiltersCredentialsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoFiltersCredentialsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoFiltersAgentsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A list of filters available for the record type.
		Filters *[]struct {
			Control *struct {
				// Provides a human-readable "hint" which describes what the filter string should look like.
				ReadableRegex *string `json:"readable_regex,omitempty"`

				// A regex which can be used by a user interface to validate input.
				Regex *string `json:"regex,omitempty"`

				// The type of UI control which represents the filter.
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
			GroupName *string `json:"group_name,omitempty"`

			// The field name to be used in request query strings when applying the filter.
			Name *string `json:"name,omitempty"`

			// Strings which represent the comparison operations which can be used for the filter.
			Operators *[]string `json:"operators,omitempty"`

			// The filter's display label.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filters,omitempty"`

		// The sorting parameters supported for data returned by the endpoint.
		Sort *struct {
			// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
			MaxSortFields *int `json:"max_sort_fields,omitempty"`

			// Fields by which the returned list of records may be sorted.
			SortableFields *[]string `json:"sortable_fields,omitempty"`
		} `json:"sort,omitempty"`

		// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
		WildcardFields *[]string `json:"wildcard_fields,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoFiltersAgentsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoFiltersAgentsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoFiltersScanListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A list of filters available for the record type.
		Filters *[]struct {
			Control *struct {
				// Provides a human-readable "hint" which describes what the filter string should look like.
				ReadableRegex *string `json:"readable_regex,omitempty"`

				// A regex which can be used by a user interface to validate input.
				Regex *string `json:"regex,omitempty"`

				// The type of UI control which represents the filter.
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
			GroupName *string `json:"group_name,omitempty"`

			// The field name to be used in request query strings when applying the filter.
			Name *string `json:"name,omitempty"`

			// Strings which represent the comparison operations which can be used for the filter.
			Operators *[]string `json:"operators,omitempty"`

			// The filter's display label.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filters,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoFiltersScanListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoFiltersScanListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoFiltersScanHistoryListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A list of filters available for the record type.
		Filters *[]struct {
			Control *struct {
				// Provides a human-readable "hint" which describes what the filter string should look like.
				ReadableRegex *string `json:"readable_regex,omitempty"`

				// A regex which can be used by a user interface to validate input.
				Regex *string `json:"regex,omitempty"`

				// The type of UI control which represents the filter.
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
			GroupName *string `json:"group_name,omitempty"`

			// The field name to be used in request query strings when applying the filter.
			Name *string `json:"name,omitempty"`

			// Strings which represent the comparison operations which can be used for the filter.
			Operators *[]string `json:"operators,omitempty"`

			// The filter's display label.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filters,omitempty"`

		// The sorting parameters supported for data returned by the endpoint.
		Sort *struct {
			// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
			MaxSortFields *int `json:"max_sort_fields,omitempty"`

			// Fields by which the returned list of records may be sorted.
			SortableFields *[]string `json:"sortable_fields,omitempty"`
		} `json:"sort,omitempty"`

		// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
		WildcardFields *[]string `json:"wildcard_fields,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoFiltersScanHistoryListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoFiltersScanHistoryListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoFiltersAssetsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A list of filters available for the record type.
		Filters *[]struct {
			Control *struct {
				// Provides a human-readable "hint" which describes what the filter string should look like.
				ReadableRegex *string `json:"readable_regex,omitempty"`

				// A regex which can be used by a user interface to validate input.
				Regex *string `json:"regex,omitempty"`

				// The type of UI control which represents the filter.
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
			GroupName *string `json:"group_name,omitempty"`

			// The field name to be used in request query strings when applying the filter.
			Name *string `json:"name,omitempty"`

			// Strings which represent the comparison operations which can be used for the filter.
			Operators *[]string `json:"operators,omitempty"`

			// The filter's display label.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filters,omitempty"`

		// The sorting parameters supported for data returned by the endpoint.
		Sort *struct {
			// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
			MaxSortFields *int `json:"max_sort_fields,omitempty"`

			// Fields by which the returned list of records may be sorted.
			SortableFields *[]string `json:"sortable_fields,omitempty"`
		} `json:"sort,omitempty"`

		// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
		WildcardFields *[]string `json:"wildcard_fields,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoFiltersAssetsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoFiltersAssetsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoFiltersAssetsListV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A list of filters available for the record type.
		Filters *[]struct {
			Control *struct {
				// Provides a human-readable "hint" which describes what the filter string should look like.
				ReadableRegex *string `json:"readable_regex,omitempty"`

				// A regex which can be used by a user interface to validate input.
				Regex *string `json:"regex,omitempty"`

				// The type of UI control which represents the filter.
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
			GroupName *string `json:"group_name,omitempty"`

			// The field name to be used in request query strings when applying the filter.
			Name *string `json:"name,omitempty"`

			// Strings which represent the comparison operations which can be used for the filter.
			Operators *[]string `json:"operators,omitempty"`

			// The filter's display label.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filters,omitempty"`

		// The sorting parameters supported for data returned by the endpoint.
		Sort *struct {
			// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
			MaxSortFields *int `json:"max_sort_fields,omitempty"`

			// Fields by which the returned list of records may be sorted.
			SortableFields *[]string `json:"sortable_fields,omitempty"`
		} `json:"sort,omitempty"`

		// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
		WildcardFields *[]string `json:"wildcard_fields,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoFiltersAssetsListV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoFiltersAssetsListV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoFiltersVulnerabilitiesWorkbenchListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A list of filters available for the record type.
		Filters *[]struct {
			Control *struct {
				// Provides a human-readable "hint" which describes what the filter string should look like.
				ReadableRegex *string `json:"readable_regex,omitempty"`

				// A regex which can be used by a user interface to validate input.
				Regex *string `json:"regex,omitempty"`

				// The type of UI control which represents the filter.
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
			GroupName *string `json:"group_name,omitempty"`

			// The field name to be used in request query strings when applying the filter.
			Name *string `json:"name,omitempty"`

			// Strings which represent the comparison operations which can be used for the filter.
			Operators *[]string `json:"operators,omitempty"`

			// The filter's display label.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filters,omitempty"`

		// The sorting parameters supported for data returned by the endpoint.
		Sort *struct {
			// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
			MaxSortFields *int `json:"max_sort_fields,omitempty"`

			// Fields by which the returned list of records may be sorted.
			SortableFields *[]string `json:"sortable_fields,omitempty"`
		} `json:"sort,omitempty"`

		// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
		WildcardFields *[]string `json:"wildcard_fields,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoFiltersVulnerabilitiesWorkbenchListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoFiltersVulnerabilitiesWorkbenchListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoFiltersVulnerabilitiesWorkbenchListV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A list of filters available for the record type.
		Filters *[]struct {
			Control *struct {
				// Provides a human-readable "hint" which describes what the filter string should look like.
				ReadableRegex *string `json:"readable_regex,omitempty"`

				// A regex which can be used by a user interface to validate input.
				Regex *string `json:"regex,omitempty"`

				// The type of UI control which represents the filter.
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
			GroupName *string `json:"group_name,omitempty"`

			// The field name to be used in request query strings when applying the filter.
			Name *string `json:"name,omitempty"`

			// Strings which represent the comparison operations which can be used for the filter.
			Operators *[]string `json:"operators,omitempty"`

			// The filter's display label.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filters,omitempty"`

		// The sorting parameters supported for data returned by the endpoint.
		Sort *struct {
			// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
			MaxSortFields *int `json:"max_sort_fields,omitempty"`

			// Fields by which the returned list of records may be sorted.
			SortableFields *[]string `json:"sortable_fields,omitempty"`
		} `json:"sort,omitempty"`

		// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
		WildcardFields *[]string `json:"wildcard_fields,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoFiltersVulnerabilitiesWorkbenchListV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoFiltersVulnerabilitiesWorkbenchListV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FoldersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Folders []struct {
			// Indicates whether or not the folder is a custom folder:
			//  - 1User-created folder. You can rename or delete this folder.
			//  - 0System-created folder. You cannot rename or delete this folder.
			Custom *int `json:"custom,omitempty"`

			// Indicates whether or not the folder is the default:
			//  - 1The folder is the default.
			//  - 0The folder is not the default.
			//
			// The main folder is the default folder. You cannot change the default folder.
			DefaultTag *int `json:"default_tag,omitempty"`

			// The unique ID of the folder.
			Id *int `json:"id,omitempty"`

			// The name of the folder. This value corresponds to the folder type as follows:
			//  - mainMy Scans
			//  - trashTrash
			// -customuser-defined string.
			Name *string `json:"name,omitempty"`

			// The type of the folder:
			// - mainTenable-provided folder. Contains all scans that you create but do not assign to a custom folder, as well as any scans shared with you by other users. If you do not specify a scan folder when creating a scan, Tenable.io stores scans in this folder by default. This folder corresponds to the **My Scans** folder in the Tenable.io user interface.
			//  - trashTenable-provided folder. Contains all scans that the current user has moved to the trash folder. Scans stored in the trash folder are automatically deleted after 30 days. This folder corresponds to the **Trash** folder in the Tenable.io user interface.
			//  - customUser-created folder. Contains scans as assigned by the current user. You can create custom folders to meet your organizational needs.
			Type *string `json:"type,omitempty"`

			// The number of scans in the folder that the current user has not yet viewed in the Tenable.io user interface.
			UnreadCount *int `json:"unread_count,omitempty"`
		} `json:"folders,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FoldersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FoldersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FoldersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The ID of the created folder.
		Id *int `json:"id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r FoldersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FoldersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FoldersDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r FoldersDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FoldersDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FoldersEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r FoldersEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FoldersEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetsListImportJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// The number of batches in the asset import job.
		Batches *int32 `json:"batches,omitempty"`

		// The UUID of your Tenable.io container.
		ContainerId *string `json:"container_id,omitempty"`

		// The Unix timestamp when Tenable.io completed processing the import job.
		EndTime *int32 `json:"end_time,omitempty"`

		// The number of assets from the import job that Tenable.io failed to import.
		FailedAssets *int `json:"failed_assets,omitempty"`

		// The UUID of the asset import job.
		JobId *string `json:"job_id,omitempty"`

		// The Unix timestamp when Tenable.io performed an action on the import job.
		LastUpdateTime *int32 `json:"last_update_time,omitempty"`

		// A user-defined name for the source of the import containing the asset records. You can specify only one source for each import.
		Source *string `json:"source,omitempty"`

		// The Unix timestamp when Tenable.io started processing the import job.
		StartTime *int32 `json:"start_time,omitempty"`

		// The status of the import job. Possible values include: COMPLETE, IN_PROGRESS, or ERROR.
		Status *string `json:"status,omitempty"`

		// The description of why a job failed.
		StatusMessage *string `json:"status_message,omitempty"`

		// The number of assets from the import job that Tenable.io successfully imported.
		UploadedAssets *int32 `json:"uploaded_assets,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetsListImportJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetsListImportJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetsImportJobInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The number of batches in the asset import job.
		Batches *int32 `json:"batches,omitempty"`

		// The UUID of your Tenable.io container.
		ContainerId *string `json:"container_id,omitempty"`

		// The Unix timestamp when Tenable.io completed processing the import job.
		EndTime *int32 `json:"end_time,omitempty"`

		// The number of assets from the import job that Tenable.io failed to import.
		FailedAssets *int `json:"failed_assets,omitempty"`

		// The UUID of the asset import job.
		JobId *string `json:"job_id,omitempty"`

		// The Unix timestamp when Tenable.io performed an action on the import job.
		LastUpdateTime *int32 `json:"last_update_time,omitempty"`

		// A user-defined name for the source of the import containing the asset records. You can specify only one source for each import.
		Source *string `json:"source,omitempty"`

		// The Unix timestamp when Tenable.io started processing the import job.
		StartTime *int32 `json:"start_time,omitempty"`

		// The status of the import job. Possible values include: COMPLETE, IN_PROGRESS, or ERROR.
		Status *string `json:"status,omitempty"`

		// The description of why a job failed.
		StatusMessage *string `json:"status_message,omitempty"`

		// The number of assets from the import job that Tenable.io successfully imported.
		UploadedAssets *int32 `json:"uploaded_assets,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetsImportJobInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetsImportJobInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssetsImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The asset import job UUID.
		AssetImportJobUuid *string `json:"asset_import_job_uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssetsImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssetsImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VulnerabilitiesImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r VulnerabilitiesImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VulnerabilitiesImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworksListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Networks *[]struct {
			// The number of days before assets age out. Assets are permanently deleted if they are not seen on a scan within the specified number of days.<ul><li>Minimum value: 90</li><li>Maximum value: 365</li></ul> Note: If you enable this option, Tenable.io immediately deletes assets in the specified network that have not been seen for the specified number of days. All asset records and associated vulnerabilities are deleted and cannot be recovered. The deleted assets no longer count towards [your license](https://docs.tenable.com/earlyaccess/tenableio/vulnerabilitymanagement/Content/GettingStarted/Licenses.htm)
			AssetsTtlDays *int `json:"assets_ttl_days,omitempty"`

			// The date (in Unix milliseconds) when the network object was created.
			Created *int `json:"created,omitempty"`

			// The UUID of the user who created the network object.
			CreatedBy *string `json:"created_by,omitempty"`

			// The date (in Unix seconds) when the network object was created.
			CreatedInSeconds *int `json:"created_in_seconds,omitempty"`

			// The date (in Unix time) when the network object was deleted. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
			Deleted *int `json:"deleted,omitempty"`

			// The UUID of the user who deleted the network object. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
			DeletedBy *string `json:"deleted_by,omitempty"`

			// The description of the network object.
			Description *string `json:"description,omitempty"`

			// Indicates whether the network object is the default network object. The default network object is a system-generated object that contains any scanners and scanner groups not yet assigned to a custom network object. You cannot update or delete the default network object.
			IsDefault *bool `json:"is_default,omitempty"`

			// The date (in Unix milliseconds) when the network object was last updated.
			Modified *int `json:"modified,omitempty"`

			// The UUID of the user who last updated the network object.
			ModifiedBy *string `json:"modified_by,omitempty"`

			// The date (in Unix seconds) when the network object was last updated.
			ModifiedInSeconds *int `json:"modified_in_seconds,omitempty"`

			// The name of the network object.
			Name *string `json:"name,omitempty"`

			// The UUID of the owner of the network object. The owner of the network object does not have any additional permissions above administrator permissions.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The UUID of the network object.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"networks,omitempty"`
		Pagination *[]struct {
			// The number of records requested (or the default value if omitted from the request).
			Limit *int32 `json:"limit,omitempty"`

			// The starting record you requested (or zero if omitted).
			Offset *int32 `json:"offset,omitempty"`

			// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
			Sort *[]struct {
				// The field on which Tenable.io sorted the results.
				Name *string `json:"name,omitempty"`

				// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
				Order *string `json:"order,omitempty"`
			} `json:"sort,omitempty"`

			// The total number of records matching your search criteria.
			Total *int32 `json:"total,omitempty"`
		} `json:"pagination,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NetworksListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworksListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The number of days before assets age out. Assets are permanently deleted if they are not seen on a scan within the specified number of days.<ul><li>Minimum value: 90</li><li>Maximum value: 365</li></ul> Note: If you enable this option, Tenable.io immediately deletes assets in the specified network that have not been seen for the specified number of days. All asset records and associated vulnerabilities are deleted and cannot be recovered. The deleted assets no longer count towards [your license](https://docs.tenable.com/earlyaccess/tenableio/vulnerabilitymanagement/Content/GettingStarted/Licenses.htm)
		AssetsTtlDays *int `json:"assets_ttl_days,omitempty"`

		// The date (in Unix milliseconds) when the network object was created.
		Created *int `json:"created,omitempty"`

		// The UUID of the user who created the network object.
		CreatedBy *string `json:"created_by,omitempty"`

		// The date (in Unix seconds) when the network object was created.
		CreatedInSeconds *int `json:"created_in_seconds,omitempty"`

		// The date (in Unix time) when the network object was deleted. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
		Deleted *int `json:"deleted,omitempty"`

		// The UUID of the user who deleted the network object. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
		DeletedBy *string `json:"deleted_by,omitempty"`

		// The description of the network object.
		Description *string `json:"description,omitempty"`

		// Indicates whether the network object is the default network object. The default network object is a system-generated object that contains any scanners and scanner groups not yet assigned to a custom network object. You cannot update or delete the default network object.
		IsDefault *bool `json:"is_default,omitempty"`

		// The date (in Unix milliseconds) when the network object was last updated.
		Modified *int `json:"modified,omitempty"`

		// The UUID of the user who last updated the network object.
		ModifiedBy *string `json:"modified_by,omitempty"`

		// The date (in Unix seconds) when the network object was last updated.
		ModifiedInSeconds *int `json:"modified_in_seconds,omitempty"`

		// The name of the network object.
		Name *string `json:"name,omitempty"`

		// The UUID of the owner of the network object. The owner of the network object does not have any additional permissions above administrator permissions.
		OwnerUuid *string `json:"owner_uuid,omitempty"`

		// The UUID of the network object.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NetworksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworksDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r NetworksDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworksDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworksDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The number of days before assets age out. Assets are permanently deleted if they are not seen on a scan within the specified number of days.<ul><li>Minimum value: 90</li><li>Maximum value: 365</li></ul> Note: If you enable this option, Tenable.io immediately deletes assets in the specified network that have not been seen for the specified number of days. All asset records and associated vulnerabilities are deleted and cannot be recovered. The deleted assets no longer count towards [your license](https://docs.tenable.com/earlyaccess/tenableio/vulnerabilitymanagement/Content/GettingStarted/Licenses.htm)
		AssetsTtlDays *int `json:"assets_ttl_days,omitempty"`

		// The date (in Unix milliseconds) when the network object was created.
		Created *int `json:"created,omitempty"`

		// The UUID of the user who created the network object.
		CreatedBy *string `json:"created_by,omitempty"`

		// The date (in Unix seconds) when the network object was created.
		CreatedInSeconds *int `json:"created_in_seconds,omitempty"`

		// The date (in Unix time) when the network object was deleted. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
		Deleted *int `json:"deleted,omitempty"`

		// The UUID of the user who deleted the network object. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
		DeletedBy *string `json:"deleted_by,omitempty"`

		// The description of the network object.
		Description *string `json:"description,omitempty"`

		// Indicates whether the network object is the default network object. The default network object is a system-generated object that contains any scanners and scanner groups not yet assigned to a custom network object. You cannot update or delete the default network object.
		IsDefault *bool `json:"is_default,omitempty"`

		// The date (in Unix milliseconds) when the network object was last updated.
		Modified *int `json:"modified,omitempty"`

		// The UUID of the user who last updated the network object.
		ModifiedBy *string `json:"modified_by,omitempty"`

		// The date (in Unix seconds) when the network object was last updated.
		ModifiedInSeconds *int `json:"modified_in_seconds,omitempty"`

		// The name of the network object.
		Name *string `json:"name,omitempty"`

		// The UUID of the owner of the network object. The owner of the network object does not have any additional permissions above administrator permissions.
		OwnerUuid *string `json:"owner_uuid,omitempty"`

		// The UUID of the network object.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NetworksDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworksDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworksUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The number of days before assets age out. Assets are permanently deleted if they are not seen on a scan within the specified number of days.<ul><li>Minimum value: 90</li><li>Maximum value: 365</li></ul> Note: If you enable this option, Tenable.io immediately deletes assets in the specified network that have not been seen for the specified number of days. All asset records and associated vulnerabilities are deleted and cannot be recovered. The deleted assets no longer count towards [your license](https://docs.tenable.com/earlyaccess/tenableio/vulnerabilitymanagement/Content/GettingStarted/Licenses.htm)
		AssetsTtlDays *int `json:"assets_ttl_days,omitempty"`

		// The date (in Unix milliseconds) when the network object was created.
		Created *int `json:"created,omitempty"`

		// The UUID of the user who created the network object.
		CreatedBy *string `json:"created_by,omitempty"`

		// The date (in Unix seconds) when the network object was created.
		CreatedInSeconds *int `json:"created_in_seconds,omitempty"`

		// The date (in Unix time) when the network object was deleted. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
		Deleted *int `json:"deleted,omitempty"`

		// The UUID of the user who deleted the network object. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
		DeletedBy *string `json:"deleted_by,omitempty"`

		// The description of the network object.
		Description *string `json:"description,omitempty"`

		// Indicates whether the network object is the default network object. The default network object is a system-generated object that contains any scanners and scanner groups not yet assigned to a custom network object. You cannot update or delete the default network object.
		IsDefault *bool `json:"is_default,omitempty"`

		// The date (in Unix milliseconds) when the network object was last updated.
		Modified *int `json:"modified,omitempty"`

		// The UUID of the user who last updated the network object.
		ModifiedBy *string `json:"modified_by,omitempty"`

		// The date (in Unix seconds) when the network object was last updated.
		ModifiedInSeconds *int `json:"modified_in_seconds,omitempty"`

		// The name of the network object.
		Name *string `json:"name,omitempty"`

		// The UUID of the owner of the network object. The owner of the network object does not have any additional permissions above administrator permissions.
		OwnerUuid *string `json:"owner_uuid,omitempty"`

		// The UUID of the network object.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NetworksUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworksUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworksListAssignableScannersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Scanners *[]struct {
			// The date on which the scanner was linked to the Tenable.io instance.
			CreationDate *int32 `json:"creation_date,omitempty"`

			// The scanner software distribution.
			Distro *string `json:"distro,omitempty"`

			// The build of the engine running on the scanner.
			EngineBuild *string `json:"engine_build,omitempty"`

			// The version of the engine running on the scanner.
			EngineVersion *string `json:"engine_version,omitempty"`

			// Indicates whether the object represents a single scanner (`false`) or a scanner group (`true`).
			Group *bool `json:"group,omitempty"`

			// The unique ID of the scanner.
			Id *int32 `json:"id,omitempty"`

			// An alpha-numeric sequence of characters used when linking a scanner to Tenable.io.
			Key *string `json:"key,omitempty"`

			// The Unix timestamp when the scanner last connected to the Tenable.io instance.
			LastConnect *int32 `json:"last_connect,omitempty"`

			// The Unix timestamp when the scanner was last updated.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// Indicates if the scanner is enabled (`1`) or not disabled (`0`).
			Linked *int `json:"linked,omitempty"`

			// The current plugin set on the scanner.
			LoadedPluginSet *string `json:"loaded_plugin_set,omitempty"`

			// The user-defined name of the scanner.
			Name *string `json:"name,omitempty"`

			// The number of hosts that the scanner's analysis have discovered.
			NumHosts *int `json:"num_hosts,omitempty"`

			// The number of scan tasks the scanner is currently executing.
			NumScans *int `json:"num_scans,omitempty"`

			// The number of active sessions between the scanner and hosts.
			NumSessions *int `json:"num_sessions,omitempty"`

			// The number of active TCP sessions between the scanner and hosts.
			NumTcpSessions *int `json:"num_tcp_sessions,omitempty"`

			// The scanner owner.
			Owner *string `json:"owner,omitempty"`

			// The ID of the scanner owner.
			OwnerId *int `json:"owner_id,omitempty"`

			// The name of the scanner owner.
			OwnerName *string `json:"owner_name,omitempty"`

			// The UUID of the scanner owner.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The platform of the scanner.
			Platform *string `json:"platform,omitempty"`

			// Indicates whether the scanner is part of a scanner group.
			Pool *bool `json:"pool,omitempty"`

			// The UUID of the Nessus installation on the scanner.
			RemoteUuid *string `json:"remote_uuid,omitempty"`

			// The frequency (in seconds) at which the scanner polls the Tenable.io instance.
			ReportFrequency *int `json:"report_frequency,omitempty"`

			// The current number of scans currently running on the scanner.
			ScanCount *int                    `json:"scan_count,omitempty"`
			Settings  *map[string]interface{} `json:"settings,omitempty"`

			// Historical attribute. Always `service`.
			Source *string `json:"source,omitempty"`

			// The scanner's current status. Possible values are:
			//  - onThe scanner has connected in the last five minutes.
			//  - offThe scanner has not connected in the last five minutes.
			Status *string `json:"status,omitempty"`

			// Indicates whether the scanner supports remote logging.
			SupportsRemoteLogs *bool `json:"supports_remote_logs,omitempty"`

			// Equivalent to the last_modification_date.
			Timestamp *int `json:"timestamp,omitempty"`

			// The type of scanner (local or remote).
			Type *string `json:"type,omitempty"`

			// The UUID of the scanner.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"scanners,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NetworksListAssignableScannersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworksListAssignableScannersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoNetworksAssetCountDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The number of assets in the network not seen since the specified number of days.
		NumAssetsNotSeen *int `json:"numAssetsNotSeen,omitempty"`

		// The total number of assets in the network.
		NumAssetstotal *int `json:"numAssetstotal,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoNetworksAssetCountDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoNetworksAssetCountDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworksListScannersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Scanners *[]struct {
			// The date on which the scanner was linked to the Tenable.io instance.
			CreationDate *int32 `json:"creation_date,omitempty"`

			// The scanner software distribution.
			Distro *string `json:"distro,omitempty"`

			// The build of the engine running on the scanner.
			EngineBuild *string `json:"engine_build,omitempty"`

			// The version of the engine running on the scanner.
			EngineVersion *string `json:"engine_version,omitempty"`

			// Indicates whether the object represents a single scanner (`false`) or a scanner group (`true`).
			Group *bool `json:"group,omitempty"`

			// The unique ID of the scanner.
			Id *int32 `json:"id,omitempty"`

			// An alpha-numeric sequence of characters used when linking a scanner to Tenable.io.
			Key *string `json:"key,omitempty"`

			// The Unix timestamp when the scanner last connected to the Tenable.io instance.
			LastConnect *int32 `json:"last_connect,omitempty"`

			// The Unix timestamp when the scanner was last updated.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// Indicates if the scanner is enabled (`1`) or not disabled (`0`).
			Linked *int `json:"linked,omitempty"`

			// The current plugin set on the scanner.
			LoadedPluginSet *string `json:"loaded_plugin_set,omitempty"`

			// The user-defined name of the scanner.
			Name *string `json:"name,omitempty"`

			// The number of hosts that the scanner's analysis have discovered.
			NumHosts *int `json:"num_hosts,omitempty"`

			// The number of scan tasks the scanner is currently executing.
			NumScans *int `json:"num_scans,omitempty"`

			// The number of active sessions between the scanner and hosts.
			NumSessions *int `json:"num_sessions,omitempty"`

			// The number of active TCP sessions between the scanner and hosts.
			NumTcpSessions *int `json:"num_tcp_sessions,omitempty"`

			// The scanner owner.
			Owner *string `json:"owner,omitempty"`

			// The ID of the scanner owner.
			OwnerId *int `json:"owner_id,omitempty"`

			// The name of the scanner owner.
			OwnerName *string `json:"owner_name,omitempty"`

			// The UUID of the scanner owner.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The platform of the scanner.
			Platform *string `json:"platform,omitempty"`

			// Indicates whether the scanner is part of a scanner group.
			Pool *bool `json:"pool,omitempty"`

			// The UUID of the Nessus installation on the scanner.
			RemoteUuid *string `json:"remote_uuid,omitempty"`

			// The frequency (in seconds) at which the scanner polls the Tenable.io instance.
			ReportFrequency *int `json:"report_frequency,omitempty"`

			// The current number of scans currently running on the scanner.
			ScanCount *int                    `json:"scan_count,omitempty"`
			Settings  *map[string]interface{} `json:"settings,omitempty"`

			// Historical attribute. Always `service`.
			Source *string `json:"source,omitempty"`

			// The scanner's current status. Possible values are:
			//  - onThe scanner has connected in the last five minutes.
			//  - offThe scanner has not connected in the last five minutes.
			Status *string `json:"status,omitempty"`

			// Indicates whether the scanner supports remote logging.
			SupportsRemoteLogs *bool `json:"supports_remote_logs,omitempty"`

			// Equivalent to the last_modification_date.
			Timestamp *int `json:"timestamp,omitempty"`

			// The type of scanner (local or remote).
			Type *string `json:"type,omitempty"`

			// The UUID of the scanner.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"scanners,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NetworksListScannersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworksListScannersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworksAssignScannerBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON409      *struct {
		Conflicts *[]struct {
			// A list of scanner groups involved in the conflict.
			ScannerGroups *[]struct {
				// The name of the scanner group.
				Name *string `json:"name,omitempty"`

				// The UUID of the scanner group.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"scanner_groups,omitempty"`

			// The UUID of the scanner involved in the conflict.
			ScannerUuid *string `json:"scanner_uuid,omitempty"`
		} `json:"conflicts,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NetworksAssignScannerBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworksAssignScannerBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworksAssignScannerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON409      *struct {
		Conflicts *[]struct {
			// A list of scanner groups involved in the conflict.
			ScannerGroups *[]struct {
				// The name of the scanner group.
				Name *string `json:"name,omitempty"`

				// The UUID of the scanner group.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"scanner_groups,omitempty"`

			// The UUID of the scanner involved in the conflict.
			ScannerUuid *string `json:"scanner_uuid,omitempty"`
		} `json:"conflicts,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NetworksAssignScannerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworksAssignScannerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermissionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// The display-friendly name of the user or group.
		DisplayName *string `json:"display_name,omitempty"`

		// The unique ID of the user or group.
		Id *int `json:"id,omitempty"`

		// The name of the user or group.
		Name *string `json:"name,omitempty"`

		// The ID of the owner of the object.
		Owner *int `json:"owner,omitempty"`

		// The permission value to grant access as described in [Permissions](doc:permissions).
		Permissions *int32 `json:"permissions,omitempty"`

		// The type of permission (default, user, group).
		Type *N200Type `json:"type,omitempty"`

		// The UUID of the owner of the object.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PermissionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermissionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermissionsChangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r PermissionsChangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermissionsChangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoPluginsFamiliesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Families *[]struct {
			// The number of plugins in the family.
			Count *int `json:"count,omitempty"`

			// The unique ID of the family.
			Id *int `json:"id,omitempty"`

			// The name of the family.
			Name *string `json:"name,omitempty"`
		} `json:"families,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoPluginsFamiliesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoPluginsFamiliesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoPluginsFamilyDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The unique ID of the family.
		Id *int `json:"id,omitempty"`

		// The name of the family.
		Name    *string `json:"name,omitempty"`
		Plugins *[]struct {
			// The ID of the plugin.
			Id *int `json:"id,omitempty"`

			// The name of the plugin.
			Name *string `json:"name,omitempty"`
		} `json:"plugins,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoPluginsFamilyDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoPluginsFamilyDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoPluginsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			PluginDetails *[]struct {
				// The plugin attributes. For more information, see [Tenable Plugin Attributes](/docs/tenable-plugin-attributes).
				Attributes *[]struct {
					// A list of plugin target systems identified by Common Platform Enumeration (CPE).
					Cpe *[]string `json:"cpe,omitempty"`

					// A list of Common Vulnerabilities and Exposures (CVE) IDs for the vulnerabilities associated with the plugin.
					Cve *[]string `json:"cve,omitempty"`

					// The CVSSv3 base score (intrinsic and fundamental characteristics of a vulnerability that are constant over time and user environments).
					Cvss3BaseScore *string `json:"cvss3_base_score,omitempty"`

					// The CVSSv3 temporal metrics for the vulnerability.
					Cvss3TemporalScore *float32 `json:"cvss3_temporal_score,omitempty"`

					// The CVSSv2 base score (intrinsic and fundamental characteristics of a vulnerability that are constant over time and user environments).
					CvssBaseScore *string `json:"cvss_base_score,omitempty"`

					// The raw CVSSv2 temporal metrics for the vulnerability.
					CvssTemporalScore *float32 `json:"cvss_temporal_score,omitempty"`

					// The raw CVSSv2 metrics for the vulnerability. For more information, see CVSSv2 documentation.
					CvssVector *struct {
						// The CVSSv2 Access Complexity (AC) metric for the vulnerability the plugin covers. Possible values include:<br /> HHigh<br /> MMedium<br /> LLow
						AccessComplexity *string `json:"AccessComplexity,omitempty"`

						// The CVSSv2 Access Vector (AV) metric for the vulnerability the plugin covers. Possible values include: <br /> LLocal<br /> AAdjacent Network<br /> NNetwork
						AccessVector *string `json:"AccessVector,omitempty"`

						// The CVSSv2 Authentication (Au) metric for the vulnerability the plugin covers. Possible values include: <br /> NNone<br /> SSingle<br /> MMultiple
						Authentication *string `json:"Authentication,omitempty"`

						// The CVSSv2 availability impact metric for the vulnerability the plugin covers. Possible values include: <br /> NNone<br /> PPartial<br /> CComplete
						AvailabilityImpact *string `json:"Availability-Impact,omitempty"`

						// The CVSSv2 confidentiality impact metric for the vulnerability the plugin covers. Possible values include: <br /> NNone<br /> PPartial<br /> CComplete
						ConfidentialityImpact *string `json:"Confidentiality-Impact,omitempty"`

						// The CVSSv2 integrity impact metric for the vulnerability the plugin covers. Possible values include: <br /> NNone<br /> PPartial<br /> CComplete
						IntegrityImpact *string `json:"Integrity-Impact,omitempty"`
					} `json:"cvss_vector,omitempty"`

					// Indicates whether the plugin checks for default accounts requiring the use of credentials other than the credentials provided in the scan policy. For more information, see [What are the plugins that test for default accounts?](https://community.tenable.com/s/article/What-are-the-plugins-that-test-for-default-accounts) in the Tenable Community Portal.
					DefaultAccount *string `json:"default_account,omitempty"`

					// The extended description of the plugin.
					Description *string `json:"description,omitempty"`

					// Indicates whether a known public exploit exists for the vulnerability.
					ExploitAvailable *bool `json:"exploit_available,omitempty"`

					// Indicates whether an exploit exists in the Immunity CANVAS framework.
					ExploitFrameworkCanvas *bool `json:"exploit_framework_canvas,omitempty"`

					// Indicates whether an exploit exists in the CORE Impact framework.
					ExploitFrameworkCore *bool `json:"exploit_framework_core,omitempty"`

					// Indicates an exploit exists in the D2 Elliot Web Exploitation framework.
					ExploitFrameworkD2Elliot *bool `json:"exploit_framework_d2_elliot,omitempty"`

					// Indicates whether an exploit exists in the ExploitHub framework.
					ExploitFrameworkExploithub *bool `json:"exploit_framework_exploithub,omitempty"`

					// Indicates whether an exploit exists in the Metasploit framework.
					ExploitFrameworkMetasploit *bool `json:"exploit_framework_metasploit,omitempty"`

					// Indicates whether the vulnerability discovered by this plugin is known to be exploited by malware.
					ExploitedByMalware *bool `json:"exploited_by_malware,omitempty"`

					// Indicates whether Nessus exploited the vulnerability during the process of identification.
					ExploitedByNessus *bool `json:"exploited_by_nessus,omitempty"`

					// Indicates whether the vendor has published a patch for the vulnerability.
					HasPatch *bool `json:"has_patch,omitempty"`

					// Indicates whether this plugin has received media attention (for example, ShellShock, Meltdown).
					InTheNews *bool `json:"in_the_news,omitempty"`

					// Indicates whether the plugin targets potentially malicious files or processes.
					Malware *bool `json:"malware,omitempty"`

					// The date when the vendor published a patch for the vulnerability.
					PatchPublicationDate *string `json:"patch_publication_date,omitempty"`

					// The date when Tenable last updated the plugin.
					PluginModificationDate *string `json:"plugin_modification_date,omitempty"`

					// The date when Tenable originally published the plugin.
					PluginPublicationDate *string `json:"plugin_publication_date,omitempty"`

					// Plugin type, for example, local, remote, or combined. For more information about plugin type, see [Nessus Plugin Types and Categories](https://community.tenable.com/s/article/Nessus-Plugin-Types-and-Categories) in the Tenable Community Portal.
					PluginType *string `json:"plugin_type,omitempty"`

					// The version of the plugin.
					PluginVersion *string `json:"plugin_version,omitempty"`

					// The risk factor associated with the plugin. Possible values are: Low, Medium, High, or Critical.
					RiskFactor *string `json:"risk_factor,omitempty"`

					// Links to external websites that contain helpful information about the vulnerability.
					SeeAlso *[]string `json:"see_also,omitempty"`

					// Remediation information for the vulnerability.
					Solution *string `json:"solution,omitempty"`

					// A brief summary of the vulnerability or vulnerabilities associated with the plugin.
					Synopsis *string `json:"synopsis,omitempty"`

					// Indicates whether the software found by this plugin is unsupported by the software's vendor (for example, Windows 95 or Firefox 3).
					UnsupportedByVendor *bool `json:"unsupported_by_vendor,omitempty"`

					// Information about the Vulnerability Priority Rating (VPR) for the plugin.
					Vpr *struct {
						// The key drivers Tenable uses to calculate a vulnerability's VPR. For more information, see <a href="/docs/vpr-drivers-tio">Vulnerability Priority Rating Drivers</a>.
						Drivers *map[string]interface{} `json:"drivers,omitempty"`

						// The Vulnerability Priority Rating (VPR) for the vulnerability. If a plugin is designed to detect multiple vulnerabilities, the VPR represents the highest value calculated for a vulnerability associated with the plugin. For more information, see <a href="https://docs.tenable.com/cloud/Content/Analysis/RiskMetrics.htm" target="_blank">Severity vs. VPR</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
						Score *float32 `json:"score,omitempty"`

						// The ISO timestamp when Tenable.io last imported the VPR for this vulnerability. Tenable.io imports updated VPR values every time you run a scan.
						Updated *string `json:"updated,omitempty"`
					} `json:"vpr,omitempty"`

					// References to third-party information about the vulnerability, exploit, or update associated with the plugin. Each reference includes a type, for example, 'FEDORA', and an ID, for example, '2003-047'.
					Xref *[]string `json:"xref,omitempty"`

					// References to third-party information about the vulnerability, exploit, or update associated with the plugin. Each reference includes a type and an ID. For example, 'FEDORA' and '2003-047'.
					Xrefs *[]string `json:"xrefs,omitempty"`
				} `json:"attributes,omitempty"`

				// The ID of the plugin.
				Id *int `json:"id,omitempty"`

				// The name of the plugin.
				Name *string `json:"name,omitempty"`
			} `json:"plugin_details,omitempty"`
		} `json:"data,omitempty"`

		// The URL query parameters for the returned data set. If the request does not specify the parameters, contains default values.
		Params *struct {
			// The 'last_updated' filter value.
			LastUpdated *string `json:"last_updated,omitempty"`

			// The result set page index. For example, if page size is 10, page 2 contains records 10-19. Default value is 1.
			Page *int `json:"page,omitempty"`

			// The result set page size. Default value is 1,000.
			Size *int `json:"size,omitempty"`
		} `json:"params,omitempty"`

		// The number of records in the returned result set.
		Size *int `json:"size,omitempty"`

		// The total number of available plugin records after Tenable.io applies the last_updated filter.
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoPluginsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoPluginsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoPluginsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The plugin attributes.
		Attributes *[]struct {
			// The name of the attribute.
			AttributeName *string `json:"attribute_name,omitempty"`

			// The value of the attribute.
			AttributeValue *string `json:"attribute_value,omitempty"`
		} `json:"attributes,omitempty"`

		// The name of the plugin family.
		FamilyName *string `json:"family_name,omitempty"`

		// The ID of the plugin.
		Id *int `json:"id,omitempty"`

		// The name of the plugin.
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoPluginsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoPluginsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PoliciesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// The creation date of the policy in Unix time format.
		CreationDate *int `json:"creation_date,omitempty"`

		// The description of the policy.
		Description *string `json:"description,omitempty"`

		// The unique ID of the policy.
		Id *int `json:"id,omitempty"`

		// The last modification date for the policy in Unix time format.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The name of the policy.
		Name *string `json:"name,omitempty"`

		// If `true`, the policy configuration does not include targets.
		NoTarget *bool `json:"no_target,omitempty"`

		// The username for the owner of the policy.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the policy.
		OwnerId *string `json:"owner_id,omitempty"`

		// The shared status of the policy (`1` if shared with users other than owner, `0` if not shared).
		Shared *bool `json:"shared,omitempty"`

		// The UUID for the Tenable-provided template used to create the policy.
		TemplateUuid *string `json:"template_uuid,omitempty"`

		// The sharing permissions for the policy.
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The visibility of the target (`private` or `shared`).
		Visibility *int `json:"visibility,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PoliciesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PoliciesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PoliciesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		PolicyId   *int    `json:"policy_id,omitempty"`
		PolicyName *string `json:"policy_name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PoliciesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PoliciesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PoliciesImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CreationDate         *int    `json:"creation_date,omitempty"`
		Description          *string `json:"description,omitempty"`
		Id                   *int    `json:"id,omitempty"`
		LastModificationDate *int    `json:"last_modification_date,omitempty"`
		Name                 *string `json:"name,omitempty"`
		NoTarget             *string `json:"no_target,omitempty"`
		Owner                *string `json:"owner,omitempty"`
		OwnerId              *int    `json:"owner_id,omitempty"`
		Private              *int    `json:"private,omitempty"`
		Shared               *bool   `json:"shared,omitempty"`
		TemplateUuid         *string `json:"template_uuid,omitempty"`
		UserPermissions      *int    `json:"user_permissions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PoliciesImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PoliciesImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PoliciesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r PoliciesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PoliciesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PoliciesDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Audits      *map[string]interface{} `json:"audits,omitempty"`
		Credentials *map[string]interface{} `json:"credentials,omitempty"`
		Plugins     *map[string]interface{} `json:"plugins,omitempty"`
		Scap        *map[string]interface{} `json:"scap,omitempty"`
		Settings    *map[string]interface{} `json:"settings,omitempty"`

		// The UUID of the Tenable-provided template used to create this policy.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PoliciesDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PoliciesDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PoliciesConfigureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r PoliciesConfigureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PoliciesConfigureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PoliciesCopyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r PoliciesCopyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PoliciesCopyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PoliciesExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r PoliciesExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PoliciesExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannerGroupsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The creation date for the scanner group in Unix time.
		CreationDate *int `json:"creation_date,omitempty"`

		// The access permissions for the Default group.
		DefaultPermissions *int `json:"default_permissions,omitempty"`

		// The flag indicating what type of scanner group.
		Flag *string `json:"flag,omitempty"`

		// The unique ID of the scanner group.
		Id *int `json:"id,omitempty"`

		// The last modification date for the scanner group in Unix time.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The name of the scanner group.
		Name *string `json:"name,omitempty"`

		// The name of the network object associated with the scanner group. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkName *string `json:"network_name,omitempty"`

		// The username of the owner of the scanner group.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the scanner group.
		OwnerId *int `json:"owner_id,omitempty"`

		// The number of scans currently tasked to the scanner group.
		ScanCount *int `json:"scan_count,omitempty"`

		// The number of scanners associated with this scanner group.
		ScannerCount *string `json:"scanner_count,omitempty"`

		// The unique scanner ID of the scanner group.
		ScannerId *int `json:"scanner_id,omitempty"`

		// The shared status of the scanner-group.
		Shared *bool `json:"shared,omitempty"`

		// The unique token for a scanner group.
		Token *string `json:"token,omitempty"`

		// The type of scanner group. This is set to "load_balancing" by default.
		Type *string `json:"type,omitempty"`

		// The sharing permissions for the scanner group.
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the scanner group.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScannerGroupsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannerGroupsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannerGroupsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The creation date for the scanner group in Unix time.
		CreationDate *int `json:"creation_date,omitempty"`

		// The access permissions for the Default group.
		DefaultPermissions *int `json:"default_permissions,omitempty"`

		// The flag indicating what type of scanner group.
		Flag *string `json:"flag,omitempty"`

		// The unique ID of the scanner group.
		Id *int `json:"id,omitempty"`

		// The last modification date for the scanner group in Unix time.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The name of the scanner group.
		Name *string `json:"name,omitempty"`

		// The name of the network object associated with the scanner group. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkName *string `json:"network_name,omitempty"`

		// The username of the owner of the scanner group.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the scanner group.
		OwnerId *int `json:"owner_id,omitempty"`

		// The number of scans currently tasked to the scanner group.
		ScanCount *int `json:"scan_count,omitempty"`

		// The number of scanners associated with this scanner group.
		ScannerCount *string `json:"scanner_count,omitempty"`

		// The unique scanner ID of the scanner group.
		ScannerId *int `json:"scanner_id,omitempty"`

		// The shared status of the scanner-group.
		Shared *bool `json:"shared,omitempty"`

		// The unique token for a scanner group.
		Token *string `json:"token,omitempty"`

		// The type of scanner group. This is set to "load_balancing" by default.
		Type *string `json:"type,omitempty"`

		// The sharing permissions for the scanner group.
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the scanner group.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScannerGroupsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannerGroupsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannerGroupsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScannerGroupsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannerGroupsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannerGroupsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The creation date for the scanner group in Unix time.
		CreationDate *int `json:"creation_date,omitempty"`

		// The access permissions for the Default group.
		DefaultPermissions *int `json:"default_permissions,omitempty"`

		// The flag indicating what type of scanner group.
		Flag *string `json:"flag,omitempty"`

		// The unique ID of the scanner group.
		Id *int `json:"id,omitempty"`

		// The last modification date for the scanner group in Unix time.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The name of the scanner group.
		Name *string `json:"name,omitempty"`

		// The name of the network object associated with the scanner group. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkName *string `json:"network_name,omitempty"`

		// The username of the owner of the scanner group.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the scanner group.
		OwnerId *int `json:"owner_id,omitempty"`

		// The number of scans currently tasked to the scanner group.
		ScanCount *int `json:"scan_count,omitempty"`

		// The number of scanners associated with this scanner group.
		ScannerCount *string `json:"scanner_count,omitempty"`

		// The unique scanner ID of the scanner group.
		ScannerId *int `json:"scanner_id,omitempty"`

		// The shared status of the scanner-group.
		Shared *bool `json:"shared,omitempty"`

		// The unique token for a scanner group.
		Token *string `json:"token,omitempty"`

		// The type of scanner group. This is set to "load_balancing" by default.
		Type *string `json:"type,omitempty"`

		// The sharing permissions for the scanner group.
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the scanner group.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScannerGroupsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannerGroupsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannerGroupsEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The creation date for the scanner group in Unix time.
		CreationDate *int `json:"creation_date,omitempty"`

		// The access permissions for the Default group.
		DefaultPermissions *int `json:"default_permissions,omitempty"`

		// The flag indicating what type of scanner group.
		Flag *string `json:"flag,omitempty"`

		// The unique ID of the scanner group.
		Id *int `json:"id,omitempty"`

		// The last modification date for the scanner group in Unix time.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The name of the scanner group.
		Name *string `json:"name,omitempty"`

		// The name of the network object associated with the scanner group. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkName *string `json:"network_name,omitempty"`

		// The username of the owner of the scanner group.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the scanner group.
		OwnerId *int `json:"owner_id,omitempty"`

		// The number of scans currently tasked to the scanner group.
		ScanCount *int `json:"scan_count,omitempty"`

		// The number of scanners associated with this scanner group.
		ScannerCount *string `json:"scanner_count,omitempty"`

		// The unique scanner ID of the scanner group.
		ScannerId *int `json:"scanner_id,omitempty"`

		// The shared status of the scanner-group.
		Shared *bool `json:"shared,omitempty"`

		// The unique token for a scanner group.
		Token *string `json:"token,omitempty"`

		// The type of scanner group. This is set to "load_balancing" by default.
		Type *string `json:"type,omitempty"`

		// The sharing permissions for the scanner group.
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the scanner group.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScannerGroupsEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannerGroupsEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoScannerGroupsListRoutesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// A hostname, hostname wildcard, IP address, CIDR address, or IP range. For more information about supported route formats, see [Supported Scan Routing Target Formats](doc:manage-scan-routing-tio#section-supported-scan-routing-target-formats).
		Route string `json:"route"`
	}
}

// Status returns HTTPResponse.Status
func (r IoScannerGroupsListRoutesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoScannerGroupsListRoutesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoScannerGroupsUpdateRoutesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *struct {
		// A brief description of the cause of the error.
		Error *string `json:"error,omitempty"`
	}
	JSON404 *struct {
		// A brief description of the cause of the error.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoScannerGroupsUpdateRoutesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoScannerGroupsUpdateRoutesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannerGroupsListScannersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Specifies how often, in minutes, the scanner checks in with Tenable.io (Amazon Web Services scanners only).
		AwsUpdateInterval *int `json:"aws_update_interval,omitempty"`

		// The Unix timestamp when the scanner was created. This attribute specifies the original creation date if the scanner was migrated.
		CreationDate *int `json:"creation_date,omitempty"`

		// The scanner operating system distribution.
		Distro *string `json:"distro,omitempty"`

		// The version of the scanner.
		EngineVersion *string `json:"engine_version,omitempty"`

		// Indicates whether the scanner belongs to a scanner group ('true') or not ('false').
		Group *bool `json:"group,omitempty"`

		// The hostname of the scanner.
		Hostname *string `json:"hostname,omitempty"`

		// The unique ID of the scanner.
		Id *int `json:"id,omitempty"`

		// A list of IP addresses associated with the scanner.
		IpAddresses *[]string `json:"ip_addresses,omitempty"`

		// The linking key, that is, the alpha-numeric sequence of characters you use to link a scanner to Tenable.io. For more information about linking a scanner to Tenable.io, see the [Tenable.io Vulnerability Management Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/LinkaSensor.htm).
		Key *string `json:"key,omitempty"`

		// The Unix timestamp when any of the scanner's tasks have provided its last update.
		LastConnect *string `json:"last_connect,omitempty"`

		// The Unix timestamp when the scanner was last modified.
		LastModificationDate *int `json:"last_modification_date,omitempty"`
		License              *struct {
			// The number of agents the scanner is licensed to use.
			Agents *int `json:"agents,omitempty"`
			Apps   *struct {
				Consec *struct {
					// The activation code you used to enable the license. This value is present for standard licenses only.
					ActivationCode *int `json:"activation_code,omitempty"`

					// The Unix timestamp when the license expires.
					ExpirationDate *int `json:"expiration_date,omitempty"`

					// The maximum memory (in GB) on the scanner allotted for the Tenable licensed application.
					MaxGb *int `json:"max_gb,omitempty"`

					// Indicates whether the product license is an evaluation license (`eval`) or standard license (`standard`).
					Mode *string `json:"mode,omitempty"`

					// Indicates that the scanner is licensed to perform Tenable.io Container Security scans.
					Type *string `json:"type,omitempty"`
				} `json:"consec,omitempty"`

				// The Tenable products licensed on the scanner.
				Type *string `json:"type,omitempty"`
				Was  *struct {
					// The activation code you used to enable the license. This value is present for standard licenses only.
					ActivationCode *int `json:"activation_code,omitempty"`

					// The Unix timestamp when the license expires.
					ExpirationDate *int `json:"expiration_date,omitempty"`

					// Indicates whether the product license is an evaluation license (`eval`) or standard license (`standard`).
					Mode *string `json:"mode,omitempty"`

					// Indicates that the scanner is licensed to perform Tenable.io Web Application Scanning scans.
					Type *string `json:"type,omitempty"`

					// The number of web assets which your license authorizes you to scan.
					WebAssets *int `json:"web_assets,omitempty"`
				} `json:"was,omitempty"`
			} `json:"apps,omitempty"`

			// The number of hosts the scanner is licensed to use.
			Ips *int `json:"ips,omitempty"`

			// The number of scanners the scanner is licensed to use.
			Scanners *int `json:"scanners,omitempty"`

			// The license type.
			Type *string `json:"type,omitempty"`
		} `json:"license,omitempty"`

		// Specifies whether you disabled (`0`) or enabled (`1`) the scanner. For more information, see the [PUT /scanners/{scanner_id}/link](ref:scanners-toggle-link-state) endpoint.
		Linked *int `json:"linked,omitempty"`

		// The current plugin set on the scanner.
		LoadedPluginSet *string `json:"loaded_plugin_set,omitempty"`

		// The user-defined name of the scanner.
		Name *string `json:"name,omitempty"`

		// The name of the network object associated with the scanner. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkName *string `json:"network_name,omitempty"`

		// The number of hosts that the scanner's analysis has discovered.
		NumHosts *int `json:"num_hosts,omitempty"`

		// The number of scans (tasks) the scanner is currently executing.
		NumScans *int `json:"num_scans,omitempty"`

		// The number of active sessions between the scanner and hosts.
		NumSessions *int `json:"num_sessions,omitempty"`

		// The number of active TCP sessions between the scanner and hosts.
		NumTcpSessions *int `json:"num_tcp_sessions,omitempty"`

		// The owner of the scanner.
		Owner *string `json:"owner,omitempty"`

		// The ID of the owner of the scanner.
		OwnerId *int `json:"owner_id,omitempty"`

		// The username of the owner of the scanner.
		OwnerName *string `json:"owner_name,omitempty"`

		// The UUID of the owner of the scanner.
		OwnerUuid *string `json:"owner_uuid,omitempty"`

		// The platform of the scanner.
		Platform *string `json:"platform,omitempty"`

		// Indicates whether the scanner is part of a scanner group ('true') or not ('false'). For more information about scanner groups, see the [Scanner Groups](ref:scanner-groups) endpoints.
		Pool *bool `json:"pool,omitempty"`

		// The registration code of the scanner.
		RegistrationCode *string `json:"registration_code,omitempty"`

		// The number of scans that the scanner is currently running.
		ScanCount *int `json:"scan_count,omitempty"`

		// Indicates whether anyone other than the scanner owner has explicit access to the scanner (`1`).
		Shared *bool `json:"shared,omitempty"`

		// Always set to `service`.
		Source *string `json:"source,omitempty"`

		// The status of the scanner (`on` or `off`).
		Status *string `json:"status,omitempty"`

		// Indicates if the scanner supports remote logging.
		SupportsRemoteLogs *bool `json:"supports_remote_logs,omitempty"`

		// Indicates if the scanner supports web application scanning.
		SupportsWebapp *bool `json:"supports_webapp,omitempty"`

		// Equivalent to the `last_modification_date` attribute.
		Timestamp *int `json:"timestamp,omitempty"`

		// The type of scanner (`local`, `managed`, `managed_pvs`, `pool`, `remote`, or `webapp`).
		Type *string `json:"type,omitempty"`

		// The backend build of Nessus that is running on the scanner.
		UiBuild *string `json:"ui_build,omitempty"`

		// The backend version of Nessus that is running on the scanner.
		UiVersion *string `json:"ui_version,omitempty"`

		// The permissions you (the current user) have been assigned for the scanner. See [Permissions](doc:permissions).
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the scanner.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScannerGroupsListScannersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannerGroupsListScannersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannerGroupsDeleteScannerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScannerGroupsDeleteScannerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannerGroupsDeleteScannerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannerGroupsAddScannerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScannerGroupsAddScannerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannerGroupsAddScannerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Scanners []struct {
			Challenge *string `json:"challenge,omitempty"`
			// Specifies how often, in minutes, the scanner checks in with Tenable.io (Amazon Web Services scanners only).
			AwsUpdateInterval *int `json:"aws_update_interval,omitempty"`

			// The Unix timestamp when the scanner was created. This attribute specifies the original creation date if the scanner was migrated.
			CreationDate *int `json:"creation_date,omitempty"`

			// The scanner operating system distribution.
			Distro *string `json:"distro,omitempty"`

			// The version of the scanner.
			EngineVersion *string `json:"engine_version,omitempty"`

			// Indicates whether the scanner belongs to a scanner group ('true') or not ('false').
			Group *bool `json:"group,omitempty"`

			// The hostname of the scanner.
			Hostname *string `json:"hostname,omitempty"`

			// The unique ID of the scanner.
			Id *int `json:"id,omitempty"`

			// A list of IP addresses associated with the scanner.
			IpAddresses *[]string `json:"ip_addresses,omitempty"`

			// The linking key, that is, the alpha-numeric sequence of characters you use to link a scanner to Tenable.io. For more information about linking a scanner to Tenable.io, see the [Tenable.io Vulnerability Management Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/LinkaSensor.htm).
			Key *string `json:"key,omitempty"`

			// The Unix timestamp when any of the scanner's tasks have provided its last update.
			LastConnect *string `json:"last_connect,omitempty"`

			// The Unix timestamp when the scanner was last modified.
			LastModificationDate *int `json:"last_modification_date,omitempty"`
			License              *struct {
				// The number of agents the scanner is licensed to use.
				Agents *int `json:"agents,omitempty"`
				Apps   *struct {
					Consec *struct {
						// The activation code you used to enable the license. This value is present for standard licenses only.
						ActivationCode *int `json:"activation_code,omitempty"`

						// The Unix timestamp when the license expires.
						ExpirationDate *int `json:"expiration_date,omitempty"`

						// The maximum memory (in GB) on the scanner allotted for the Tenable licensed application.
						MaxGb *int `json:"max_gb,omitempty"`

						// Indicates whether the product license is an evaluation license (`eval`) or standard license (`standard`).
						Mode *string `json:"mode,omitempty"`

						// Indicates that the scanner is licensed to perform Tenable.io Container Security scans.
						Type *string `json:"type,omitempty"`
					} `json:"consec,omitempty"`

					// The Tenable products licensed on the scanner.
					Type *string `json:"type,omitempty"`
					Was  *struct {
						// The activation code you used to enable the license. This value is present for standard licenses only.
						ActivationCode *int `json:"activation_code,omitempty"`

						// The Unix timestamp when the license expires.
						ExpirationDate *int `json:"expiration_date,omitempty"`

						// Indicates whether the product license is an evaluation license (`eval`) or standard license (`standard`).
						Mode *string `json:"mode,omitempty"`

						// Indicates that the scanner is licensed to perform Tenable.io Web Application Scanning scans.
						Type *string `json:"type,omitempty"`

						// The number of web assets which your license authorizes you to scan.
						WebAssets *int `json:"web_assets,omitempty"`
					} `json:"was,omitempty"`
				} `json:"apps,omitempty"`

				// The number of hosts the scanner is licensed to use.
				Ips *int `json:"ips,omitempty"`

				// The number of scanners the scanner is licensed to use.
				Scanners *int `json:"scanners,omitempty"`

				// The license type.
				Type *string `json:"type,omitempty"`
			} `json:"license,omitempty"`

			// Specifies whether you disabled (`0`) or enabled (`1`) the scanner. For more information, see the [PUT /scanners/{scanner_id}/link](ref:scanners-toggle-link-state) endpoint.
			Linked *int `json:"linked,omitempty"`

			// The current plugin set on the scanner.
			LoadedPluginSet *string `json:"loaded_plugin_set,omitempty"`

			// The user-defined name of the scanner.
			Name *string `json:"name,omitempty"`

			// The name of the network object associated with the scanner. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkName *string `json:"network_name,omitempty"`

			// The number of hosts that the scanner's analysis has discovered.
			NumHosts *int `json:"num_hosts,omitempty"`

			// The number of scans (tasks) the scanner is currently executing.
			NumScans *int `json:"num_scans,omitempty"`

			// The number of active sessions between the scanner and hosts.
			NumSessions *int `json:"num_sessions,omitempty"`

			// The number of active TCP sessions between the scanner and hosts.
			NumTcpSessions *int `json:"num_tcp_sessions,omitempty"`

			// The owner of the scanner.
			Owner *string `json:"owner,omitempty"`

			// The ID of the owner of the scanner.
			OwnerId *int `json:"owner_id,omitempty"`

			// The username of the owner of the scanner.
			OwnerName *string `json:"owner_name,omitempty"`

			// The UUID of the owner of the scanner.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The platform of the scanner.
			Platform *string `json:"platform,omitempty"`

			// Indicates whether the scanner is part of a scanner group ('true') or not ('false'). For more information about scanner groups, see the [Scanner Groups](ref:scanner-groups) endpoints.
			Pool *bool `json:"pool,omitempty"`

			// The registration code of the scanner.
			RegistrationCode *string `json:"registration_code,omitempty"`

			// The number of scans that the scanner is currently running.
			ScanCount *int `json:"scan_count,omitempty"`

			// Indicates whether anyone other than the scanner owner has explicit access to the scanner (`1`).
			Shared *int `json:"shared,omitempty"`

			// Always set to `service`.
			Source *string `json:"source,omitempty"`

			// The status of the scanner (`on` or `off`).
			Status *string `json:"status,omitempty"`

			// Indicates if the scanner supports remote logging.
			SupportsRemoteLogs *bool `json:"supports_remote_logs,omitempty"`

			// Indicates if the scanner supports web application scanning.
			SupportsWebapp *bool `json:"supports_webapp,omitempty"`

			// Equivalent to the `last_modification_date` attribute.
			Timestamp *int `json:"timestamp,omitempty"`

			// The type of scanner (`local`, `managed`, `managed_pvs`, `pool`, `remote`, or `webapp`).
			Type *string `json:"type,omitempty"`

			// The backend build of Nessus that is running on the scanner.
			UiBuild *string `json:"ui_build,omitempty"`

			// The backend version of Nessus that is running on the scanner.
			UiVersion *string `json:"ui_version,omitempty"`

			// The permissions you (the current user) have been assigned for the scanner. See [Permissions](doc:permissions).
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the scanner.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"scanners,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScannersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkAddAgentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// `total_work_units_completed` divided by `total_work_units`.
		CompletionPercentage *int `json:"completion_percentage,omitempty"`

		// The UUID of the container where the task is operating.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// End time of the task in unix time milliseconds, if the task is finished.
		EndTime *int `json:"end_time,omitempty"`

		// Last time progress was made on executing the task in unix time milliseconds.
		LastUpdateTime *int `json:"last_update_time,omitempty"`

		// An informative, human-readable message about the state of the task.
		Message *string `json:"message,omitempty"`

		// Start time of the task in unix time milliseconds.
		StartTime *int `json:"start_time,omitempty"`

		// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
		Status *N200Status `json:"status,omitempty"`

		// The UUID of the task.
		TaskId *string `json:"task_id,omitempty"`

		// Total amount of work which the task will attempt to complete.
		TotalWorkUnits *int `json:"total_work_units,omitempty"`

		// Total amount of work that the task has completed.
		TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkAddAgentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkAddAgentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoAgentBulkOperationsGroupDirectiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// `total_work_units_completed` divided by `total_work_units`.
		CompletionPercentage *int `json:"completion_percentage,omitempty"`

		// The UUID of the container where the task is operating.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// End time of the task in unix time milliseconds, if the task is finished.
		EndTime *int `json:"end_time,omitempty"`

		// Last time progress was made on executing the task in unix time milliseconds.
		LastUpdateTime *int `json:"last_update_time,omitempty"`

		// An informative, human-readable message about the state of the task.
		Message *string `json:"message,omitempty"`

		// Start time of the task in unix time milliseconds.
		StartTime *int `json:"start_time,omitempty"`

		// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
		Status *N200Status `json:"status,omitempty"`

		// The UUID of the task.
		TaskId *string `json:"task_id,omitempty"`

		// Total amount of work which the task will attempt to complete.
		TotalWorkUnits *int `json:"total_work_units,omitempty"`

		// Total amount of work that the task has completed.
		TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoAgentBulkOperationsGroupDirectiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoAgentBulkOperationsGroupDirectiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkRemoveAgentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// `total_work_units_completed` divided by `total_work_units`.
		CompletionPercentage *int `json:"completion_percentage,omitempty"`

		// The UUID of the container where the task is operating.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// End time of the task in unix time milliseconds, if the task is finished.
		EndTime *int `json:"end_time,omitempty"`

		// Last time progress was made on executing the task in unix time milliseconds.
		LastUpdateTime *int `json:"last_update_time,omitempty"`

		// An informative, human-readable message about the state of the task.
		Message *string `json:"message,omitempty"`

		// Start time of the task in unix time milliseconds.
		StartTime *int `json:"start_time,omitempty"`

		// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
		Status *N200Status `json:"status,omitempty"`

		// The UUID of the task.
		TaskId *string `json:"task_id,omitempty"`

		// Total amount of work which the task will attempt to complete.
		TotalWorkUnits *int `json:"total_work_units,omitempty"`

		// Total amount of work that the task has completed.
		TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkRemoveAgentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkRemoveAgentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkTaskAgentGroupStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// `total_work_units_completed` divided by `total_work_units`.
		CompletionPercentage *int `json:"completion_percentage,omitempty"`

		// The UUID of the container where the task is operating.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// End time of the task in unix time milliseconds, if the task is finished.
		EndTime *int `json:"end_time,omitempty"`

		// Last time progress was made on executing the task in unix time milliseconds.
		LastUpdateTime *int `json:"last_update_time,omitempty"`

		// An informative, human-readable message about the state of the task.
		Message *string `json:"message,omitempty"`

		// Start time of the task in unix time milliseconds.
		StartTime *int `json:"start_time,omitempty"`

		// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
		Status *N200Status `json:"status,omitempty"`

		// The UUID of the task.
		TaskId *string `json:"task_id,omitempty"`

		// Total amount of work which the task will attempt to complete.
		TotalWorkUnits *int `json:"total_work_units,omitempty"`

		// Total amount of work that the task has completed.
		TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkTaskAgentGroupStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkTaskAgentGroupStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoAgentBulkOperationsAddToNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// `total_work_units_completed` divided by `total_work_units`.
		CompletionPercentage *int `json:"completion_percentage,omitempty"`

		// The UUID of the container where the task is operating.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// End time of the task in unix time milliseconds, if the task is finished.
		EndTime *int `json:"end_time,omitempty"`

		// Last time progress was made on executing the task in unix time milliseconds.
		LastUpdateTime *int `json:"last_update_time,omitempty"`

		// An informative, human-readable message about the state of the task.
		Message *string `json:"message,omitempty"`

		// Start time of the task in unix time milliseconds.
		StartTime *int `json:"start_time,omitempty"`

		// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
		Status *N200Status `json:"status,omitempty"`

		// The UUID of the task.
		TaskId *string `json:"task_id,omitempty"`

		// Total amount of work which the task will attempt to complete.
		TotalWorkUnits *int `json:"total_work_units,omitempty"`

		// Total amount of work that the task has completed.
		TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoAgentBulkOperationsAddToNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoAgentBulkOperationsAddToNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoAgentBulkOperationsDirectiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// `total_work_units_completed` divided by `total_work_units`.
		CompletionPercentage *int `json:"completion_percentage,omitempty"`

		// The UUID of the container where the task is operating.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// End time of the task in unix time milliseconds, if the task is finished.
		EndTime *int `json:"end_time,omitempty"`

		// Last time progress was made on executing the task in unix time milliseconds.
		LastUpdateTime *int `json:"last_update_time,omitempty"`

		// An informative, human-readable message about the state of the task.
		Message *string `json:"message,omitempty"`

		// Start time of the task in unix time milliseconds.
		StartTime *int `json:"start_time,omitempty"`

		// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
		Status *N200Status `json:"status,omitempty"`

		// The UUID of the task.
		TaskId *string `json:"task_id,omitempty"`

		// Total amount of work which the task will attempt to complete.
		TotalWorkUnits *int `json:"total_work_units,omitempty"`

		// Total amount of work that the task has completed.
		TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoAgentBulkOperationsDirectiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoAgentBulkOperationsDirectiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoAgentBulkOperationsRemoveFromNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// `total_work_units_completed` divided by `total_work_units`.
		CompletionPercentage *int `json:"completion_percentage,omitempty"`

		// The UUID of the container where the task is operating.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// End time of the task in unix time milliseconds, if the task is finished.
		EndTime *int `json:"end_time,omitempty"`

		// Last time progress was made on executing the task in unix time milliseconds.
		LastUpdateTime *int `json:"last_update_time,omitempty"`

		// An informative, human-readable message about the state of the task.
		Message *string `json:"message,omitempty"`

		// Start time of the task in unix time milliseconds.
		StartTime *int `json:"start_time,omitempty"`

		// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
		Status *N200Status `json:"status,omitempty"`

		// The UUID of the task.
		TaskId *string `json:"task_id,omitempty"`

		// Total amount of work which the task will attempt to complete.
		TotalWorkUnits *int `json:"total_work_units,omitempty"`

		// Total amount of work that the task has completed.
		TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoAgentBulkOperationsRemoveFromNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoAgentBulkOperationsRemoveFromNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUnlinkAgentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// `total_work_units_completed` divided by `total_work_units`.
		CompletionPercentage *int `json:"completion_percentage,omitempty"`

		// The UUID of the container where the task is operating.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// End time of the task in unix time milliseconds, if the task is finished.
		EndTime *int `json:"end_time,omitempty"`

		// Last time progress was made on executing the task in unix time milliseconds.
		LastUpdateTime *int `json:"last_update_time,omitempty"`

		// An informative, human-readable message about the state of the task.
		Message *string `json:"message,omitempty"`

		// Start time of the task in unix time milliseconds.
		StartTime *int `json:"start_time,omitempty"`

		// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
		Status *N200Status `json:"status,omitempty"`

		// The UUID of the task.
		TaskId *string `json:"task_id,omitempty"`

		// Total amount of work which the task will attempt to complete.
		TotalWorkUnits *int `json:"total_work_units,omitempty"`

		// Total amount of work that the task has completed.
		TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkUnlinkAgentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUnlinkAgentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkTaskAgentStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// `total_work_units_completed` divided by `total_work_units`.
		CompletionPercentage *int `json:"completion_percentage,omitempty"`

		// The UUID of the container where the task is operating.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// End time of the task in unix time milliseconds, if the task is finished.
		EndTime *int `json:"end_time,omitempty"`

		// Last time progress was made on executing the task in unix time milliseconds.
		LastUpdateTime *int `json:"last_update_time,omitempty"`

		// An informative, human-readable message about the state of the task.
		Message *string `json:"message,omitempty"`

		// Start time of the task in unix time milliseconds.
		StartTime *int `json:"start_time,omitempty"`

		// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
		Status *N200Status `json:"status,omitempty"`

		// The UUID of the task.
		TaskId *string `json:"task_id,omitempty"`

		// Total amount of work which the task will attempt to complete.
		TotalWorkUnits *int `json:"total_work_units,omitempty"`

		// Total amount of work that the task has completed.
		TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkTaskAgentStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkTaskAgentStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannersDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScannersDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannersDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannersDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Specifies how often, in minutes, the scanner checks in with Tenable.io (Amazon Web Services scanners only).
		AwsUpdateInterval *int `json:"aws_update_interval,omitempty"`

		// The Unix timestamp when the scanner was created. This attribute specifies the original creation date if the scanner was migrated.
		CreationDate *int `json:"creation_date,omitempty"`

		// The scanner operating system distribution.
		Distro *string `json:"distro,omitempty"`

		// The version of the scanner.
		EngineVersion *string `json:"engine_version,omitempty"`

		// Indicates whether the scanner belongs to a scanner group ('true') or not ('false').
		Group *bool `json:"group,omitempty"`

		// The hostname of the scanner.
		Hostname *string `json:"hostname,omitempty"`

		// The unique ID of the scanner.
		Id *int `json:"id,omitempty"`

		// A list of IP addresses associated with the scanner.
		IpAddresses *[]string `json:"ip_addresses,omitempty"`

		// The linking key, that is, the alpha-numeric sequence of characters you use to link a scanner to Tenable.io. For more information about linking a scanner to Tenable.io, see the [Tenable.io Vulnerability Management Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/LinkaSensor.htm).
		Key *string `json:"key,omitempty"`

		// The Unix timestamp when any of the scanner's tasks have provided its last update.
		LastConnect *string `json:"last_connect,omitempty"`

		// The Unix timestamp when the scanner was last modified.
		LastModificationDate *int `json:"last_modification_date,omitempty"`
		License              *struct {
			// The number of agents the scanner is licensed to use.
			Agents *int `json:"agents,omitempty"`
			Apps   *struct {
				Consec *struct {
					// The activation code you used to enable the license. This value is present for standard licenses only.
					ActivationCode *int `json:"activation_code,omitempty"`

					// The Unix timestamp when the license expires.
					ExpirationDate *int `json:"expiration_date,omitempty"`

					// The maximum memory (in GB) on the scanner allotted for the Tenable licensed application.
					MaxGb *int `json:"max_gb,omitempty"`

					// Indicates whether the product license is an evaluation license (`eval`) or standard license (`standard`).
					Mode *string `json:"mode,omitempty"`

					// Indicates that the scanner is licensed to perform Tenable.io Container Security scans.
					Type *string `json:"type,omitempty"`
				} `json:"consec,omitempty"`

				// The Tenable products licensed on the scanner.
				Type *string `json:"type,omitempty"`
				Was  *struct {
					// The activation code you used to enable the license. This value is present for standard licenses only.
					ActivationCode *int `json:"activation_code,omitempty"`

					// The Unix timestamp when the license expires.
					ExpirationDate *int `json:"expiration_date,omitempty"`

					// Indicates whether the product license is an evaluation license (`eval`) or standard license (`standard`).
					Mode *string `json:"mode,omitempty"`

					// Indicates that the scanner is licensed to perform Tenable.io Web Application Scanning scans.
					Type *string `json:"type,omitempty"`

					// The number of web assets which your license authorizes you to scan.
					WebAssets *int `json:"web_assets,omitempty"`
				} `json:"was,omitempty"`
			} `json:"apps,omitempty"`

			// The number of hosts the scanner is licensed to use.
			Ips *int `json:"ips,omitempty"`

			// The number of scanners the scanner is licensed to use.
			Scanners *int `json:"scanners,omitempty"`

			// The license type.
			Type *string `json:"type,omitempty"`
		} `json:"license,omitempty"`

		// Specifies whether you disabled (`0`) or enabled (`1`) the scanner. For more information, see the [PUT /scanners/{scanner_id}/link](ref:scanners-toggle-link-state) endpoint.
		Linked *int `json:"linked,omitempty"`

		// The current plugin set on the scanner.
		LoadedPluginSet *string `json:"loaded_plugin_set,omitempty"`

		// The user-defined name of the scanner.
		Name *string `json:"name,omitempty"`

		// The name of the network object associated with the scanner. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkName *string `json:"network_name,omitempty"`

		// The number of hosts that the scanner's analysis has discovered.
		NumHosts *int `json:"num_hosts,omitempty"`

		// The number of scans (tasks) the scanner is currently executing.
		NumScans *int `json:"num_scans,omitempty"`

		// The number of active sessions between the scanner and hosts.
		NumSessions *int `json:"num_sessions,omitempty"`

		// The number of active TCP sessions between the scanner and hosts.
		NumTcpSessions *int `json:"num_tcp_sessions,omitempty"`

		// The owner of the scanner.
		Owner *string `json:"owner,omitempty"`

		// The ID of the owner of the scanner.
		OwnerId *int `json:"owner_id,omitempty"`

		// The username of the owner of the scanner.
		OwnerName *string `json:"owner_name,omitempty"`

		// The UUID of the owner of the scanner.
		OwnerUuid *string `json:"owner_uuid,omitempty"`

		// The platform of the scanner.
		Platform *string `json:"platform,omitempty"`

		// Indicates whether the scanner is part of a scanner group ('true') or not ('false'). For more information about scanner groups, see the [Scanner Groups](ref:scanner-groups) endpoints.
		Pool *bool `json:"pool,omitempty"`

		// The registration code of the scanner.
		RegistrationCode *string `json:"registration_code,omitempty"`

		// The number of scans that the scanner is currently running.
		ScanCount *int `json:"scan_count,omitempty"`

		// Indicates whether anyone other than the scanner owner has explicit access to the scanner (`1`).
		Shared *bool `json:"shared,omitempty"`

		// Always set to `service`.
		Source *string `json:"source,omitempty"`

		// The status of the scanner (`on` or `off`).
		Status *string `json:"status,omitempty"`

		// Indicates if the scanner supports remote logging.
		SupportsRemoteLogs *bool `json:"supports_remote_logs,omitempty"`

		// Indicates if the scanner supports web application scanning.
		SupportsWebapp *bool `json:"supports_webapp,omitempty"`

		// Equivalent to the `last_modification_date` attribute.
		Timestamp *int `json:"timestamp,omitempty"`

		// The type of scanner (`local`, `managed`, `managed_pvs`, `pool`, `remote`, or `webapp`).
		Type *string `json:"type,omitempty"`

		// The backend build of Nessus that is running on the scanner.
		UiBuild *string `json:"ui_build,omitempty"`

		// The backend version of Nessus that is running on the scanner.
		UiVersion *string `json:"ui_version,omitempty"`

		// The permissions you (the current user) have been assigned for the scanner. See [Permissions](doc:permissions).
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the scanner.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScannersDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannersDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannersEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The UUID of the Tenable.io instance to which the scanner is linked.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// The Unix timestamp when you linked the scanner to the Tenable.io instance.
		Created *int `json:"created,omitempty"`

		// The default permissions value set for the scanner. (Possible values are: 16, 24, 32, 40, and 64)
		DefaultPermissions *int `json:"default_permissions,omitempty"`

		// The unique ID of the scanner.
		Id *int `json:"id,omitempty"`

		// The linking key, that is, the alpha-numeric sequence of characters you use to link a scanner to Tenable.io. For more information about linking a scanner to Tenable.io, see the [Tenable.io Vulnerability Management Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/LinkaSensor.htm).
		Key *string `json:"key,omitempty"`

		// The Unix timestamp when the scanner configuration was last modified.
		Modified *int `json:"modified,omitempty"`

		// The user-defined name of the scanner.
		Name *string `json:"name,omitempty"`

		// The name of the network object associated with the scanner. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkName *string `json:"network_name,omitempty"`

		// The UUID of the owner of the scanner.
		OwnerUuid *string `json:"owner_uuid,omitempty"`

		// Indicates whether anyone other than the scanner owner has explicit access to the scanner (`1`).
		Shared *bool `json:"shared,omitempty"`

		// The status of the scanner (`on` or `off`).
		Status *string `json:"status,omitempty"`

		// The permissions you (the current user) have been assigned for the scanner. See [Permissions](doc:permissions).
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the scanner.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScannersEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannersEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentGroupsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// The agents in the group. The agent records can be filtered, sorted, and paginated.
		Agents *[]string `json:"agents,omitempty"`

		// The creation date of the agent group in unixtime.
		CreationDate *int `json:"creation_date,omitempty"`

		// The unique ID of the agent group.
		Id *int `json:"id,omitempty"`

		// The last modification date for the agent group in unixtime.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The name of the agent group.
		Name *string `json:"name,omitempty"`

		// The username for the owner of the agent group.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the agent group.
		OwnerId *string `json:"owner_id,omitempty"`

		// The name for the owner of the agent group.
		OwnerName *string `json:"owner_name,omitempty"`

		// The UUID of the owner of the agent group.
		OwnerUuid *string `json:"owner_uuid,omitempty"`

		// The shared status of the agent group.
		Shared *bool `json:"shared,omitempty"`

		// The sharing permissions for the agent group.
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the agent group.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AgentGroupsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentGroupsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentGroupsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The agents in the group. The agent records can be filtered, sorted, and paginated.
		Agents *[]string `json:"agents,omitempty"`

		// The creation date of the agent group in unixtime.
		CreationDate *int `json:"creation_date,omitempty"`

		// The unique ID of the agent group.
		Id *int `json:"id,omitempty"`

		// The last modification date for the agent group in unixtime.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The name of the agent group.
		Name *string `json:"name,omitempty"`

		// The username for the owner of the agent group.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the agent group.
		OwnerId *string `json:"owner_id,omitempty"`

		// The name for the owner of the agent group.
		OwnerName *string `json:"owner_name,omitempty"`

		// The UUID of the owner of the agent group.
		OwnerUuid *string `json:"owner_uuid,omitempty"`

		// The shared status of the agent group.
		Shared *bool `json:"shared,omitempty"`

		// The sharing permissions for the agent group.
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the agent group.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AgentGroupsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentGroupsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentGroupListAgentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Agents *[]struct {
			// Build number for the agent.
			CoreBuild *string `json:"core_build,omitempty"`

			// Build version for the agent.
			CoreVersion *string `json:"core_version,omitempty"`

			// The agent software distribution.
			Distro *string `json:"distro,omitempty"`

			// Array of groups to which the agent belongs. Groups are returned in the form {"name": "group name", "id": "group id"}.
			Groups *[]struct {
				// The unique ID of the agent group to which the agent belongs.
				Id *int `json:"id,omitempty"`

				// The name of the agent group to which the agent belongs.
				Name *string `json:"name,omitempty"`
			} `json:"groups,omitempty"`

			// The unique ID of the agent.
			Id *int `json:"id,omitempty"`

			// The IP address of the agent.
			Ip *string `json:"ip,omitempty"`

			// The Unix timestamp when the agent last communicated with Tenable.io.
			LastConnect *int `json:"last_connect,omitempty"`

			// The Unix timestamp when the agent last scanned the asset.
			LastScanned *int `json:"last_scanned,omitempty"`

			// The Unix timestamp when the link from Tenable.io to the agent was established.
			LinkedOn *int `json:"linked_on,omitempty"`

			// The name of the agent.
			Name *string `json:"name,omitempty"`

			// The name of the network that the agent belongs to.
			NetworkName *string `json:"network_name,omitempty"`

			// The UUID of the network that the agent belongs to.
			NetworkUuid *string `json:"network_uuid,omitempty"`

			// The platform of the agent.
			Platform *string `json:"platform,omitempty"`

			// The currently loaded plugin set of the agent (null if the agent has no plugin set loaded).
			PluginFeedId *string `json:"plugin_feed_id,omitempty"`

			// "on", "off", or "init".  "on" means that the agent has connected recently, and is therefore likely ready to scan.  "off" means that the agent has not been seen recently and should be considered offline.  "init" means that the agent is online, but it is still processing plugin updates and is not ready to scan.
			Status *N200AgentsStatus `json:"status,omitempty"`

			// The UUID of the agent. Note: This value corresponds to the ID of the asset where the agent is installed. You can use this attribute to match agent data to asset data.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"agents,omitempty"`
		Pagination *struct {
			// The number of records requested (or the default value if omitted from the request).
			Limit *int32 `json:"limit,omitempty"`

			// The starting record you requested (or zero if omitted).
			Offset *int32 `json:"offset,omitempty"`

			// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
			Sort *[]struct {
				// The field on which Tenable.io sorted the results.
				Name *string `json:"name,omitempty"`

				// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
				Order *string `json:"order,omitempty"`
			} `json:"sort,omitempty"`

			// The total number of records matching your search criteria.
			Total *int32 `json:"total,omitempty"`
		} `json:"pagination,omitempty"`
	}
	JSON400 *struct {
		// A brief description of the cause of the error.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AgentGroupListAgentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentGroupListAgentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentGroupsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r AgentGroupsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentGroupsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentGroupsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The agents in the group. The agent records can be filtered, sorted, and paginated.
		Agents *[]string `json:"agents,omitempty"`

		// The creation date of the agent group in unixtime.
		CreationDate *int `json:"creation_date,omitempty"`

		// The unique ID of the agent group.
		Id *int `json:"id,omitempty"`

		// The last modification date for the agent group in unixtime.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The name of the agent group.
		Name *string `json:"name,omitempty"`

		// The username for the owner of the agent group.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the agent group.
		OwnerId *string `json:"owner_id,omitempty"`

		// The name for the owner of the agent group.
		OwnerName *string `json:"owner_name,omitempty"`

		// The UUID of the owner of the agent group.
		OwnerUuid *string `json:"owner_uuid,omitempty"`

		// The shared status of the agent group.
		Shared *bool `json:"shared,omitempty"`

		// The sharing permissions for the agent group.
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the agent group.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AgentGroupsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentGroupsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentGroupsConfigureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r AgentGroupsConfigureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentGroupsConfigureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentGroupsDeleteAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r AgentGroupsDeleteAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentGroupsDeleteAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentGroupsAddAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r AgentGroupsAddAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentGroupsAddAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Agents *[]struct {
			// Build number for the agent.
			CoreBuild *string `json:"core_build,omitempty"`

			// Build version for the agent.
			CoreVersion *string `json:"core_version,omitempty"`

			// The agent software distribution.
			Distro *string `json:"distro,omitempty"`

			// Array of groups to which the agent belongs. Groups are returned in the form {"name": "group name", "id": "group id"}.
			Groups *[]struct {
				// The unique ID of the agent group to which the agent belongs.
				Id *int `json:"id,omitempty"`

				// The name of the agent group to which the agent belongs.
				Name *string `json:"name,omitempty"`
			} `json:"groups,omitempty"`

			// The unique ID of the agent.
			Id *int `json:"id,omitempty"`

			// The IP address of the agent.
			Ip *string `json:"ip,omitempty"`

			// The Unix timestamp when the agent last communicated with Tenable.io.
			LastConnect *int `json:"last_connect,omitempty"`

			// The Unix timestamp when the agent last scanned the asset.
			LastScanned *int `json:"last_scanned,omitempty"`

			// The Unix timestamp when the link from Tenable.io to the agent was established.
			LinkedOn *int `json:"linked_on,omitempty"`

			// The name of the agent.
			Name *string `json:"name,omitempty"`

			// The name of the network that the agent belongs to.
			NetworkName *string `json:"network_name,omitempty"`

			// The UUID of the network that the agent belongs to.
			NetworkUuid *string `json:"network_uuid,omitempty"`

			// The platform of the agent.
			Platform *string `json:"platform,omitempty"`

			// The currently loaded plugin set of the agent (null if the agent has no plugin set loaded).
			PluginFeedId *string `json:"plugin_feed_id,omitempty"`

			// "on", "off", or "init".  "on" means that the agent has connected recently, and is therefore likely ready to scan.  "off" means that the agent has not been seen recently and should be considered offline.  "init" means that the agent is online, but it is still processing plugin updates and is not ready to scan.
			Status *N200AgentsStatus `json:"status,omitempty"`

			// The UUID of the agent. Note: This value corresponds to the ID of the asset where the agent is installed. You can use this attribute to match agent data to asset data.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"agents,omitempty"`
		Pagination *struct {
			// The number of records requested (or the default value if omitted from the request).
			Limit *int32 `json:"limit,omitempty"`

			// The starting record you requested (or zero if omitted).
			Offset *int32 `json:"offset,omitempty"`

			// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
			Sort *[]struct {
				// The field on which Tenable.io sorted the results.
				Name *string `json:"name,omitempty"`

				// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
				Order *string `json:"order,omitempty"`
			} `json:"sort,omitempty"`

			// The total number of records matching your search criteria.
			Total *int32 `json:"total,omitempty"`
		} `json:"pagination,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AgentsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentConfigDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AutoUnlink *struct {
			// If true, agent auto-unlink is enabled. Enabling auto-unlink causes it to take effect against all agents retroactively.
			Enabled *bool `json:"enabled,omitempty"`

			// The expiration time for agents, in days. If an agent has not communicated in the specified number of days, Tenable.io classifies the agent as expired and auto-unlinks the agent if auto_unlink.enabled is `true`. Valid values are 1-365.
			Expiration *int32 `json:"expiration,omitempty"`
		} `json:"auto_unlink,omitempty"`

		// If true, software updates are enabled for agents pursuant to any agent exclusions that are in effect. If false, software updates are disabled for all agents, even if no agent exclusions are in effect.
		SoftwareUpdate *bool `json:"software_update,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AgentConfigDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentConfigDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentConfigEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AutoUnlink *struct {
			// If true, agent auto-unlink is enabled. Enabling auto-unlink causes it to take effect against all agents retroactively.
			Enabled *bool `json:"enabled,omitempty"`

			// The expiration time for agents, in days. If an agent has not communicated in the specified number of days, Tenable.io classifies the agent as expired and auto-unlinks the agent if auto_unlink.enabled is `true`. Valid values are 1-365.
			Expiration *int32 `json:"expiration,omitempty"`
		} `json:"auto_unlink,omitempty"`

		// If true, software updates are enabled for agents pursuant to any agent exclusions that are in effect. If false, software updates are disabled for all agents, even if no agent exclusions are in effect.
		SoftwareUpdate *bool `json:"software_update,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AgentConfigEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentConfigEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentExclusionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// The creation date of the exclusion in unixtime.
		CreationDate *int `json:"creation_date,omitempty"`

		// The description of the exclusion.
		Description *string `json:"description,omitempty"`

		// The unique ID of the exclusion.
		Id *int `json:"id,omitempty"`

		// The last modification date for the exclusion in unixtime.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The name of the exclusion.
		Name     *string `json:"name,omitempty"`
		Schedule *struct {
			// If true, the exclusion is scheduled.
			Enabled *bool `json:"enabled,omitempty"`

			// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
			Endtime *string `json:"endtime,omitempty"`
			Rrules  struct {
				// The day of the month to repeat a MONTHLY freq rule on.
				Bymonthday *int `json:"bymonthday,omitempty"`

				// A comma separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
				Byweekday *string `json:"byweekday,omitempty"`

				// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
				Freq N200ScheduleRrulesFreq `json:"freq"`

				// The interval of the rule.
				Interval *int `json:"interval,omitempty"`
			} `json:"rrules"`

			// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
			Starttime string `json:"starttime"`

			// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
			Timezone string `json:"timezone"`
		} `json:"schedule,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AgentExclusionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentExclusionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentExclusionsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The creation date of the exclusion in unixtime.
		CreationDate *int `json:"creation_date,omitempty"`

		// The description of the exclusion.
		Description *string `json:"description,omitempty"`

		// The unique ID of the exclusion.
		Id *int `json:"id,omitempty"`

		// The last modification date for the exclusion in unixtime.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The name of the exclusion.
		Name     *string `json:"name,omitempty"`
		Schedule *struct {
			// If true, the exclusion is scheduled.
			Enabled *bool `json:"enabled,omitempty"`

			// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
			Endtime *string `json:"endtime,omitempty"`
			Rrules  struct {
				// The day of the month to repeat a MONTHLY freq rule on.
				Bymonthday *int `json:"bymonthday,omitempty"`

				// A comma separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
				Byweekday *string `json:"byweekday,omitempty"`

				// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
				Freq N200ScheduleRrulesFreq `json:"freq"`

				// The interval of the rule.
				Interval *int `json:"interval,omitempty"`
			} `json:"rrules"`

			// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
			Starttime string `json:"starttime"`

			// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
			Timezone string `json:"timezone"`
		} `json:"schedule,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AgentExclusionsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentExclusionsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentExclusionsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r AgentExclusionsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentExclusionsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentExclusionsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The creation date of the exclusion in unixtime.
		CreationDate *int `json:"creation_date,omitempty"`

		// The description of the exclusion.
		Description *string `json:"description,omitempty"`

		// The unique ID of the exclusion.
		Id *int `json:"id,omitempty"`

		// The last modification date for the exclusion in unixtime.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The name of the exclusion.
		Name     *string `json:"name,omitempty"`
		Schedule *struct {
			// If true, the exclusion is scheduled.
			Enabled *bool `json:"enabled,omitempty"`

			// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
			Endtime *string `json:"endtime,omitempty"`
			Rrules  struct {
				// The day of the month to repeat a MONTHLY freq rule on.
				Bymonthday *int `json:"bymonthday,omitempty"`

				// A comma separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
				Byweekday *string `json:"byweekday,omitempty"`

				// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
				Freq N200ScheduleRrulesFreq `json:"freq"`

				// The interval of the rule.
				Interval *int `json:"interval,omitempty"`
			} `json:"rrules"`

			// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
			Starttime string `json:"starttime"`

			// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
			Timezone string `json:"timezone"`
		} `json:"schedule,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AgentExclusionsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentExclusionsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentExclusionsEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r AgentExclusionsEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentExclusionsEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r AgentsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AgentsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Build number for the agent.
		CoreBuild *string `json:"core_build,omitempty"`

		// Build version for the agent.
		CoreVersion *string `json:"core_version,omitempty"`

		// The agent software distribution.
		Distro *string `json:"distro,omitempty"`

		// Array of groups to which the agent belongs. Groups are returned in the form {"name": "group name", "id": "group id"}.
		Groups *[]struct {
			// The unique ID of the agent group to which the agent belongs.
			Id *int `json:"id,omitempty"`

			// The name of the agent group to which the agent belongs.
			Name *string `json:"name,omitempty"`
		} `json:"groups,omitempty"`

		// The unique ID of the agent.
		Id *int `json:"id,omitempty"`

		// The IP address of the agent.
		Ip *string `json:"ip,omitempty"`

		// The Unix timestamp when the agent last communicated with Tenable.io.
		LastConnect *int `json:"last_connect,omitempty"`

		// The Unix timestamp when the agent last scanned the asset.
		LastScanned *int `json:"last_scanned,omitempty"`

		// The Unix timestamp when the link from Tenable.io to the agent was established.
		LinkedOn *int `json:"linked_on,omitempty"`

		// The name of the agent.
		Name *string `json:"name,omitempty"`

		// The name of the network that the agent belongs to.
		NetworkName *string `json:"network_name,omitempty"`

		// The UUID of the network that the agent belongs to.
		NetworkUuid *string `json:"network_uuid,omitempty"`

		// The platform of the agent.
		Platform *string `json:"platform,omitempty"`

		// The currently loaded plugin set of the agent (null if the agent has no plugin set loaded).
		PluginFeedId *string `json:"plugin_feed_id,omitempty"`

		// "on", "off", or "init".  "on" means that the agent has connected recently, and is therefore likely ready to scan.  "off" means that the agent has not been seen recently and should be considered offline.  "init" means that the agent is online, but it is still processing plugin updates and is not ready to scan.
		Status *N200Status `json:"status,omitempty"`

		// The UUID of the agent. Note: This value corresponds to the ID of the asset where the agent is installed. You can use this attribute to match agent data to asset data.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AgentsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AgentsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannersGetAwsTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Unique instance identifier from Amazon.
		InstanceId *string `json:"instance_id,omitempty"`

		// The user-defined name of the instance.
		Name *string `json:"name,omitempty"`

		// Private IP address of the AWS instance.
		PrivateIp *string `json:"private_ip,omitempty"`

		// Public IP address of the AWS instance.
		PublicIp *string `json:"public_ip,omitempty"`

		// The ID of the scanner.
		ScannerId *int `json:"scanner_id,omitempty"`

		// The state of the instance. Can be one of the following values: `running`, `stopped`, or `terminated`.
		State *string `json:"state,omitempty"`

		// The size of the instance. Example: `t2.small`, `t2.medium`, etc.
		Type *string `json:"type,omitempty"`

		// The availability zone for the instance. Example: `us-east-1a`, `us-east-1b`, etc.
		Zone *string `json:"zone,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScannersGetAwsTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannersGetAwsTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannersGetScannerKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The linking key, that is, the alpha-numeric sequence of characters you use to link a scanner to Tenable.io. For more information about linking a scanner to Tenable.io, see the [Tenable.io Vulnerability Management Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/LinkaSensor.htm).
		ScannerId *string `json:"scanner_id,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScannersGetScannerKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannersGetScannerKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannersToggleLinkStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScannersToggleLinkStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannersToggleLinkStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannersGetScansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The scan UUID.
		Id *string `json:"id,omitempty"`

		// The last time the scan was modified.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The name of the scan.
		Name *string `json:"name,omitempty"`

		// The ID of the network object associated with the scanner currently running the scan. The default network ID is `00000000-0000-0000-0000-000000000000`. To determine the ID of a custom network, use the [GET /networks](ref:networks-list) endpoint. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkId *string `json:"network_id,omitempty"`

		// Indicates whether the scan is running remotely ('true') or not ('false').
		Remote *bool `json:"remote,omitempty"`

		// The ID of the scan.
		ScanId *int `json:"scan_id,omitempty"`

		// The UUID of the scanner the scan belongs to.
		ScannerUuid *string `json:"scanner_uuid,omitempty"`

		// When the scan was started.
		StartTime *int `json:"start_time,omitempty"`

		// Scan status. Can be one of the following values: pending, processing, stopping, pausing, paused, resuming, or running.
		Status *string `json:"status,omitempty"`

		// The username of the owner of the scan.
		User *string `json:"user,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScannersGetScansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannersGetScansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannersControlScansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScannersControlScansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannersControlScansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Folders *[]struct {
			// Indicates whether or not the folder is a custom folder:
			//  - 1User-created folder. You can rename or delete this folder.
			//  - 0System-created folder. You cannot rename or delete this folder.
			Custom *int `json:"custom,omitempty"`

			// Indicates whether or not the folder is the default:
			//  - 1The folder is the default.
			//  - 0The folder is not the default.
			//
			// The main folder is the default folder. You cannot change the default folder.
			DefaultTag *int `json:"default_tag,omitempty"`

			// The unique ID of the folder.
			Id *int `json:"id,omitempty"`

			// The name of the folder. This value corresponds to the folder type as follows:
			//  - mainMy Scans
			//  - trashTrash
			// -customuser-defined string.
			Name *string `json:"name,omitempty"`

			// The type of the folder:
			// - mainTenable-provided folder. Contains all scans that you create but do not assign to a custom folder, as well as any scans shared with you by other users. If you do not specify a scan folder when creating a scan, Tenable.io stores scans in this folder by default. This folder corresponds to the **My Scans** folder in the Tenable.io user interface.
			//  - trashTenable-provided folder. Contains all scans that the current user has moved to the trash folder. Scans stored in the trash folder are automatically deleted after 30 days. This folder corresponds to the **Trash** folder in the Tenable.io user interface.
			//  - customUser-created folder. Contains scans as assigned by the current user. You can create custom folders to meet your organizational needs.
			Type *string `json:"type,omitempty"`

			// The number of scans in the folder that the current user has not yet viewed in the Tenable.io user interface.
			UnreadCount *int `json:"unread_count,omitempty"`
		} `json:"folders,omitempty"`
		Scans *[]struct {
			// If `true`, the scan has a schedule and can be launched.
			Control *bool `json:"control,omitempty"`

			// For newly-created scans, the date on which the scan configuration was originally created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was originally created. Instead, it represents the date on which the scan was first launched, in Unix time format.
			CreationDate *int32 `json:"creation_date,omitempty"`

			// Indicates whether the scan schedule is active (`true`) or inactive (`false`).
			Enabled *bool `json:"enabled,omitempty"`

			// The unique ID of the scan.
			Id *int32 `json:"id,omitempty"`

			// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
			LastModificationDate *int32 `json:"last_modification_date,omitempty"`

			// A value indicating whether the scan results were created before a change in storage method. If `true`, Tenable.io stores the results in the old storage method. If `false`, Tenable.io stores the results in the new storage method.
			Legacy *bool `json:"legacy,omitempty"`

			// The name of the scan.
			Name *string `json:"name,omitempty"`

			// The owner of the scan.
			Owner *string `json:"owner,omitempty"`

			// The requesting user's permissions for the scan.
			Permissions *int32 `json:"permissions,omitempty"`

			// The unique ID of the user-defined template (policy) on which the scan configuration is based.
			PolicyId *int `json:"policy_id,omitempty"`

			// A value indicating whether the user account associated with the request message has viewed the scan in the Tenable.io user interface. If `1`, the user account has viewed the scan results.
			Read *bool `json:"read,omitempty"`

			// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
			//
			// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
			Rrules *string `json:"rrules,omitempty"`

			// The UUID for a specific instance in the scan schedule.
			ScheduleUuid *string `json:"schedule_uuid,omitempty"`

			// If `true`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
			Shared *bool `json:"shared,omitempty"`

			// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` attribute.
			//
			// This attribute has the following format: `YYYYMMDDTHHMMSS`.
			Starttime *string `json:"starttime,omitempty"`

			// The status of the scan. For a list of possible values, see [Scan Status](doc:scan-status-tio).
			Status *string `json:"status,omitempty"`

			// The timezone of the scheduled start time for the scan.
			Timezone *string `json:"timezone,omitempty"`

			// The type of scan.
			Type *string `json:"type,omitempty"`

			// The sharing permissions for the scan.
			UserPermissions *int32 `json:"user_permissions,omitempty"`

			// The UUID of the scan.
			Uuid *string `json:"uuid,omitempty"`

			// The UUID of the Tenable-provided template used to create either the scan or the user-defined template (policy) on which the scan configuration is based.
			WizardUuid *string `json:"wizard_uuid,omitempty"`
		} `json:"scans,omitempty"`

		// The Unix timestamp when Tenable.io received the list request.
		Timestamp *int32 `json:"timestamp,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The unique ID of your Tenable.io instance.
		ContainerId *string `json:"container_id,omitempty"`

		// For newly-created scans, the date on which the scan configuration was originally created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was originally created. Instead, it represents the date on which the scan was first launched, in Unix time format.
		CreationDate *int32 `json:"creation_date,omitempty"`

		// Targets specified in the `alt_targets` parameter of the [POST /scans/{scan_id}/launch](/reference#scans-launch) request body used to run the scan.
		CustomTargets *string `json:"custom_targets,omitempty"`

		// The name of the dashboard file associated with the scan.
		DashboardFile *string `json:"dashboard_file,omitempty"`

		// The default permissions for the scan.
		DefaultPermissions *int32 `json:"default_permissions,omitempty"`

		// A brief user-defined description of the scan.
		Description *string `json:"description,omitempty"`

		// A comma-separated list of accounts that receive the email summary report.
		Emails *string `json:"emails,omitempty"`

		// A value indicating whether the scan schedule is active (`true`) or inactive (`false`).
		Enabled *bool `json:"enabled,omitempty"`

		// The unique ID of the scan.
		Id *int32 `json:"id,omitempty"`

		// A value indicating whether the scan results appear in dashboards.
		IncludeAggregate *bool `json:"include_aggregate,omitempty"`

		// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
		LastModificationDate *int32 `json:"last_modification_date,omitempty"`

		// The user-defined scan name.
		Name *string `json:"name,omitempty"`

		// A list of filters that Tenable.io applies to determine whether it sends a notification email on scan completion to the recipients specified in the `emails` attribute.
		NotificationFilters *[]struct {
			// The attribute name. For example, use the `risk_factor` attribute if you want to filter on vulnerability severity.
			Filter *string `json:"filter,omitempty"`

			// The operator Tenable.io applies to the filter value, for example, `eq`.
			Quality *string `json:"quality,omitempty"`

			// The attribute value Tenable.io filters on. For example, when filtering on severity, this attribute might specify `Critical`.
			Value *string `json:"value,omitempty"`
		} `json:"notification_filters,omitempty"`

		// The owner of the scan.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the scan.
		OwnerId *int `json:"owner_id,omitempty"`

		// The unique ID of the scan owner.
		OwnerUuid *string `json:"owner_uuid,omitempty"`

		// The unique ID of the policy associated with the scan.
		PolicyId *int `json:"policy_id,omitempty"`

		// If `1`, your vulnerability remediation actions on scan targets have been successful.
		Remediation *int `json:"remediation,omitempty"`

		// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
		//
		// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
		Rrules *string `json:"rrules,omitempty"`

		// The time frame, in minutes, during which agents must transmit scan results to Tenable.io in order to be included in dashboards and reports. If your request omits this parameter, the default value is 180 minutes. For non-agent scans, this attribute is null.
		ScanTimeWindow *string `json:"scan_time_window,omitempty"`

		// The UUID of the scanner that the scan is configured to use, if the scan is *not* configured for [scan routing](doc:manage-scan-routing-tio).
		ScannerUuid *string `json:"scanner_uuid,omitempty"`

		// If `1`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
		Shared *bool `json:"shared,omitempty"`

		// A comma-separated list of mobile phone numbers that receive notification of the scan.
		Sms *string `json:"sms,omitempty"`

		// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` parameter.
		//
		// This attribute has the following format: `YYYYMMDDTHHMMSS`.
		Starttime *string `json:"starttime,omitempty"`

		// The list of asset tag identifiers the scan uses to determine which assets it evaluates. For more information about tag-based scans, see [Manage Tag-Based Scans](doc:manage-tag-based-scans-tio).
		TagTargets *[]string `json:"tag_targets,omitempty"`

		// The type of tag.
		TagType *string `json:"tag_type,omitempty"`

		// The UUID of the network object that Tenable.io associates with the scan results if the scan is configured for [scan routing](doc:manage-scan-routing-tio).
		TargetNetworkUuid *string `json:"target_network_uuid,omitempty"`

		// The timezone of the scheduled start time for the scan.
		Timezone *string `json:"timezone,omitempty"`

		// The type of scan.
		Type *string `json:"type,omitempty"`

		// The sharing permissions for the scan.
		UserPermissions *int32 `json:"user_permissions,omitempty"`

		// The UUID of the schedule for the scan.
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON500 *struct {
		// The HTTP status text.
		Error *int `json:"error,omitempty"`

		// A brief message describing the error Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP status code.
		StatusCode *string `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoScansCheckAutoTargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A list of UUIDs for scanner groups where configured scan routes matched at least one of the specified targets.
		MatchedResourceUuids *[]string `json:"matched_resource_uuids,omitempty"`

		// The list of targets that did not match a route in any scanner group.
		MissedTargets *[]string `json:"missed_targets,omitempty"`

		// The count of matched resource UUIDs, before being truncated by the optional `matched_resource_limit` parameter.
		TotalMatchedResourceUuids *int `json:"total_matched_resource_uuids,omitempty"`

		// The total count of missed targets, before being truncated by the optional `limit` parameter.
		TotalMissedTargets *int `json:"total_missed_targets,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoScansCheckAutoTargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoScansCheckAutoTargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// If `true`, the scan has a schedule and can be launched.
		Control *bool `json:"control,omitempty"`

		// The creation date for the scan in Unix time.
		CreationDate *int `json:"creation_date,omitempty"`

		// If `true`, the schedule for the scan is enabled.
		Enabled *bool `json:"enabled,omitempty"`

		// The unique ID of the scan.
		Id *int `json:"id,omitempty"`

		// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
		LastModificationDate *int32 `json:"last_modification_date,omitempty"`

		// The name of the scan.
		Name *string `json:"name,omitempty"`

		// The owner of the scan.
		Owner *string `json:"owner,omitempty"`

		// If `true`, the scan has been read.
		Read *bool `json:"read,omitempty"`

		// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
		//
		// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
		Rrules *string `json:"rrules,omitempty"`

		// The UUID for a specific instance in the scan schedule.
		ScheduleUuid *string `json:"schedule_uuid,omitempty"`

		// If `1`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
		Shared *bool `json:"shared,omitempty"`

		// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` attribute.
		//
		// This attribute has the following format: `YYYYMMDDTHHMMSS`.
		Starttime *string `json:"starttime,omitempty"`

		// The status of the scan. For a list of possible values, see [Scan Status](doc:scan-status-tio).
		Status *string `json:"status,omitempty"`

		// The timezone of the scheduled start time for the scan.
		Timezone *string `json:"timezone,omitempty"`

		// The type of scan (local, remote, or agent).
		Type *string `json:"type,omitempty"`

		// The sharing permissions for the scan.
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the scan.
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON500 *struct {
		// The HTTP status text.
		Error *int `json:"error,omitempty"`

		// A brief message describing the error Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP status code.
		StatusCode *string `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoScansRemediationListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Pagination *struct {
			// The number of records requested (or the default value if omitted from the request).
			Limit *int32 `json:"limit,omitempty"`

			// The starting record you requested (or zero if omitted).
			Offset *int32 `json:"offset,omitempty"`

			// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
			Sort *[]struct {
				// The field on which Tenable.io sorted the results.
				Name *string `json:"name,omitempty"`

				// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
				Order *string `json:"order,omitempty"`
			} `json:"sort,omitempty"`

			// The total number of records matching your search criteria.
			Total *int32 `json:"total,omitempty"`
		} `json:"pagination,omitempty"`
		Scans *[]struct {
			// If `true`, the scan has a schedule and can be launched.
			Control *bool `json:"control,omitempty"`

			// For newly-created scans, the date on which the scan configuration was originally created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was originally created. Instead, it represents the date on which the scan was first launched, in Unix time format.
			CreationDate *int32 `json:"creation_date,omitempty"`

			// Indicates whether the scan schedule is active (`true`) or inactive (`false`).
			Enabled *bool `json:"enabled,omitempty"`

			// The unique ID of the scan.
			Id *int32 `json:"id,omitempty"`

			// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
			LastModificationDate *int32 `json:"last_modification_date,omitempty"`

			// The name of the scan.
			Name *string `json:"name,omitempty"`

			// The owner of the scan.
			Owner *string `json:"owner,omitempty"`

			// The requesting user's permissions for the scan.
			Permissions *int32 `json:"permissions,omitempty"`

			// The unique ID of the user-defined template (policy) on which the scan configuration is based.
			PolicyId *int `json:"policy_id,omitempty"`

			// A value indicating whether the user account associated with the request message has viewed the scan in the Tenable.io user interface. If `1`, the user account has viewed the scan results.
			Read *bool `json:"read,omitempty"`

			// If `1`, your vulnerability remediation actions on scan targets have been successful.
			Remediation *int `json:"remediation,omitempty"`

			// The Unix timestamp when the remediation scan run was created.
			ScanCreationDate *int32 `json:"scan_creation_date,omitempty"`

			// The UUID for a specific instance in the scan schedule.
			ScheduleUuid *string `json:"schedule_uuid,omitempty"`

			// If `true`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
			Shared *bool `json:"shared,omitempty"`

			// The status of the scan. For a list of possible values, see [Scan Status](doc:scan-status-tio).
			Status *string `json:"status,omitempty"`

			// The UUID of the template.
			TemplateUuid *string `json:"template_uuid,omitempty"`

			// The type of scan.
			Type *string `json:"type,omitempty"`

			// The sharing permissions for the scan.
			UserPermissions *int32 `json:"user_permissions,omitempty"`

			// The UUID of the remediation scan.
			Uuid *string `json:"uuid,omitempty"`

			// The UUID of the Tenable-provided template used to create either the scan or the user-defined template (policy) on which the scan configuration is based.
			WizardUuid *string `json:"wizard_uuid,omitempty"`
		} `json:"scans,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoScansRemediationListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoScansRemediationListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoScansRemediationCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The unique ID of your Tenable.io instance.
		ContainerId *string `json:"container_id,omitempty"`

		// For newly-created scans, the date on which the scan configuration was originally created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was originally created. Instead, it represents the date on which the scan was first launched, in Unix time format.
		CreationDate *int32 `json:"creation_date,omitempty"`

		// Targets specified in the `alt_targets` parameter of the [POST /scans/{scan_id}/launch](/reference#scans-launch) request body used to run the scan.
		CustomTargets *string `json:"custom_targets,omitempty"`

		// The name of the dashboard file associated with the scan.
		DashboardFile *string `json:"dashboard_file,omitempty"`

		// The default permissions for the scan.
		DefaultPermissions *int32 `json:"default_permissions,omitempty"`

		// A brief user-defined description of the scan.
		Description *string `json:"description,omitempty"`

		// A comma-separated list of accounts that receive the email summary report.
		Emails *string `json:"emails,omitempty"`

		// A value indicating whether the scan schedule is active (`true`) or inactive (`false`).
		Enabled *bool `json:"enabled,omitempty"`

		// The unique ID of the scan.
		Id *int32 `json:"id,omitempty"`

		// A value indicating whether the scan results appear in dashboards.
		IncludeAggregate *bool `json:"include_aggregate,omitempty"`

		// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
		LastModificationDate *int32 `json:"last_modification_date,omitempty"`

		// The user-defined scan name.
		Name *string `json:"name,omitempty"`

		// A list of filters that Tenable.io applies to determine whether it sends a notification email on scan completion to the recipients specified in the `emails` attribute.
		NotificationFilters *[]struct {
			// The attribute name. For example, use the `risk_factor` attribute if you want to filter on vulnerability severity.
			Filter *string `json:"filter,omitempty"`

			// The operator Tenable.io applies to the filter value, for example, `eq`.
			Quality *string `json:"quality,omitempty"`

			// The attribute value Tenable.io filters on. For example, when filtering on severity, this attribute might specify `Critical`.
			Value *string `json:"value,omitempty"`
		} `json:"notification_filters,omitempty"`

		// The owner of the scan.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the scan.
		OwnerId *int `json:"owner_id,omitempty"`

		// The unique ID of the scan owner.
		OwnerUuid *string `json:"owner_uuid,omitempty"`

		// The unique ID of the policy associated with the scan.
		PolicyId *int `json:"policy_id,omitempty"`

		// If `1`, your vulnerability remediation actions on scan targets have been successful.
		Remediation *int `json:"remediation,omitempty"`

		// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
		//
		// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
		Rrules *string `json:"rrules,omitempty"`

		// The time frame, in minutes, during which agents must transmit scan results to Tenable.io in order to be included in dashboards and reports. If your request omits this parameter, the default value is 180 minutes. For non-agent scans, this attribute is null.
		ScanTimeWindow *string `json:"scan_time_window,omitempty"`

		// The UUID of the scanner that the scan is configured to use, if the scan is *not* configured for [scan routing](doc:manage-scan-routing-tio).
		ScannerUuid *string `json:"scanner_uuid,omitempty"`

		// If `1`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
		Shared *bool `json:"shared,omitempty"`

		// A comma-separated list of mobile phone numbers that receive notification of the scan.
		Sms *string `json:"sms,omitempty"`

		// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` parameter.
		//
		// This attribute has the following format: `YYYYMMDDTHHMMSS`.
		Starttime *string `json:"starttime,omitempty"`

		// The list of asset tag identifiers the scan uses to determine which assets it evaluates. For more information about tag-based scans, see [Manage Tag-Based Scans](doc:manage-tag-based-scans-tio).
		TagTargets *[]string `json:"tag_targets,omitempty"`

		// The type of tag.
		TagType *string `json:"tag_type,omitempty"`

		// The UUID of the network object that Tenable.io associates with the scan results if the scan is configured for [scan routing](doc:manage-scan-routing-tio).
		TargetNetworkUuid *string `json:"target_network_uuid,omitempty"`

		// The timezone of the scheduled start time for the scan.
		Timezone *string `json:"timezone,omitempty"`

		// The type of scan.
		Type *string `json:"type,omitempty"`

		// The sharing permissions for the scan.
		UserPermissions *int32 `json:"user_permissions,omitempty"`

		// The UUID of the schedule for the scan.
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON500 *struct {
		// The HTTP status text.
		Error *int `json:"error,omitempty"`

		// A brief message describing the error Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP status code.
		StatusCode *string `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoScansRemediationCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoScansRemediationCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansTimezonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// The readable name of the timezone.
		Name *string `json:"name,omitempty"`

		// The system value for the timezone.
		Value *string `json:"value,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansTimezonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansTimezonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON500      *struct {
		// The HTTP status text.
		Error *int `json:"error,omitempty"`

		// A brief message describing the error Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP status code.
		StatusCode *string `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A list of the hosts targeted by the scan for the specified run. If the scan results are older than 35 days (that is, if the `info.archived` attribute for the scan is `true`), this array does not appear in the response message.
		Comphosts *[]struct {
			// The percentage of critical findings on the host.
			Critical *int `json:"critical,omitempty"`

			// The percentage of high findings on the host.
			High *int `json:"high,omitempty"`

			// The unique ID of the host.
			HostId *int `json:"host_id,omitempty"`

			// The index for the host.
			HostIndex *int `json:"host_index,omitempty"`

			// The name of the host.
			Hostname *string `json:"hostname,omitempty"`

			// The percentage of info findings on the host.
			Info *int `json:"info,omitempty"`

			// The percentage of low findings on the host.
			Low *int `json:"low,omitempty"`

			// The percentage of medium findings on the host.
			Medium *int `json:"medium,omitempty"`

			// The number of checks considered on the host.
			Numchecksconsidered *int `json:"numchecksconsidered,omitempty"`

			// The scan progress of the host.
			Progress *string `json:"progress,omitempty"`

			// The current scan progress for the host.
			Scanprogresscurrent *int `json:"scanprogresscurrent,omitempty"`

			// The total scan progress for the host.
			Scanprogresstotal *int `json:"scanprogresstotal,omitempty"`

			// The overall score for the host.
			Score         *int                    `json:"score,omitempty"`
			Severitycount *map[string]interface{} `json:"severitycount,omitempty"`

			// The total number of checks considered on the host.
			Totalchecksconsidered *int `json:"totalchecksconsidered,omitempty"`
		} `json:"comphosts,omitempty"`

		// A list of compliance checks performed during the run of the scan. If the scan results are older than 35 days (that is, if the `info.archived` attribute for the scan is `true`), this array does not appear in the response message.
		Compliance *[]struct {
			// The number of vulnerabilities found.
			Count *int `json:"count,omitempty"`

			// The parent family of the vulnerability plugin.
			PluginFamily *string `json:"plugin_family,omitempty"`

			// The unique ID of the vulnerability plugin.
			PluginId *int `json:"plugin_id,omitempty"`

			// The name of the vulnerability plugin.
			PluginName *string `json:"plugin_name,omitempty"`

			// The severity rating of the plugin.
			Severity *int `json:"severity,omitempty"`

			// The severity index order of the plugin.
			SeverityIndex *int `json:"severity_index,omitempty"`

			// The index of the vulnerability plugin.
			VulnIndex *int `json:"vuln_index,omitempty"`
		} `json:"compliance,omitempty"`

		// A list of filters. If the scan results are older than 35 days (that is, if the `info.archived` attribute for the scan is `true`), this array does not appear in the response message.
		Filters *[]struct {
			Control *struct {
				// A list of options if the input is a dropdown.
				Options *[]string `json:"options,omitempty"`

				// The placeholder for the input.
				ReadableRegest *string `json:"readable_regest,omitempty"`

				// A regex for checking the value of the input.
				Regex *string `json:"regex,omitempty"`

				// The input type (entry or dropdown).
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// The short name of the filter.
			Name *string `json:"name,omitempty"`

			// The comparison options for the filter.
			Operators *[]string `json:"operators,omitempty"`

			// The long name of the filter.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filters,omitempty"`

		// A list of details about each time the scan has run.
		History *[]struct {
			// If `true`, Tenable.io did not not launched with a target list. This parameter is `true` for agent scans.
			AltTargetsUsed *bool `json:"alt_targets_used,omitempty"`

			// The creation date for the historical data in Unix time.
			CreationDate *int `json:"creation_date,omitempty"`

			// The unique ID of the historical data.
			HistoryId *int `json:"history_id,omitempty"`

			// Indicates whether the scan results are older than 35 days (`true`). If this parameter is `true`, Tenable.io returns limited data for the scan run. For complete scan results that are older than 35 days, use the [POST /scans/{scan_id}/export](ref:scans-export-request) endpoint instead.
			IsArchived *bool `json:"is_archived,omitempty"`

			// The last modification date for the historical data in Unix time.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The unique ID of the owner of the scan.
			OwnerId *int `json:"owner_id,omitempty"`

			// If `true`, Tenable.io launched the scan automatically from a schedule.
			Scheduler *int `json:"scheduler,omitempty"`

			// The terminal status of the scan run. For a list of possible values, see [Scan Status](doc:scan-status-tio).
			Status *string `json:"status,omitempty"`

			// The type of scan: `local` (a credentialed scan performed over the network), `remote` (an uncredentialed scan performed over the network, `agent` (a scan on a local host that a Nessus agent performs directly), or `null` (the scan has never been launched, or the scan is imported).
			Type *string `json:"type,omitempty"`

			// The UUID of the historical data.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"history,omitempty"`

		// A list of the hosts targeted by the scan for the specified run. If the scan results are older than 35 days (that is, if the `info.archived` attribute for the scan is `true`), this array does not appear in the response message.
		Hosts *[]struct {
			// The percentage of critical findings on the host.
			Critical *int `json:"critical,omitempty"`

			// The percentage of high findings on the host.
			High *int `json:"high,omitempty"`

			// The unique ID of the host.
			HostId *int `json:"host_id,omitempty"`

			// The index for the host.
			HostIndex *int `json:"host_index,omitempty"`

			// The name of the host.
			Hostname *string `json:"hostname,omitempty"`

			// The percentage of info findings on the host.
			Info *int `json:"info,omitempty"`

			// The percentage of low findings on the host.
			Low *int `json:"low,omitempty"`

			// The percentage of medium findings on the host.
			Medium *int `json:"medium,omitempty"`

			// The number of checks considered on the host.
			Numchecksconsidered *int `json:"numchecksconsidered,omitempty"`

			// The scan progress of the host.
			Progress *string `json:"progress,omitempty"`

			// The current scan progress for the host.
			Scanprogresscurrent *int `json:"scanprogresscurrent,omitempty"`

			// The total scan progress for the host.
			Scanprogresstotal *int `json:"scanprogresstotal,omitempty"`

			// The overall score for the host.
			Score         *int                    `json:"score,omitempty"`
			Severitycount *map[string]interface{} `json:"severitycount,omitempty"`

			// The total number of checks considered on the host.
			Totalchecksconsidered *int `json:"totalchecksconsidered,omitempty"`
		} `json:"hosts,omitempty"`
		Info *struct {
			// An array of objects that control sharing permissions for the scan.
			Acls *[]struct {
				// The name of the user or group granted the specified permissions, as it appears in the Tenable.io user interface.
				DisplayName *string `json:"display_name,omitempty"`

				// A number representing the order in which the user or user groups display in the Permissions tab in the Tenable.io user interface.
				Id *int `json:"id,omitempty"`

				// The name of the user or group granted the specified permissions.
				Name *string `json:"name,omitempty"`

				// A value that indicates whether the user or user group specified in the object owns the scan. Possible values include: `null` (system-owned permissions), `0` (the user is not the owner of the scan), `1` (the user is the owner of the scan).
				Owner *int `json:"owner,omitempty"`

				// The scan permission. For more information, see [Permissions](doc:permissions).
				Permissions *int `json:"permissions,omitempty"`

				// The type of scan permissions: `default` (default permissions for the scan), `user` (permissions for an individual user), or `group` (permissions for a user group).
				Type *string `json:"type,omitempty"`
			} `json:"acls,omitempty"`

			// If `true`, Tenable.io did not not launched with a target list. This parameter is `true` for agent scans.
			AltTargetsUsed *bool `json:"alt_targets_used,omitempty"`

			// If `true`, the scan has a schedule and can be launched.
			Control *bool `json:"control,omitempty"`

			// If `true`, the requesting user can edit this scan configuration.
			EditAllowed *bool `json:"edit_allowed,omitempty"`

			// The unique ID of the destination folder for the scan.
			FolderId *int32 `json:"folder_id,omitempty"`

			// Indicates whether the scan is configured to create an audit trail.
			Hasaudittrail *bool `json:"hasaudittrail,omitempty"`

			// Indicates whether a scan has a Knowledge Base (KB) associated with it. A KB is an ASCII text file containing a log of information relevant to the scan performed and results found.
			Haskb *bool `json:"haskb,omitempty"`

			// The total number of assets scanned for vulnerabilities.
			Hostcount *int32 `json:"hostcount,omitempty"`

			// Indicates whether the scan results are older than 35 days (`true`). If this attribute is `true`, the response message for this endpoint excludes the `hosts`, `vulnerabilities`, `comphosts`, `compliance`, and `filters` objects. For complete scan results older than 35 days, use the [POST /scans/{scan_id}/export](ref:scans-export-request) endpoint instead.
			IsArchived *bool `json:"is_archived,omitempty"`

			// The name of the scan.
			Name *string `json:"name,omitempty"`

			// Indicates whether the scan based on this policy can specify targets.
			NoTarget *bool `json:"no_target,omitempty"`

			// The unique ID of the scan result object.
			ObjectId *int32 `json:"object_id,omitempty"`

			// The owner of the scan.
			Owner *string `json:"owner,omitempty"`

			// If `true`, you can submit the results of the scan for PCI ASV review. For more information, see [PCI ASV](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/PCI_ASV/Welcome.htm) in the Tenable.io Vulnerability Management User Guide.
			PciCanUpload *bool `json:"pci-can-upload,omitempty"`

			// The name of the scan template associated with the scan.
			Policy *string `json:"policy,omitempty"`

			// The Unix timestamp when the scan run finished.
			ScanEnd *int `json:"scan_end,omitempty"`

			// The Unix timestamp when the scan run started.
			ScanStart *int32 `json:"scan_start,omitempty"`

			// The type of scan: `ps` (a scan performed over the network by a cloud scanner), `remote` (a  scan performed over the network by a local scanner), `agent` (a scan on a local host that a Nessus agent performs directly), or `null` (the scan has never been launched, or the scan is imported).
			ScanType *string `json:"scan_type,omitempty"`

			// The scan's end time, if the scan is imported.
			ScannerEnd *int `json:"scanner_end,omitempty"`

			// The name of the scanner configured to run the scan.
			ScannerName *string `json:"scanner_name,omitempty"`

			// The scan's start time, if the scan is imported.
			ScannerStart *int `json:"scanner_start,omitempty"`

			// The UUID for a specific instance in the scan schedule.
			ScheduleUuid *string `json:"schedule_uuid,omitempty"`

			// If `true`, the scan is shared with users other than the owner. The level of sharing is specified in the `acls` attribute of the scan details.
			Shared *bool `json:"shared,omitempty"`

			// The status of the scan. For a list of possible values, see [Scan Status](doc:scan-status-tio).
			Status *string `json:"status,omitempty"`

			// The list of asset tag identifiers the scan uses to determine which assets it evaluates. For more information about tag-based scans, see [Manage Tag-Based Scans](doc:manage-tag-based-scans-tio).
			TagTargets *[]string `json:"tag_targets,omitempty"`

			// A comma-delimited list of IPv4 addresses that are configured as targets for the scan.
			Targets *string `json:"targets,omitempty"`

			// The Unix timestamp when the scan run finished.
			Timestamp *int `json:"timestamp,omitempty"`

			// The sharing permissions for the scan.
			UserPermissions *int32 `json:"user_permissions,omitempty"`

			// The UUID of the scan.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"info,omitempty"`
		Notes *[]struct {
			// The specific message of the note.
			Message *string `json:"message,omitempty"`

			// The severity of the note.
			Severity *int `json:"severity,omitempty"`

			// The title of the note.
			Title *string `json:"title,omitempty"`
		} `json:"notes,omitempty"`
		Remediations *map[string]interface{} `json:"remediations,omitempty"`

		// A list of vulnerabilities that the scan identified on the target hosts. If the scan results are older than 35 days (that is, if the `info.archived` attribute for the scan is `true`), this array does not appear in the response message.
		Vulnerabilities *[]struct {
			// The number of vulnerabilities found.
			Count *int `json:"count,omitempty"`

			// The parent family of the vulnerability plugin.
			PluginFamily *string `json:"plugin_family,omitempty"`

			// The unique ID of the vulnerability plugin.
			PluginId *int `json:"plugin_id,omitempty"`

			// The name of the vulnerability plugin.
			PluginName *string `json:"plugin_name,omitempty"`

			// The severity rating of the plugin.
			Severity *int `json:"severity,omitempty"`

			// The severity index order of the plugin.
			SeverityIndex *int `json:"severity_index,omitempty"`

			// The index of the vulnerability plugin.
			VulnIndex *int `json:"vuln_index,omitempty"`
		} `json:"vulnerabilities,omitempty"`
	}
	JSON404 *struct {
		// A brief description of the cause of the error.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansConfigureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The unique ID of your Tenable.io instance.
		ContainerId *string `json:"container_id,omitempty"`

		// For newly-created scans, the date on which the scan configuration was originally created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was originally created. Instead, it represents the date on which the scan was first launched, in Unix time format.
		CreationDate *int32 `json:"creation_date,omitempty"`

		// Targets specified in the `alt_targets` parameter of the [POST /scans/{scan_id}/launch](/reference#scans-launch) request body used to run the scan.
		CustomTargets *string `json:"custom_targets,omitempty"`

		// The name of the dashboard file associated with the scan.
		DashboardFile *string `json:"dashboard_file,omitempty"`

		// The default permissions for the scan.
		DefaultPermissions *int32 `json:"default_permissions,omitempty"`

		// A brief user-defined description of the scan.
		Description *string `json:"description,omitempty"`

		// A comma-separated list of accounts that receive the email summary report.
		Emails *string `json:"emails,omitempty"`

		// A value indicating whether the scan schedule is active (`true`) or inactive (`false`).
		Enabled *bool `json:"enabled,omitempty"`

		// The unique ID of the scan.
		Id *int32 `json:"id,omitempty"`

		// A value indicating whether the scan results appear in dashboards.
		IncludeAggregate *bool `json:"include_aggregate,omitempty"`

		// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
		LastModificationDate *int32 `json:"last_modification_date,omitempty"`

		// The user-defined scan name.
		Name *string `json:"name,omitempty"`

		// A list of filters that Tenable.io applies to determine whether it sends a notification email on scan completion to the recipients specified in the `emails` attribute.
		NotificationFilters *[]struct {
			// The attribute name. For example, use the `risk_factor` attribute if you want to filter on vulnerability severity.
			Filter *string `json:"filter,omitempty"`

			// The operator Tenable.io applies to the filter value, for example, `eq`.
			Quality *string `json:"quality,omitempty"`

			// The attribute value Tenable.io filters on. For example, when filtering on severity, this attribute might specify `Critical`.
			Value *string `json:"value,omitempty"`
		} `json:"notification_filters,omitempty"`

		// The owner of the scan.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the scan.
		OwnerId *int `json:"owner_id,omitempty"`

		// The unique ID of the scan owner.
		OwnerUuid *string `json:"owner_uuid,omitempty"`

		// The unique ID of the policy associated with the scan.
		PolicyId *int `json:"policy_id,omitempty"`

		// If `1`, your vulnerability remediation actions on scan targets have been successful.
		Remediation *int `json:"remediation,omitempty"`

		// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
		//
		// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
		Rrules *string `json:"rrules,omitempty"`

		// The time frame, in minutes, during which agents must transmit scan results to Tenable.io in order to be included in dashboards and reports. If your request omits this parameter, the default value is 180 minutes. For non-agent scans, this attribute is null.
		ScanTimeWindow *string `json:"scan_time_window,omitempty"`

		// The UUID of the scanner that the scan is configured to use, if the scan is *not* configured for [scan routing](doc:manage-scan-routing-tio).
		ScannerUuid *string `json:"scanner_uuid,omitempty"`

		// If `1`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
		Shared *bool `json:"shared,omitempty"`

		// A comma-separated list of mobile phone numbers that receive notification of the scan.
		Sms *string `json:"sms,omitempty"`

		// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` parameter.
		//
		// This attribute has the following format: `YYYYMMDDTHHMMSS`.
		Starttime *string `json:"starttime,omitempty"`

		// The list of asset tag identifiers the scan uses to determine which assets it evaluates. For more information about tag-based scans, see [Manage Tag-Based Scans](doc:manage-tag-based-scans-tio).
		TagTargets *[]string `json:"tag_targets,omitempty"`

		// The type of tag.
		TagType *string `json:"tag_type,omitempty"`

		// The UUID of the network object that Tenable.io associates with the scan results if the scan is configured for [scan routing](doc:manage-scan-routing-tio).
		TargetNetworkUuid *string `json:"target_network_uuid,omitempty"`

		// The timezone of the scheduled start time for the scan.
		Timezone *string `json:"timezone,omitempty"`

		// The type of scan.
		Type *string `json:"type,omitempty"`

		// The sharing permissions for the scan.
		UserPermissions *int32 `json:"user_permissions,omitempty"`

		// The UUID of the schedule for the scan.
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON500 *struct {
		// The HTTP status text.
		Error *int `json:"error,omitempty"`

		// A brief message describing the error Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP status code.
		StatusCode *string `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansConfigureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansConfigureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ScansAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansCopyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// If `true`, the scan has a schedule and can be launched.
		Control *bool `json:"control,omitempty"`

		// The creation date for the scan in Unix time.
		CreationDate *int `json:"creation_date,omitempty"`

		// If `true`, the schedule for the scan is enabled.
		Enabled *bool `json:"enabled,omitempty"`

		// The unique ID of the scan.
		Id *int `json:"id,omitempty"`

		// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
		LastModificationDate *int32 `json:"last_modification_date,omitempty"`

		// The name of the scan.
		Name *string `json:"name,omitempty"`

		// The owner of the scan.
		Owner *string `json:"owner,omitempty"`

		// If `true`, the scan has been read.
		Read *bool `json:"read,omitempty"`

		// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
		//
		// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
		Rrules *string `json:"rrules,omitempty"`

		// The UUID for a specific instance in the scan schedule.
		ScheduleUuid *string `json:"schedule_uuid,omitempty"`

		// If `1`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
		Shared *bool `json:"shared,omitempty"`

		// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` attribute.
		//
		// This attribute has the following format: `YYYYMMDDTHHMMSS`.
		Starttime *string `json:"starttime,omitempty"`

		// The status of the scan. For a list of possible values, see [Scan Status](doc:scan-status-tio).
		Status *string `json:"status,omitempty"`

		// The timezone of the scheduled start time for the scan.
		Timezone *string `json:"timezone,omitempty"`

		// The type of scan (local, remote, or agent).
		Type *string `json:"type,omitempty"`

		// The sharing permissions for the scan.
		UserPermissions *int `json:"user_permissions,omitempty"`

		// The UUID of the scan.
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON500 *struct {
		// The HTTP status text.
		Error *int `json:"error,omitempty"`

		// A brief message describing the error Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP status code.
		StatusCode *string `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansCopyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansCopyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoScansCredentialsConvertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The UUID of the new managed credentials.
		Uuid *string `json:"uuid,omitempty"`
	}
	JSON401 *struct {
		// The HTTP status text.
		Error *int `json:"error,omitempty"`

		// A brief message describing the error Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP status code.
		StatusCode *string `json:"statusCode,omitempty"`
	}
	JSON404 *struct {
		// A message describing the error condition Tenable.io encountered.
		Error *string `json:"error,omitempty"`
	}
	JSON500 *struct {
		// The HTTP status text.
		Error *int `json:"error,omitempty"`

		// A brief message describing the error Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP status code.
		StatusCode *string `json:"statusCode,omitempty"`
	}
	JSON503 *struct {
		// The HTTP status text.
		Error *int `json:"error,omitempty"`

		// A brief message describing the error Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP status code.
		StatusCode *string `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoScansCredentialsConvertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoScansCredentialsConvertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansExportRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		File      *string `json:"file,omitempty"`
		TempToken *string `json:"temp_token,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansExportRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansExportRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansExportDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ScansExportDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansExportDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansExportStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The export status.
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansExportStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansExportStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		History *[]struct {
			// The unique identifier for the specific scan run.
			Id *int `json:"id,omitempty"`

			// Indicates whether the scan results are older than 35 days (`true`). If this parameter is `true`, Tenable.io returns limited data for the scan run. For complete scan results that are older than 35 days, use the [POST /scans/{scan_id}/export](ref:scans-export-request) endpoint instead.
			IsArchived *bool `json:"is_archived,omitempty"`

			// The UUID for the specific scan run.
			ScanUuid *string `json:"scan_uuid,omitempty"`

			// The status of the scan. For a list of possible values, see [Scan Status](doc:scan-status-tio).
			Status *string `json:"status,omitempty"`

			// The target parameters used to launch the scan.
			Targets *struct {
				// If `true`, custom parameters were used to launch the scan.
				Custom *bool `json:"custom,omitempty"`

				// If `true`, default parameters were used to launch the scan..
				Default *bool `json:"default,omitempty"`
			} `json:"targets,omitempty"`

			// The Unix timestamp when the scan finished running.
			TimeEnd *int `json:"time_end,omitempty"`

			// The Unix timestamp when the scan started running.
			TimeStart *int `json:"time_start,omitempty"`

			// The visibility of the scan results in workbenches (`public` or `private`).
			Visibility *string `json:"visibility,omitempty"`
		} `json:"history,omitempty"`
		Pagination *struct {
			// The number of records requested (or the default value if omitted from the request).
			Limit *int32 `json:"limit,omitempty"`

			// The starting record you requested (or zero if omitted).
			Offset *int32 `json:"offset,omitempty"`

			// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
			Sort *[]struct {
				// The field on which Tenable.io sorted the results.
				Name *string `json:"name,omitempty"`

				// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
				Order *string `json:"order,omitempty"`
			} `json:"sort,omitempty"`

			// The total number of records matching your search criteria.
			Total *int32 `json:"total,omitempty"`
		} `json:"pagination,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansDeleteHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON500      *struct {
		// The HTTP status text.
		Error *int `json:"error,omitempty"`

		// A brief message describing the error Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP status code.
		StatusCode *string `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansDeleteHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansDeleteHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansHistoryDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Indicates whether the scan results are older than 35 days (`true`). If this parameter is `true`, Tenable.io returns limited data for the scan run. For complete scan results that are older than 35 days, use the [POST /scans/{scan_id}/export](ref:scans-export-request) endpoint instead.
		IsArchived *bool `json:"is_archived,omitempty"`

		// The name of the scan.
		Name *string `json:"name,omitempty"`

		// The unique ID of the scan result object.
		ObjectId *int32 `json:"object_id,omitempty"`

		// The username of the owner of the scan when the scan run occurred.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the scan.
		OwnerId *int `json:"owner_id,omitempty"`

		// The UUID of the owner of the scan when the scan run occurred.
		OwnerUuid *int `json:"owner_uuid,omitempty"`

		// The Unix timestamp when the scan run finished.
		ScanEnd *int `json:"scan_end,omitempty"`

		// The Unix timestamp when the scan run started.
		ScanStart *int32 `json:"scan_start,omitempty"`

		// The type of scan: `ps` (a scan performed over the network by a cloud scanner), `remote` (a  scan performed over the network by a local scanner), `agent` (a scan on a local host that a Nessus agent performs directly), or `null` (the scan has never been launched, or the scan is imported).
		ScanType *string `json:"scan_type,omitempty"`

		// The UUID for a specific instance in the scan schedule.
		ScheduleUuid *string `json:"schedule_uuid,omitempty"`

		// The terminal status of the scan run. For possible values, see [Scan Status](doc:scan-status-tio).
		Status *string `json:"status,omitempty"`

		// The hosts that the scan targeted.
		Targets *string `json:"targets,omitempty"`

		// The UUID of the historical data.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansHistoryDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansHistoryDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansGetLatestStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The latest status of the scan. For a list of possible status values, see [Scan Status](doc:scan-status-tio).
		Status *string `json:"status,omitempty"`
	}
	JSON404 *struct {
		// A brief description of the cause of the error.
		Error *string `json:"error,omitempty"`
	}
	JSON500 *struct {
		// The HTTP status text.
		Error *int `json:"error,omitempty"`

		// A brief message describing the error Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP status code.
		StatusCode *string `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansGetLatestStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansGetLatestStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansLaunchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The UUID of the scan launched.
		ScanUuid *string `json:"scan_uuid,omitempty"`
	}
	JSON404 *struct {
		// A brief description of the cause of the error.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansLaunchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansLaunchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansPauseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScansPauseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansPauseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansResumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScansResumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansResumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// If `true`, the scan has a schedule and can be launched.
		Control *bool `json:"control,omitempty"`

		// If `true`, the schedule for the scan is enabled.
		Enabled *bool `json:"enabled,omitempty"`

		// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
		//
		// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
		Rrules *string `json:"rrules,omitempty"`

		// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` parameter.
		//
		// This attribute has the following format: `YYYYMMDDTHHMMSS`.
		Starttime *string `json:"starttime,omitempty"`

		// The timezone of the scheduled start time for the scan.
		Timezone *string `json:"timezone,omitempty"`
	}
	JSON404 *struct {
		// A brief description of the cause of the error.
		Error *string `json:"error,omitempty"`
	}
	JSON500 *struct {
		// The HTTP status text.
		Error *int `json:"error,omitempty"`

		// A brief message describing the error Tenable.io encountered.
		Message *string `json:"message,omitempty"`

		// The HTTP status code.
		StatusCode *string `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansReadStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScansReadStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansReadStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansStopResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ScansStopResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansStopResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansHostDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Compliance *[]struct {
			// The number of vulnerabilities found.
			Count *int `json:"count,omitempty"`

			// The unique ID of the host.
			HostId *int `json:"host_id,omitempty"`

			// The name of the host.
			Hostname *string `json:"hostname,omitempty"`

			// The parent family of the vulnerability plugin.
			PluginFamily *string `json:"plugin_family,omitempty"`

			// The unique ID of the vulnerability plugin.
			PluginId *int `json:"plugin_id,omitempty"`

			// The name of the vulnerability plugin.
			PluginName *string `json:"plugin_name,omitempty"`

			// The severity of plugin.
			Severity *int `json:"severity,omitempty"`

			// The severity index order of the plugin.
			SeverityIndex *int `json:"severity_index,omitempty"`
		} `json:"compliance,omitempty"`
		Info            *map[string]interface{} `json:"info,omitempty"`
		Vulnerabilities *[]struct {
			// The number of vulnerabilities found.
			Count *int `json:"count,omitempty"`

			// The unique ID of the host.
			HostId *int `json:"host_id,omitempty"`

			// The name of the host.
			Hostname *string `json:"hostname,omitempty"`

			// The parent family of the vulnerability plugin.
			PluginFamily *string `json:"plugin_family,omitempty"`

			// The unique ID of the vulnerability plugin.
			PluginId *int `json:"plugin_id,omitempty"`

			// The name of the vulnerability plugin.
			PluginName *string `json:"plugin_name,omitempty"`

			// The severity of plugin.
			Severity *int `json:"severity,omitempty"`

			// The severity index order of the plugin.
			SeverityIndex *int `json:"severity_index,omitempty"`

			// The index of the vulnerability plugin.
			VulnIndex *int `json:"vuln_index,omitempty"`
		} `json:"vulnerabilities,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansHostDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansHostDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScansPluginOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Info *struct {
			// The host's fully qualified domain name; optional.
			HostFqdn *string `json:"host-fqdn,omitempty"`

			// The host's IPv4 address; optional.
			HostIp *string `json:"host-ip,omitempty"`

			// The host's UUID generated by Tenable.io for identification purposes; always present.
			HostUuid *string `json:"host-uuid,omitempty"`

			// The last time a scan was completed for this host as an ISO 8601 timestamp; always present.
			HostEnd *string `json:"host_end,omitempty"`

			// The FQDN of the host. Normally, this is populated with the value used to scan the host in the target list of the last scan that was ran where it was seen; always present.
			HostFqdn2 *string `json:"host_fqdn,omitempty"`

			// The last time a scan was started for this host as an ISO 8601 timestamp; always present.
			HostStart *string `json:"host_start,omitempty"`

			// The host's mac addresses in a newline-separated list; optional.
			MacAddress *string `json:"mac-address,omitempty"`
		} `json:"info,omitempty"`
		Output *[]struct {
			// A custom description of the plugin.
			CustomDescription *string `json:"custom_description,omitempty"`

			// If the value is 1, the plugin output contains files that may be exported.
			HasAttachment *int `json:"has_attachment,omitempty"`

			// Other hosts with the same output.
			Hosts *string `json:"hosts,omitempty"`

			// The text of the plugin output.
			PluginOutput *string                 `json:"plugin_output,omitempty"`
			Ports        *map[string]interface{} `json:"ports,omitempty"`

			// The severity the output.
			Severity *int `json:"severity,omitempty"`
		} `json:"output,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScansPluginOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScansPluginOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServerPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Analytics          *map[string]interface{} `json:"analytics,omitempty"`
		Capabilities       *map[string]interface{} `json:"capabilities,omitempty"`
		ContainerDbVersion *string                 `json:"container_db_version,omitempty"`
		Enterprise         *bool                   `json:"enterprise,omitempty"`
		Expiration         *int                    `json:"expiration,omitempty"`
		ExpirationTime     *int                    `json:"expiration_time,omitempty"`
		ForceUiReload      *bool                   `json:"force_ui_reload,omitempty"`
		IdleTimeout        *int                    `json:"idle_timeout,omitempty"`
		License            *map[string]interface{} `json:"license,omitempty"`
		LimitEnabled       *bool                   `json:"limitEnabled,omitempty"`
		LoadedPluginSet    *string                 `json:"loaded_plugin_set,omitempty"`
		LoginBanner        *bool                   `json:"login_banner,omitempty"`
		Msp                *bool                   `json:"msp,omitempty"`
		NessusType         *string                 `json:"nessus_type,omitempty"`
		NessusUiBuild      *string                 `json:"nessus_ui_build,omitempty"`
		NessusUiVersion    *string                 `json:"nessus_ui_version,omitempty"`
		Notifications      *[]string               `json:"notifications,omitempty"`
		PluginSet          *string                 `json:"plugin_set,omitempty"`
		ScannerBoottime    *int                    `json:"scanner_boottime,omitempty"`
		ServerBuild        *string                 `json:"server_build,omitempty"`
		ServerUuid         *string                 `json:"server_uuid,omitempty"`
		ServerVersion      *string                 `json:"server_version,omitempty"`
		Update             *struct {
			Href       *string `json:"href,omitempty"`
			NewVersion *int    `json:"new_version,omitempty"`
			Restart    *int    `json:"restart,omitempty"`
		} `json:"update,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ServerPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServerPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServerStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Code   *int    `json:"code,omitempty"`
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ServerStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServerStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsAssignAssetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// The UUID of the asynchronous asset update job.
		JobUuid *string `json:"job_uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TagsAssignAssetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsAssignAssetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsListAssetFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Control *struct {
			// Provides a human-readable "hint" to guide users creating tag rules in the Tenable.io user interface.
			ReadableRegex *string `json:"readable_regex,omitempty"`

			// A regular expression that Tenable.io UI uses to validate input.
			Regex *string `json:"regex,omitempty"`

			// The type of UI control that represents the filter in the Tenable.io user interface.
			Type *string `json:"type,omitempty"`
		} `json:"control,omitempty"`

		// The name of the asset attribute or tag.
		Name *string `json:"name,omitempty"`

		// The comparison operators that can be used for the filter. To find supported operators, use the [GET /tags/assets/filters](ref:tags-list-asset-filters) endpoint.
		Operators *[]string `json:"operators,omitempty"`

		// The asset attribute name displayed in the Tenable.io user interface.
		ReadableName *string `json:"readable_name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TagsListAssetFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsListAssetFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsListAssetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// An array of asset assignment objects.
		Tags *[]struct {
			// The UUID of the asset where the tag is assigned.
			AssetUuid *string `json:"asset_uuid,omitempty"`

			// The tag category name (the first half of the category:value pair).
			CategoryName *string `json:"category_name,omitempty"`

			// The UUID of the tag category. Use this value to create future tags in the same category.
			CategoryUuid *string `json:"category_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the was assigned to an asset, for example, `2018-12-31T13:51:17.243Z`.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who assigned the tag to the asset.
			CreatedBy *string `json:"created_by,omitempty"`

			// The tag type:
			//  - staticA user must manually apply the tag to assets.
			//  - dynamicTenable.io automatically applies the tag based on asset attribute rules.
			Source *string `json:"source,omitempty"`

			// The tag value (the second half of the category:value pair).
			Value *string `json:"value,omitempty"`

			// The UUID of the tag value.
			//
			// **Note:** A tag UUID is technically assigned to the tag value only (the second half of the category:value pair), but the API commands use this value to represent the whole `category:value` pair.
			ValueUuid *string `json:"value_uuid,omitempty"`
		} `json:"tags,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TagsListAssetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsListAssetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsListTagCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A collection of category objects.
		Categories *[]struct {
			// An ISO timestamp indicating the date and time on which the category was created, for example, `2018-12-31T13:51:17.243Z`.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the category.
			CreatedBy *string `json:"created_by,omitempty"`

			// The description of the category.
			Description *string `json:"description,omitempty"`

			// The name of the category. The name must be unique within a Tenable.io instance.
			Name *string `json:"name,omitempty"`

			// Indicates whether the tags in this category are reserved (cannot be updated). This is a read-only field set by the system.
			Reserved *bool `json:"reserved,omitempty"`

			// An ISO timestamp indicating the date and time on which the category was last updated, for example, `2018-12-31T13:51:17.243Z`.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last updated the category.
			UpdatedBy *string `json:"updated_by,omitempty"`

			// The UUID of the category.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"categories,omitempty"`
		Pagination *struct {
			// The number of records requested (or the default value if omitted from the request).
			Limit *int32 `json:"limit,omitempty"`

			// The starting record you requested (or zero if omitted).
			Offset *int32 `json:"offset,omitempty"`

			// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
			Sort *[]struct {
				// The field on which Tenable.io sorted the results.
				Name *string `json:"name,omitempty"`

				// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
				Order *string `json:"order,omitempty"`
			} `json:"sort,omitempty"`

			// The total number of records matching your search criteria.
			Total *int32 `json:"total,omitempty"`
		} `json:"pagination,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TagsListTagCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsListTagCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsCreateTagCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// An ISO timestamp indicating the date and time on which the category was created, for example, `2018-12-31T13:51:17.243Z`.
		CreatedAt *string `json:"created_at,omitempty"`

		// The name of the user who created the category.
		CreatedBy *string `json:"created_by,omitempty"`

		// The description of the category.
		Description *string `json:"description,omitempty"`

		// The name of the category. The name must be unique within a Tenable.io instance.
		Name *string `json:"name,omitempty"`

		// Indicates whether the tags in this category are reserved (cannot be updated). This is a read-only field set by the system.
		Reserved *bool `json:"reserved,omitempty"`

		// An ISO timestamp indicating the date and time on which the category was last updated, for example, `2018-12-31T13:51:17.243Z`.
		UpdatedAt *string `json:"updated_at,omitempty"`

		// The name of the user who last updated the category.
		UpdatedBy *string `json:"updated_by,omitempty"`

		// The UUID of the category.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TagsCreateTagCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsCreateTagCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsDeleteTagCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *interface{}
}

// Status returns HTTPResponse.Status
func (r TagsDeleteTagCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsDeleteTagCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsTagCategoryDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// An ISO timestamp indicating the date and time on which the category was created, for example, `2018-12-31T13:51:17.243Z`.
		CreatedAt *string `json:"created_at,omitempty"`

		// The name of the user who created the category.
		CreatedBy *string `json:"created_by,omitempty"`

		// The description of the category.
		Description *string `json:"description,omitempty"`

		// The name of the category. The name must be unique within a Tenable.io instance.
		Name *string `json:"name,omitempty"`

		// Indicates whether the tags in this category are reserved (cannot be updated). This is a read-only field set by the system.
		Reserved *bool `json:"reserved,omitempty"`

		// An ISO timestamp indicating the date and time on which the category was last updated, for example, `2018-12-31T13:51:17.243Z`.
		UpdatedAt *string `json:"updated_at,omitempty"`

		// The name of the user who last updated the category.
		UpdatedBy *string `json:"updated_by,omitempty"`

		// The UUID of the category.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TagsTagCategoryDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsTagCategoryDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsEditTagCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// An ISO timestamp indicating the date and time on which the category was created, for example, `2018-12-31T13:51:17.243Z`.
		CreatedAt *string `json:"created_at,omitempty"`

		// The name of the user who created the category.
		CreatedBy *string `json:"created_by,omitempty"`

		// The description of the category.
		Description *string `json:"description,omitempty"`

		// The name of the category. The name must be unique within a Tenable.io instance.
		Name *string `json:"name,omitempty"`

		// Indicates whether the tags in this category are reserved (cannot be updated). This is a read-only field set by the system.
		Reserved *bool `json:"reserved,omitempty"`

		// An ISO timestamp indicating the date and time on which the category was last updated, for example, `2018-12-31T13:51:17.243Z`.
		UpdatedAt *string `json:"updated_at,omitempty"`

		// The name of the user who last updated the category.
		UpdatedBy *string `json:"updated_by,omitempty"`

		// The UUID of the category.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TagsEditTagCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsEditTagCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsListTagValuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Pagination *struct {
			// The number of records requested (or the default value if omitted from the request).
			Limit *int32 `json:"limit,omitempty"`

			// The starting record you requested (or zero if omitted).
			Offset *int32 `json:"offset,omitempty"`

			// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
			Sort *[]struct {
				// The field on which Tenable.io sorted the results.
				Name *string `json:"name,omitempty"`

				// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
				Order *string `json:"order,omitempty"`
			} `json:"sort,omitempty"`

			// The total number of records matching your search criteria.
			Total *int32 `json:"total,omitempty"`
		} `json:"pagination,omitempty"`

		// An array of tag value objects.
		Values *[]struct {
			// Determines what the user can do with the tag value.
			AccessControl *struct {
				// List of the minimum set of permissions all users have on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
				AllUsersPermissions *N200ValuesAccessControlAllUsersPermissions `json:"all_users_permissions,omitempty"`

				// List of user and group-specific permissions for the current tag.
				CurrentDomainPermissions *[]struct {
					// The UUID of a user or group.
					Id *string `json:"id,omitempty"`

					// The name of the user or group.
					Name *string `json:"name,omitempty"`

					// The permissions associated with the user or group.
					Permissions *[]string `json:"permissions,omitempty"`

					// The type of permission.
					Type *N200ValuesAccessControlCurrentDomainPermissionsType `json:"type,omitempty"`
				} `json:"current_domain_permissions,omitempty"`

				// List of all permissions for the current user on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`.
				CurrentUserPermissions *N200ValuesAccessControlCurrentUserPermissions `json:"current_user_permissions,omitempty"`

				// List of all defined permissions for objects of type tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
				DefinedDomainPermissions *N200ValuesAccessControlDefinedDomainPermissions `json:"defined_domain_permissions,omitempty"`

				// Optional, user-defined value. This value must be incremented each time the permissions are updated. Set to `1` by default.
				Version *int64 `json:"version,omitempty"`
			} `json:"access_control,omitempty"`

			// The description of the category associated with the tag value.
			CategoryDescription *string `json:"category_description,omitempty"`

			// The name of the category associated with the tag value.
			CategoryName *string `json:"category_name,omitempty"`

			// The UUID of the category associated with the tag value. Use this value to create future tags in the same category.
			CategoryUuid *string `json:"category_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the tag value was created, for example, `2018-12-31T13:51:17.243Z`.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the tag value.
			CreatedBy *string `json:"created_by,omitempty"`

			// The description of the tag value.
			Description *string `json:"description,omitempty"`

			// The tag type:
			//  - staticA user must manually apply the tag to assets.
			//  - dynamicTenable.io automatically applies the tag based on asset attribute rules.
			Type *string `json:"type,omitempty"`

			// An ISO timestamp indicating the date and time on which the tag value was last updated, for example, `2018-12-31T13:51:17.243Z`. When you create a tag value, this date matches the `created_at` date.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last updated the tag value. When you create a tag value, this name matches the `created_by` name.
			UpdatedBy *string `json:"updated_by,omitempty"`

			// The UUID of the tag value. Use this value to assign the tag to assets.
			Uuid *string `json:"uuid,omitempty"`

			// The tag value. Must be unique within the category.
			Value *string `json:"value,omitempty"`
		} `json:"values,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TagsListTagValuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsListTagValuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsCreateTagValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Determines what the user can do with the tag value.
		AccessControl *struct {
			// List of the minimum set of permissions all users have on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
			AllUsersPermissions *N200AccessControlAllUsersPermissions `json:"all_users_permissions,omitempty"`

			// List of user and group-specific permissions for the current tag.
			CurrentDomainPermissions *[]struct {
				// The UUID of a user or group.
				Id *string `json:"id,omitempty"`

				// The name of the user or group.
				Name *string `json:"name,omitempty"`

				// The permissions associated with the user or group.
				Permissions *[]string `json:"permissions,omitempty"`

				// The type of permission.
				Type *N200AccessControlCurrentDomainPermissionsType `json:"type,omitempty"`
			} `json:"current_domain_permissions,omitempty"`

			// List of all permissions for the current user on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`.
			CurrentUserPermissions *N200AccessControlCurrentUserPermissions `json:"current_user_permissions,omitempty"`

			// List of all defined permissions for objects of type tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
			DefinedDomainPermissions *N200AccessControlDefinedDomainPermissions `json:"defined_domain_permissions,omitempty"`

			// Optional, user-defined value. This value must be incremented each time the permissions are updated. Set to `1` by default.
			Version *int64 `json:"version,omitempty"`
		} `json:"access_control,omitempty"`

		// The description of the category associated with the tag value.
		CategoryDescription *string `json:"category_description,omitempty"`

		// The name of the category associated with the tag value.
		CategoryName *string `json:"category_name,omitempty"`

		// The UUID of the category associated with the tag value. Use this value to create future tags in the same category.
		CategoryUuid *string `json:"category_uuid,omitempty"`

		// An ISO timestamp indicating the date and time on which the tag value was created, for example, `2018-12-31T13:51:17.243Z`.
		CreatedAt *string `json:"created_at,omitempty"`

		// The name of the user who created the tag value.
		CreatedBy *string `json:"created_by,omitempty"`

		// The description of the tag value.
		Description *string `json:"description,omitempty"`

		// For dynamic tags, asset selection rules.
		Filters *struct {
			// Tag rule definitions represented as a JSON-formatted string.
			Asset *string `json:"asset,omitempty"`
		} `json:"filters,omitempty"`

		// The tag type:
		//  - staticA user must manually apply the tag to assets.
		//  - dynamicTenable.io automatically applies the tag based on asset attribute rules.
		Type *string `json:"type,omitempty"`

		// An ISO timestamp indicating the date and time on which the tag value was last updated, for example, `2018-12-31T13:51:17.243Z`. When you create a tag value, this date matches the `created_at` date.
		UpdatedAt *string `json:"updated_at,omitempty"`

		// The name of the user who last updated the tag value. When you create a tag value, this name matches the `created_by` name.
		UpdatedBy *string `json:"updated_by,omitempty"`

		// The UUID of the tag value. Use this value to assign the tag to assets.
		Uuid *string `json:"uuid,omitempty"`

		// The tag value. Must be unique within the category.
		Value *string `json:"value,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TagsCreateTagValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsCreateTagValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsDeleteTagValuesBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r TagsDeleteTagValuesBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsDeleteTagValuesBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsDeleteTagValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON204      *interface{}
}

// Status returns HTTPResponse.Status
func (r TagsDeleteTagValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsDeleteTagValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsTagValueDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Determines what the user can do with the tag value.
		AccessControl *struct {
			// List of the minimum set of permissions all users have on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
			AllUsersPermissions *N200AccessControlAllUsersPermissions `json:"all_users_permissions,omitempty"`

			// List of user and group-specific permissions for the current tag.
			CurrentDomainPermissions *[]struct {
				// The UUID of a user or group.
				Id *string `json:"id,omitempty"`

				// The name of the user or group.
				Name *string `json:"name,omitempty"`

				// The permissions associated with the user or group.
				Permissions *[]string `json:"permissions,omitempty"`

				// The type of permission.
				Type *N200AccessControlCurrentDomainPermissionsType `json:"type,omitempty"`
			} `json:"current_domain_permissions,omitempty"`

			// List of all permissions for the current user on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`.
			CurrentUserPermissions *N200AccessControlCurrentUserPermissions `json:"current_user_permissions,omitempty"`

			// List of all defined permissions for objects of type tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
			DefinedDomainPermissions *N200AccessControlDefinedDomainPermissions `json:"defined_domain_permissions,omitempty"`

			// Optional, user-defined value. This value must be incremented each time the permissions are updated. Set to `1` by default.
			Version *int64 `json:"version,omitempty"`
		} `json:"access_control,omitempty"`

		// The description of the category associated with the tag value.
		CategoryDescription *string `json:"category_description,omitempty"`

		// The name of the category associated with the tag value.
		CategoryName *string `json:"category_name,omitempty"`

		// The UUID of the category associated with the tag value. Use this value to create future tags in the same category.
		CategoryUuid *string `json:"category_uuid,omitempty"`

		// An ISO timestamp indicating the date and time on which the tag value was created, for example, `2018-12-31T13:51:17.243Z`.
		CreatedAt *string `json:"created_at,omitempty"`

		// The name of the user who created the tag value.
		CreatedBy *string `json:"created_by,omitempty"`

		// The description of the tag value.
		Description *string `json:"description,omitempty"`

		// For dynamic tags, asset selection rules.
		Filters *struct {
			// Tag rule definitions represented as a JSON-formatted string.
			Asset *string `json:"asset,omitempty"`
		} `json:"filters,omitempty"`

		// The tag type:
		//  - staticA user must manually apply the tag to assets.
		//  - dynamicTenable.io automatically applies the tag based on asset attribute rules.
		Type *string `json:"type,omitempty"`

		// An ISO timestamp indicating the date and time on which the tag value was last updated, for example, `2018-12-31T13:51:17.243Z`. When you create a tag value, this date matches the `created_at` date.
		UpdatedAt *string `json:"updated_at,omitempty"`

		// The name of the user who last updated the tag value. When you create a tag value, this name matches the `created_by` name.
		UpdatedBy *string `json:"updated_by,omitempty"`

		// The UUID of the tag value. Use this value to assign the tag to assets.
		Uuid *string `json:"uuid,omitempty"`

		// The tag value. Must be unique within the category.
		Value *string `json:"value,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TagsTagValueDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsTagValueDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TagsUpdateTagValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Determines what the user can do with the tag value.
		AccessControl *struct {
			// List of the minimum set of permissions all users have on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
			AllUsersPermissions *N200AccessControlAllUsersPermissions `json:"all_users_permissions,omitempty"`

			// List of user and group-specific permissions for the current tag.
			CurrentDomainPermissions *[]struct {
				// The UUID of a user or group.
				Id *string `json:"id,omitempty"`

				// The name of the user or group.
				Name *string `json:"name,omitempty"`

				// The permissions associated with the user or group.
				Permissions *[]string `json:"permissions,omitempty"`

				// The type of permission.
				Type *N200AccessControlCurrentDomainPermissionsType `json:"type,omitempty"`
			} `json:"current_domain_permissions,omitempty"`

			// List of all permissions for the current user on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`.
			CurrentUserPermissions *N200AccessControlCurrentUserPermissions `json:"current_user_permissions,omitempty"`

			// List of all defined permissions for objects of type tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
			DefinedDomainPermissions *N200AccessControlDefinedDomainPermissions `json:"defined_domain_permissions,omitempty"`

			// Optional, user-defined value. This value must be incremented each time the permissions are updated. Set to `1` by default.
			Version *int64 `json:"version,omitempty"`
		} `json:"access_control,omitempty"`

		// The description of the category associated with the tag value.
		CategoryDescription *string `json:"category_description,omitempty"`

		// The name of the category associated with the tag value.
		CategoryName *string `json:"category_name,omitempty"`

		// The UUID of the category associated with the tag value. Use this value to create future tags in the same category.
		CategoryUuid *string `json:"category_uuid,omitempty"`

		// An ISO timestamp indicating the date and time on which the tag value was created, for example, `2018-12-31T13:51:17.243Z`.
		CreatedAt *string `json:"created_at,omitempty"`

		// The name of the user who created the tag value.
		CreatedBy *string `json:"created_by,omitempty"`

		// The description of the tag value.
		Description *string `json:"description,omitempty"`

		// For dynamic tags, asset selection rules.
		Filters *struct {
			// Tag rule definitions represented as a JSON-formatted string.
			Asset *string `json:"asset,omitempty"`
		} `json:"filters,omitempty"`

		// The tag type:
		//  - staticA user must manually apply the tag to assets.
		//  - dynamicTenable.io automatically applies the tag based on asset attribute rules.
		Type *string `json:"type,omitempty"`

		// An ISO timestamp indicating the date and time on which the tag value was last updated, for example, `2018-12-31T13:51:17.243Z`. When you create a tag value, this date matches the `created_at` date.
		UpdatedAt *string `json:"updated_at,omitempty"`

		// The name of the user who last updated the tag value. When you create a tag value, this name matches the `created_by` name.
		UpdatedBy *string `json:"updated_by,omitempty"`

		// The UUID of the tag value. Use this value to assign the tag to assets.
		Uuid *string `json:"uuid,omitempty"`

		// The tag value. Must be unique within the category.
		Value *string `json:"value,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TagsUpdateTagValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TagsUpdateTagValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TargetGroupsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// The Access Control Lists applicable to the group.
		Acls *[]struct {
			// The display-friendly name of the user or group.
			DisplayName *string `json:"display_name,omitempty"`

			// The unique ID of the user or group.
			Id *int `json:"id,omitempty"`

			// The name of the user or group.
			Name *string `json:"name,omitempty"`

			// The ID of the owner of the object.
			Owner *int `json:"owner,omitempty"`

			// The permission value to grant access as described in [Permissions](doc:permissions).
			Permissions *int32 `json:"permissions,omitempty"`

			// The type of permission (default, user, group).
			Type *N200AclsType `json:"type,omitempty"`

			// The UUID of the owner of the object.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"acls,omitempty"`

		// If true, this group is the default.
		DefaultGroup *bool `json:"default_group,omitempty"`

		// The unique ID of the group.
		Id *int `json:"id,omitempty"`

		// The last modification date for the group in unixtime.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The members of the group.
		Members *string `json:"members,omitempty"`

		// The name of the group.
		Name *string `json:"name,omitempty"`

		// The name of the owner of the group. A user of `nessus_ms_agent` indicates it is a system target group.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the group.
		OwnerId *int `json:"owner_id,omitempty"`

		// The shared status of the group.
		Shared *bool `json:"shared,omitempty"`

		// The group type (user or system). Note that the system group type is deprecated. Tenable recommends that you create only user target groups.
		Type *string `json:"type,omitempty"`

		// The current user permissions for the group.
		UserPermissions *int `json:"user_permissions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TargetGroupsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TargetGroupsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TargetGroupsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The Access Control Lists applicable to the group.
		Acls *[]struct {
			// The display-friendly name of the user or group.
			DisplayName *string `json:"display_name,omitempty"`

			// The unique ID of the user or group.
			Id *int `json:"id,omitempty"`

			// The name of the user or group.
			Name *string `json:"name,omitempty"`

			// The ID of the owner of the object.
			Owner *int `json:"owner,omitempty"`

			// The permission value to grant access as described in [Permissions](doc:permissions).
			Permissions *int32 `json:"permissions,omitempty"`

			// The type of permission (default, user, group).
			Type *N200AclsType `json:"type,omitempty"`

			// The UUID of the owner of the object.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"acls,omitempty"`

		// If true, this group is the default.
		DefaultGroup *bool `json:"default_group,omitempty"`

		// The unique ID of the group.
		Id *int `json:"id,omitempty"`

		// The last modification date for the group in unixtime.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The members of the group.
		Members *string `json:"members,omitempty"`

		// The name of the group.
		Name *string `json:"name,omitempty"`

		// The name of the owner of the group. A user of `nessus_ms_agent` indicates it is a system target group.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the group.
		OwnerId *int `json:"owner_id,omitempty"`

		// The shared status of the group.
		Shared *bool `json:"shared,omitempty"`

		// The group type (user or system). Note that the system group type is deprecated. Tenable recommends that you create only user target groups.
		Type *string `json:"type,omitempty"`

		// The current user permissions for the group.
		UserPermissions *int `json:"user_permissions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TargetGroupsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TargetGroupsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TargetGroupsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r TargetGroupsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TargetGroupsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TargetGroupsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The Access Control Lists applicable to the group.
		Acls *[]struct {
			// The display-friendly name of the user or group.
			DisplayName *string `json:"display_name,omitempty"`

			// The unique ID of the user or group.
			Id *int `json:"id,omitempty"`

			// The name of the user or group.
			Name *string `json:"name,omitempty"`

			// The ID of the owner of the object.
			Owner *int `json:"owner,omitempty"`

			// The permission value to grant access as described in [Permissions](doc:permissions).
			Permissions *int32 `json:"permissions,omitempty"`

			// The type of permission (default, user, group).
			Type *N200AclsType `json:"type,omitempty"`

			// The UUID of the owner of the object.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"acls,omitempty"`

		// If true, this group is the default.
		DefaultGroup *bool `json:"default_group,omitempty"`

		// The unique ID of the group.
		Id *int `json:"id,omitempty"`

		// The last modification date for the group in unixtime.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The members of the group.
		Members *string `json:"members,omitempty"`

		// The name of the group.
		Name *string `json:"name,omitempty"`

		// The name of the owner of the group. A user of `nessus_ms_agent` indicates it is a system target group.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the group.
		OwnerId *int `json:"owner_id,omitempty"`

		// The shared status of the group.
		Shared *bool `json:"shared,omitempty"`

		// The group type (user or system). Note that the system group type is deprecated. Tenable recommends that you create only user target groups.
		Type *string `json:"type,omitempty"`

		// The current user permissions for the group.
		UserPermissions *int `json:"user_permissions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TargetGroupsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TargetGroupsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TargetGroupsEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The Access Control Lists applicable to the group.
		Acls *[]struct {
			// The display-friendly name of the user or group.
			DisplayName *string `json:"display_name,omitempty"`

			// The unique ID of the user or group.
			Id *int `json:"id,omitempty"`

			// The name of the user or group.
			Name *string `json:"name,omitempty"`

			// The ID of the owner of the object.
			Owner *int `json:"owner,omitempty"`

			// The permission value to grant access as described in [Permissions](doc:permissions).
			Permissions *int32 `json:"permissions,omitempty"`

			// The type of permission (default, user, group).
			Type *N200AclsType `json:"type,omitempty"`

			// The UUID of the owner of the object.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"acls,omitempty"`

		// If true, this group is the default.
		DefaultGroup *bool `json:"default_group,omitempty"`

		// The unique ID of the group.
		Id *int `json:"id,omitempty"`

		// The last modification date for the group in unixtime.
		LastModificationDate *int `json:"last_modification_date,omitempty"`

		// The members of the group.
		Members *string `json:"members,omitempty"`

		// The name of the group.
		Name *string `json:"name,omitempty"`

		// The name of the owner of the group. A user of `nessus_ms_agent` indicates it is a system target group.
		Owner *string `json:"owner,omitempty"`

		// The unique ID of the owner of the group.
		OwnerId *int `json:"owner_id,omitempty"`

		// The shared status of the group.
		Shared *bool `json:"shared,omitempty"`

		// The group type (user or system). Note that the system group type is deprecated. Tenable recommends that you create only user target groups.
		Type *string `json:"type,omitempty"`

		// The current user permissions for the group.
		UserPermissions *int `json:"user_permissions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TargetGroupsEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TargetGroupsEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV2AccessGroupsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccessGroups *struct {
			// The type of access group. It can be one of three possible types:
			//  * MANAGE_ASSETSUsers in this access group can view the asset records created during previous scans and scan the associated targets for those assets.
			//  * SCAN_TARGETSUsers in this access group can scan targets associated with the access group and view the results of those scans. Targets may be associated with existing assets.
			//  * ALLThis access group type is only applicable to the default system-generated "All Assets" access group that contains all assets in your organization. This group is referred to as the "All Assets" group in the user interface. By default, Tenable.io grants all users in this access group both CAN VIEW and CAN SCAN permissions.
			AccessGroupType *N200AccessGroupsAccessGroupType `json:"access_group_type,omitempty"`

			// Specifies whether the access group is the system-provided All Assets access group:
			//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /v2/access-groups/{id}](ref:io-v2-access-groups-edit) endpoint.
			//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
			AllAssets *bool `json:"all_assets,omitempty"`

			// The UUID of your Tenable.io instance.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the access group was created.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the access group.
			CreatedByName *string `json:"created_by_name,omitempty"`

			// The UUID of the user who created the access group.
			CreatedByUuid *string `json:"created_by_uuid,omitempty"`

			// The UUID of the access group.
			Id *string `json:"id,omitempty"`

			// The name of the access group. This name must be:
			// * Unique within your Tenable.io instance.
			// * A maximum of 255 characters.
			// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
			Name *string `json:"name,omitempty"`

			// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
			Principals *[]struct {
				// (Required) The permissions associated with the principal of the access group as described in <a href="/docs/permissions">Permissions</a>.
				Permissions *N200AccessGroupsPrincipalsPermissions `json:"permissions,omitempty"`

				// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
				PrincipalId *string `json:"principal_id,omitempty"`

				// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
				PrincipalName *string `json:"principal_name,omitempty"`

				// (Required) The type of principal. Valid values include:
				//  - all_usersGrants access to all users in your organization. That access includes `Can View` access to the assets defined in the rules parameter.
				//  - userGrants access to the user you specify.
				//  - groupGrants access to all users assigned to the user group you specify.
				Type *N200AccessGroupsPrincipalsType `json:"type,omitempty"`
			} `json:"principals,omitempty"`

			// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
			ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

			// The status of the process evaluating and assigning assets to the access group. Possible values are:
			//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
			//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
			//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
			Status *string `json:"status,omitempty"`

			// An ISO timestamp indicating the time and date on which the access group was last modified.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last modified the access group.
			UpdatedByName *string `json:"updated_by_name,omitempty"`

			// The UUID of the user who last modified the access group.
			UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`

			// Optional, user-defined value. This value must be incremented each time an access group is updated. Set to `1` by default.
			Version *int `json:"version,omitempty"`
		} `json:"access_groups,omitempty"`
		Pagination *struct {
			// The number of records requested (or the default value if omitted from the request).
			Limit *int32 `json:"limit,omitempty"`

			// The starting record you requested (or zero if omitted).
			Offset *int32 `json:"offset,omitempty"`

			// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
			Sort *[]struct {
				// The field on which Tenable.io sorted the results.
				Name *string `json:"name,omitempty"`

				// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
				Order *string `json:"order,omitempty"`
			} `json:"sort,omitempty"`

			// The total number of records matching your search criteria.
			Total *int32 `json:"total,omitempty"`
		} `json:"pagination,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoV2AccessGroupsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV2AccessGroupsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV2AccessGroupsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The type of access group. It can be one of three possible types:
		//  * MANAGE_ASSETSUsers in this access group can view the asset records created during previous scans and scan the associated targets for those assets.
		//  * SCAN_TARGETSUsers in this access group can scan targets associated with the access group and view the results of those scans. Targets may be associated with existing assets.
		//  * ALLThis access group type is only applicable to the default system-generated "All Assets" access group that contains all assets in your organization. This group is referred to as the "All Assets" group in the user interface. By default, Tenable.io grants all users in this access group both CAN VIEW and CAN SCAN permissions.
		AccessGroupType *N200AccessGroupType `json:"access_group_type,omitempty"`

		// Specifies whether the access group is the system-provided All Assets access group:
		//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /v2/access-groups/{id}](ref:io-v2-access-groups-edit) endpoint.
		//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
		AllAssets *bool `json:"all_assets,omitempty"`

		// The UUID of your Tenable.io instance.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// An ISO timestamp indicating the date and time on which the access group was created.
		CreatedAt *string `json:"created_at,omitempty"`

		// The name of the user who created the access group.
		CreatedByName *string `json:"created_by_name,omitempty"`

		// The UUID of the user who created the access group.
		CreatedByUuid *string `json:"created_by_uuid,omitempty"`

		// The UUID of the access group.
		Id *string `json:"id,omitempty"`

		// The name of the access group. This name must be:
		// * Unique within your Tenable.io instance.
		// * A maximum of 255 characters.
		// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
		Name *string `json:"name,omitempty"`

		// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
		Principals *[]struct {
			// (Required) The permissions associated with the principal of the access group as described in <a href="/docs/permissions">Permissions</a>.
			Permissions *N200PrincipalsPermissions `json:"permissions,omitempty"`

			// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
			PrincipalId *string `json:"principal_id,omitempty"`

			// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
			PrincipalName *string `json:"principal_name,omitempty"`

			// (Required) The type of principal. Valid values include:
			//  - all_usersGrants access to all users in your organization. That access includes `Can View` access to the assets defined in the rules parameter.
			//  - userGrants access to the user you specify.
			//  - groupGrants access to all users assigned to the user group you specify.
			Type *N200PrincipalsType `json:"type,omitempty"`
		} `json:"principals,omitempty"`

		// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
		ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

		// The status of the process evaluating and assigning assets to the access group. Possible values are:
		//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
		//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
		//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
		Status *string `json:"status,omitempty"`

		// An ISO timestamp indicating the time and date on which the access group was last modified.
		UpdatedAt *string `json:"updated_at,omitempty"`

		// The name of the user who last modified the access group.
		UpdatedByName *string `json:"updated_by_name,omitempty"`

		// The UUID of the user who last modified the access group.
		UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`

		// Optional, user-defined value. This value must be incremented each time an access group is updated. Set to `1` by default.
		Version *int `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoV2AccessGroupsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV2AccessGroupsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV2AccessGroupsListFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The filters and operators for each field you can use when constructing filter (`f` parameter) values in the [GET /v2/access-groups](ref:io-v2-access-groups-list) endpoint.
		Filters *[]struct {
			// Indicates how the parameter appears in the Tenable.io user interface.
			Control *string `json:"control,omitempty"`

			// Corresponds to the field component of the `f` parameter.
			Name *string `json:"name,omitempty"`

			// Corresponds to the operator component of the `f` parameter.
			Operators *[]string `json:"operators,omitempty"`

			// The name of the parameter as it appears in the Tenable.io user interface.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"filters,omitempty"`

		// The fields you can use when constructing `sort` parameter values for the [GET /v2/access-groups](ref:io-v2-access-groups-list) endpoint.
		Sort *[]struct {
			// The names of the fields you can use when constructing `sort` parameter values for the [GET /v2/access-groups](ref:io-v2-access-groups-list) endpoint.
			SortableFields *string `json:"sortable_fields,omitempty"`
		} `json:"sort,omitempty"`

		// The fields you can use as a wildcard (`wf` parameter) value in the [GET /v2/access-groups](ref:io-v2-access-groups-list) endpoint.
		WildcardFields *[]string `json:"wildcard_fields,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoV2AccessGroupsListFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV2AccessGroupsListFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV2AccessGroupsListRuleFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// An array specifying values to use when constructing an asset rule for the [POST /access-groups](ref:io-v2-access-groups-create) and [PUT /access-groups/{id}](ref:io-v2-access-groups-edit) methods.
		Rules *[]struct {
			// Indicates how the field appears in the Tenable.io user interface.
			Control *[]struct {
				// The regular expression Tenable.io uses to match values of the rule type.
				Regex *string `json:"regex,omitempty"`

				// The type of control.
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// The name of the filter parameter. Corresponds to the asset rule type.
			Name *string `json:"name,omitempty"`

			// The operator that specifies how Tenable.io matches the terms value to asset data. Corresponds to the operator component of the rules parameter. Possible operators include:
			// * eqTenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
			// * matchTenable.io matches the rule to assets based a partial match of the specified term.
			// * startsTenable.io matches the rule to assets that start with the specified term.
			// * endsTenable.io matches the rule to assets that end with the specified term.
			//  * set-hasTenable.io matches the rule to assets based on the specified `tag_uuid`.
			//
			// For a complete list of operators by rule type, use the [GET /v2/access-groups/filters](ref:io-v2-access-groups-list-filters) endpoint.
			Operators *[]string `json:"operators,omitempty"`

			// An example value.
			Placeholder *string `json:"placeholder,omitempty"`

			// The name of the field as it appears in the Tenable.io user interface.
			ReadableName *string `json:"readable_name,omitempty"`
		} `json:"rules,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoV2AccessGroupsListRuleFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV2AccessGroupsListRuleFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV2AccessGroupsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IoV2AccessGroupsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV2AccessGroupsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV2AccessGroupsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The type of access group. It can be one of three possible types:
		//  * MANAGE_ASSETSUsers in this access group can view the asset records created during previous scans and scan the associated targets for those assets.
		//  * SCAN_TARGETSUsers in this access group can scan targets associated with the access group and view the results of those scans. Targets may be associated with existing assets.
		//  * ALLThis access group type is only applicable to the default system-generated "All Assets" access group that contains all assets in your organization. This group is referred to as the "All Assets" group in the user interface. By default, Tenable.io grants all users in this access group both CAN VIEW and CAN SCAN permissions.
		AccessGroupType *N200AccessGroupType `json:"access_group_type,omitempty"`

		// Specifies whether the access group is the system-provided All Assets access group:
		//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /v2/access-groups/{id}](ref:io-v2-access-groups-edit) endpoint.
		//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
		AllAssets *bool `json:"all_assets,omitempty"`

		// The UUID of your Tenable.io instance.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// An ISO timestamp indicating the date and time on which the access group was created.
		CreatedAt *string `json:"created_at,omitempty"`

		// The name of the user who created the access group.
		CreatedByName *string `json:"created_by_name,omitempty"`

		// The UUID of the user who created the access group.
		CreatedByUuid *string `json:"created_by_uuid,omitempty"`

		// The UUID of the access group.
		Id *string `json:"id,omitempty"`

		// The name of the access group. This name must be:
		// * Unique within your Tenable.io instance.
		// * A maximum of 255 characters.
		// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
		Name *string `json:"name,omitempty"`

		// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
		Principals *[]struct {
			// (Required) The permissions associated with the principal of the access group as described in <a href="/docs/permissions">Permissions</a>.
			Permissions *N200PrincipalsPermissions `json:"permissions,omitempty"`

			// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
			PrincipalId *string `json:"principal_id,omitempty"`

			// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
			PrincipalName *string `json:"principal_name,omitempty"`

			// (Required) The type of principal. Valid values include:
			//  - all_usersGrants access to all users in your organization. That access includes `Can View` access to the assets defined in the rules parameter.
			//  - userGrants access to the user you specify.
			//  - groupGrants access to all users assigned to the user group you specify.
			Type *N200PrincipalsType `json:"type,omitempty"`
		} `json:"principals,omitempty"`

		// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
		ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

		// An array of asset rules. Tenable.io uses these rules to assign assets to the access group. You can specify a maximum of 1,000 rules for an individual access group. If you specify multiple rules for an access group, Tenable.io assigns an asset to the access group if the asset matches any of the rules. You can only add rules to access groups if the `all_assets` parameter is set to `false`.
		Rules *[]struct {
			// The operator that specifies how Tenable.io matches the terms value to asset data.
			//
			// Possible operators include:
			//  - eqTenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
			//  - matchTenable.io matches the rule to assets based a partial match of the specified term.
			//  - startsTenable.io matches the rule to assets that start with the specified term.
			//  - endsTenable.io matches the rule to assets that end with the specified term.
			//  - set-hasTenable.io matches the rule to assets based on the specified `tag_uuid`.
			//
			// For a complete list of operators by rule type, use the [GET /v2/access-groups/rules/filters](ref:io-v2-access-groups-list-rule-filters) endpoint.
			Operator *string `json:"operator,omitempty"`

			// The values that Tenable.io uses to match an asset to the rule. A term must correspond to the rule type.
			//
			// For example:
			//  - If the rule type is `aws_account`, the term is an AWS account ID.
			//  - If the rule type is `fqdn`, the term is a hostname or a fully-qualified domain name (FQDN).
			//  - If the rule type is `ipv4`, the term is an individual IPv4 address, a range of IPv4 addresses (for example, 192.0.2.57-192.0.2.60), or a CIDR range (for example, 192.0.2.57/24).
			//
			// For a complete list of supported values by rule type, use the [GET /v2/access-groups/rules/filters](ref:io-v2-access-groups-list-rule-filters) endpoint.
			//
			// If you specify multiple terms values, Tenable.io includes an asset in the access group if the asset's attributes match any of the terms in the rule.
			// <br >You can specify up to 100,000 terms per asset rule.
			Terms *[]string `json:"terms,omitempty"`

			// The type of asset rule. The asset rule type corresponds to the type of data you can specify in the `terms` parameter. For a complete list of supported rule types, use the [GET /v2/access-groups/filters](ref:io-v2-access-groups-list-filters) endpoint.
			Type *string `json:"type,omitempty"`
		} `json:"rules,omitempty"`

		// The status of the process evaluating and assigning assets to the access group. Possible values are:
		//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
		//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
		//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
		Status *string `json:"status,omitempty"`

		// An ISO timestamp indicating the time and date on which the access group was last modified.
		UpdatedAt *string `json:"updated_at,omitempty"`

		// The name of the user who last modified the access group.
		UpdatedByName *string `json:"updated_by_name,omitempty"`

		// The UUID of the user who last modified the access group.
		UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`

		// Optional, user-defined value. This value must be incremented each time an access group is updated. Set to `1` by default.
		Version *int `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoV2AccessGroupsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV2AccessGroupsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IoV2AccessGroupsEditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The type of access group. It can be one of three possible types:
		//  * MANAGE_ASSETSUsers in this access group can view the asset records created during previous scans and scan the associated targets for those assets.
		//  * SCAN_TARGETSUsers in this access group can scan targets associated with the access group and view the results of those scans. Targets may be associated with existing assets.
		//  * ALLThis access group type is only applicable to the default system-generated "All Assets" access group that contains all assets in your organization. This group is referred to as the "All Assets" group in the user interface. By default, Tenable.io grants all users in this access group both CAN VIEW and CAN SCAN permissions.
		AccessGroupType *N200AccessGroupType `json:"access_group_type,omitempty"`

		// Specifies whether the access group is the system-provided All Assets access group:
		//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /v2/access-groups/{id}](ref:io-v2-access-groups-edit) endpoint.
		//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
		AllAssets *bool `json:"all_assets,omitempty"`

		// The UUID of your Tenable.io instance.
		ContainerUuid *string `json:"container_uuid,omitempty"`

		// An ISO timestamp indicating the date and time on which the access group was created.
		CreatedAt *string `json:"created_at,omitempty"`

		// The name of the user who created the access group.
		CreatedByName *string `json:"created_by_name,omitempty"`

		// The UUID of the user who created the access group.
		CreatedByUuid *string `json:"created_by_uuid,omitempty"`

		// The UUID of the access group.
		Id *string `json:"id,omitempty"`

		// The name of the access group. This name must be:
		// * Unique within your Tenable.io instance.
		// * A maximum of 255 characters.
		// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
		Name *string `json:"name,omitempty"`

		// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
		Principals *[]struct {
			// (Required) The permissions associated with the principal of the access group as described in <a href="/docs/permissions">Permissions</a>.
			Permissions *N200PrincipalsPermissions `json:"permissions,omitempty"`

			// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
			PrincipalId *string `json:"principal_id,omitempty"`

			// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
			PrincipalName *string `json:"principal_name,omitempty"`

			// (Required) The type of principal. Valid values include:
			//  - all_usersGrants access to all users in your organization. That access includes `Can View` access to the assets defined in the rules parameter.
			//  - userGrants access to the user you specify.
			//  - groupGrants access to all users assigned to the user group you specify.
			Type *N200PrincipalsType `json:"type,omitempty"`
		} `json:"principals,omitempty"`

		// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
		ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

		// An array of asset rules. Tenable.io uses these rules to assign assets to the access group. You can specify a maximum of 1,000 rules for an individual access group. If you specify multiple rules for an access group, Tenable.io assigns an asset to the access group if the asset matches any of the rules. You can only add rules to access groups if the `all_assets` parameter is set to `false`.
		Rules *[]struct {
			// The operator that specifies how Tenable.io matches the terms value to asset data.
			//
			// Possible operators include:
			//  - eqTenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
			//  - matchTenable.io matches the rule to assets based a partial match of the specified term.
			//  - startsTenable.io matches the rule to assets that start with the specified term.
			//  - endsTenable.io matches the rule to assets that end with the specified term.
			//  - set-hasTenable.io matches the rule to assets based on the specified `tag_uuid`.
			//
			// For a complete list of operators by rule type, use the [GET /v2/access-groups/rules/filters](ref:io-v2-access-groups-list-rule-filters) endpoint.
			Operator *string `json:"operator,omitempty"`

			// The values that Tenable.io uses to match an asset to the rule. A term must correspond to the rule type.
			//
			// For example:
			//  - If the rule type is `aws_account`, the term is an AWS account ID.
			//  - If the rule type is `fqdn`, the term is a hostname or a fully-qualified domain name (FQDN).
			//  - If the rule type is `ipv4`, the term is an individual IPv4 address, a range of IPv4 addresses (for example, 192.0.2.57-192.0.2.60), or a CIDR range (for example, 192.0.2.57/24).
			//
			// For a complete list of supported values by rule type, use the [GET /v2/access-groups/rules/filters](ref:io-v2-access-groups-list-rule-filters) endpoint.
			//
			// If you specify multiple terms values, Tenable.io includes an asset in the access group if the asset's attributes match any of the terms in the rule.
			// <br >You can specify up to 100,000 terms per asset rule.
			Terms *[]string `json:"terms,omitempty"`

			// The type of asset rule. The asset rule type corresponds to the type of data you can specify in the `terms` parameter. For a complete list of supported rule types, use the [GET /v2/access-groups/filters](ref:io-v2-access-groups-list-filters) endpoint.
			Type *string `json:"type,omitempty"`
		} `json:"rules,omitempty"`

		// The status of the process evaluating and assigning assets to the access group. Possible values are:
		//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
		//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
		//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
		Status *string `json:"status,omitempty"`

		// An ISO timestamp indicating the time and date on which the access group was last modified.
		UpdatedAt *string `json:"updated_at,omitempty"`

		// The name of the user who last modified the access group.
		UpdatedByName *string `json:"updated_by_name,omitempty"`

		// The UUID of the user who last modified the access group.
		UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`

		// Optional, user-defined value. This value must be incremented each time an access group is updated. Set to `1` by default.
		Version *int `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IoV2AccessGroupsEditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IoV2AccessGroupsEditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportsVulnsRequestExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The UUID of the vulnerabilities export job.
		ExportUuid *string `json:"export_uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExportsVulnsRequestExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportsVulnsRequestExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportsVulnsExportStatusRecentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Exports *[]struct {
			// The total number of completed chunks available for download.
			ChunksAvailableCount *int `json:"chunks_available_count,omitempty"`

			// The Unix timestamp when the export job was created.
			Created *int `json:"created,omitempty"`

			// The total number of empty chunks.
			EmptyChunksCount *int `json:"empty_chunks_count,omitempty"`

			// The filters used in the export job request. For a list of possible filters, see the [POST /vulns/export](ref:exports-vulns-request-export) and [POST /assets/export](ref:exports-assets-request-export) endpoints.
			Filters *map[string]interface{} `json:"filters,omitempty"`

			// The number of chunks that have been processed and are available for download.
			FinishedChunks *int `json:"finished_chunks,omitempty"`

			// The number of assets contained in each export chunk.
			NumAssetsPerChunk *int `json:"num_assets_per_chunk,omitempty"`

			// The status of the export request. Possible values include:
			//  - QUEUEDTenable.io has queued the export request until it completes other requests currently in process.
			//  - PROCESSINGTenable.io has started processing the export request.
			//  - FINISHEDTenable.io has completed processing the export request. The list of chunks is complete.
			//  - CANCELLEDAn administrator has cancelled the export request.
			//  - ERRORTenable.io encountered an error while processing the export request. Tenable recommends that you retry the request. If the status persists on retry, contact Support.
			Status *string `json:"status,omitempty"`

			// The total number of chunks associated with the export job as a whole.
			TotalChunks *int `json:"total_chunks,omitempty"`

			// The UUID for the export request.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"exports,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExportsVulnsExportStatusRecentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportsVulnsExportStatusRecentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportsVulnsExportCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Text describing the export job status, `CANCELLED`.
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExportsVulnsExportCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportsVulnsExportCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportsVulnsDownloadChunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExportsVulnsDownloadChunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportsVulnsDownloadChunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportsVulnsExportStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Information about the export job.
		Status *struct {
			// A list of completed chunks available for download.
			ChunksAvailable *[]int32 `json:"chunks_available,omitempty"`

			// The total number of completed chunks available for download.
			ChunksAvailableCount *int `json:"chunks_available_count,omitempty"`

			// A list of chunks for which the export process was cancelled. If a chunk fails processing, Tenable.io automatically cancels all subsequent chunks queued for export in the same request.
			ChunksCancelled *[]int32 `json:"chunks_cancelled,omitempty"`

			// A list of chunks for which the export process failed. If a chunk fails processing, submit the export request again. If the chunk continues to fail, contact Support.
			ChunksFailed *[]int32 `json:"chunks_failed,omitempty"`

			// The Unix timestamp when the export job was created.
			Created *int `json:"created,omitempty"`

			// The total number of empty chunks.
			EmptyChunksCount *int `json:"empty_chunks_count,omitempty"`

			// The filters used in the export job request. For a list of possible filters, see the [POST /vulns/export](ref:exports-vulns-export-request-export) and [POST /assets/export](ref:exports-assets-request-export) endpoints.
			Filters *map[string]interface{} `json:"filters,omitempty"`

			// The number of chunks that have been processed and are available for download.
			FinishedChunks *int `json:"finished_chunks,omitempty"`

			// The number of assets contained in each export chunk.
			NumAssetsPerChunk *int `json:"num_assets_per_chunk,omitempty"`

			// The status of the export request. Possible values include:
			//  - QUEUEDTenable.io has queued the export request until it completes other requests currently in process.
			//  - PROCESSINGTenable.io has started processing the export request.
			//  - FINISHEDTenable.io has completed processing the export request. The list of chunks is complete.
			//  - CANCELLEDAn administrator has cancelled the export request.
			//  - ERRORTenable.io encountered an error while processing the export request. Tenable recommends that you retry the request. If the status persists on retry, contact Support.
			Status *string `json:"status,omitempty"`

			// The total number of chunks associated with the export job as a whole.
			TotalChunks *int `json:"total_chunks,omitempty"`

			// The UUID for the export request.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ExportsVulnsExportStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportsVulnsExportStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// An array of asset objects.
		Assets *[]struct {
			// The key drivers that Tenable uses to calculate an asset's Tenable-provided ACR. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			AcrDrivers *[]struct {
				// The type of characteristic.
				DriverName *string `json:"driver_name,omitempty"`

				// The characteristic value.
				DriverValue *[]string `json:"driver_value,omitempty"`
			} `json:"acr_drivers,omitempty"`

			// The Asset Criticality Rating (ACR) for the asset. Tenable assigns an ACR to each asset on your network to represent the asset's relative risk as an integer from 1 to 10. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			AcrScore *int `json:"acr_score,omitempty"`

			// The names of any Nessus agents that scanned and identified the asset.
			AgentName *[]string `json:"agent_name,omitempty"`

			// The name of the virtual machine instance in AWS EC2.
			AwsEc2Name *[]string `json:"aws_ec2_name,omitempty"`

			// The unique identifier of the asset in HCL BigFix. For more information, see the HCL BigFix documentation.
			BigfixAssetId *[]string `json:"bigfix_asset_id,omitempty"`

			// The Asset Exposure Score (AES) for the asset. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			ExposureScore *int `json:"exposure_score,omitempty"`

			// A list of fully-qualified domain names (FQDNs) for the asset.
			Fqdn *[]string `json:"fqdn,omitempty"`

			// A value specifying whether a Nessus agent scan detected the asset (`true`).
			HasAgent *bool `json:"has_agent,omitempty"`

			// The UUID of the asset.
			Id *string `json:"id,omitempty"`

			// A list of ipv4 addresses for the asset.
			Ipv4 *[]string `json:"ipv4,omitempty"`

			// A list of ipv6 addresses for the asset.
			Ipv6 *[]string `json:"ipv6,omitempty"`

			// The IPv4 address, IPv6 address, or FQDN that the scanner last used to evaluate the asset.
			LastScanTarget *string `json:"last_scan_target,omitempty"`

			// The ISO timestamp of the scan that most recently detected the asset.
			LastSeen *string `json:"last_seen,omitempty"`

			// A list of MAC addresses for the asset.
			MacAddress *[]string `json:"mac_address,omitempty"`

			// The NetBIOS name for the asset.
			NetbiosName *[]string `json:"netbios_name,omitempty"`

			// The operating system installed on the asset.
			OperatingSystem *[]string `json:"operating_system,omitempty"`

			// Information about how often scans ran against the asset during specified intervals. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			ScanFrequency *[]struct {
				// The number of times that a scan ran against the asset during the specified interval.
				Frequency *int `json:"frequency,omitempty"`

				// The number of days over which Tenable searches for scans involving the asset.
				Interval *int `json:"interval,omitempty"`

				// Indicates whether the asset was licensed at the time of the identified scans.
				Licensed *bool `json:"licensed,omitempty"`
			} `json:"scan_frequency,omitempty"`

			// A list of sources for the asset record.
			Sources *[]struct {
				// The ISO timestamp when the source first reported the asset.
				FirstSeen *string `json:"first_seen,omitempty"`

				// The ISO timestamp when the source last reported the asset.
				LastSeen *string `json:"last_seen,omitempty"`

				// The name of the entity that reported the asset details. Sources can include sensors, connectors, and API imports. Source names can be customized by your organization (for example, you specify a name when you import asset records). If your organization does not customize source names, system-generated names include:
				//  - AWSYou obtained the asset data from an Amazon Web Services connector.
				//  - NESSUS_AGENTYou obtained the asset data obtained from a Nessus agent scan.
				//  - PVSYou obtained the asset data from a Nessus Network Monitor (NNM) scan.
				//  - NESSUS_SCANYou obtained the asset data from a Nessus scan.
				//  - WASYou obtained the asset data from a  Web Application Scanning scan.
				Name *string `json:"name,omitempty"`
			} `json:"sources,omitempty"`
		} `json:"assets,omitempty"`

		// The total count of returned assets.
		Total *int `json:"total,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesAssetsVulnerabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// The names of any Nessus agents that scanned and identified the asset.
		AgentName *[]string `json:"agent_name,omitempty"`

		// A list of fully-qualified domain names (FQDNs) for the asset.
		Fqdn *[]string `json:"fqdn,omitempty"`

		// The UUID of the asset.
		Id *string `json:"id,omitempty"`

		// A list of ipv4 addresses for the asset.
		Ipv4 *[]string `json:"ipv4,omitempty"`

		// A list of ipv6 addresses for the asset.
		Ipv6 *[]string `json:"ipv6,omitempty"`

		// The ISO timestamp of the scan that most recently detected the asset.
		LastSeen *string `json:"last_seen,omitempty"`

		// The NetBIOS name for the asset.
		NetbiosName *[]string `json:"netbios_name,omitempty"`

		// A count of vulnerabilities by severity.
		Severities *[]struct {
			// The number of vulnerabilities with the specified severity.
			Count *int `json:"count,omitempty"`

			// The code for the severity. Possible values include:
			//  - 0The vulnerability has a CVSS score of 0, which corresponds to the "info" severity level.
			//  - 1The vulnerability has a CVSS score between 0.1 and 3.9, which corresponds to the "low" severity level.
			//  - 2The vulnerability has a CVSS score between 4.0 and 6.9, which corresponds to the "medium" severity level.
			//  - 3The vulnerability has a CVSS score between 7.0 and 9.9, which corresponds to the "high" severity level.
			//  - 4The vulnerability has a CVSS score of 10.0, which corresponds to the "critical" severity level.
			Level *int `json:"level,omitempty"`

			// The severity of the vulnerability as defined using the Common Vulnerability Scoring System (CVSS) base score. Possible values include `info` (CVSS score of 0), `low` (CVSS score between 0.1 and 3.9), `medium` (CVSS score between 4.0 and 6.9), `high` (CVSS score between 7.0 and 9.9), and `critical` (CVSS score of 10.0).
			Name *string `json:"name,omitempty"`
		} `json:"severities,omitempty"`

		// The total number of vulnerabilities detected on the asset.
		Total *int `json:"total,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesAssetsVulnerabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesAssetsVulnerabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesAssetInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Info *struct {
			// The key drivers that Tenable uses to calculate an asset's Tenable-provided ACR. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			AcrDrivers *[]struct {
				// The type of characteristic.
				DriverName *string `json:"driver_name,omitempty"`

				// The characteristic value.
				DriverValue *[]string `json:"driver_value,omitempty"`
			} `json:"acr_drivers,omitempty"`

			// The Asset Criticality Rating (ACR) for the asset. Tenable assigns an ACR to each asset on your network to represent the asset's relative risk as an integer from 1 to 10. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			AcrScore *int `json:"acr_score,omitempty"`

			// The names of any Nessus agents that scanned and identified the asset.
			AgentName *[]string `json:"agent_name,omitempty"`

			// The availability zone where Amazon Web Services hosts the virtual machine instance, for example, `us-east-1a`. Availability zones are subdivisions of AWS regions. For more information, see Regions and Availability Zones in the AWS documentation.
			AwsAvailabilityZone *[]string `json:"aws_availability_zone,omitempty"`

			// The unique identifier of the Linux AMI image in Amazon Elastic Compute Cloud (Amazon EC2). For more information, see the Amazon Elastic Compute Cloud Documentation.
			AwsEc2InstanceAmiId *[]string `json:"aws_ec2_instance_ami_id,omitempty"`

			// The virtual machine instance's group in AWS.
			AwsEc2InstanceGroupName *[]string `json:"aws_ec2_instance_group_name,omitempty"`

			// The unique identifier of the Linux instance in Amazon EC2. For more information, see the Amazon Elastic Compute Cloud Documentation.
			AwsEc2InstanceId *[]string `json:"aws_ec2_instance_id,omitempty"`

			// The state of the virtual machine instance in AWS at the time of the scan. For more information on instance states, see the AWS documentation.
			AwsEc2InstanceStateName *[]string `json:"aws_ec2_instance_state_name,omitempty"`

			// The type of instance in AWS EC2.
			AwsEc2InstanceType *[]string `json:"aws_ec2_instance_type,omitempty"`

			// The name of the virtual machine instance in AWS EC2.
			AwsEc2Name *[]string `json:"aws_ec2_name,omitempty"`

			// The product code associated with the AMI used to launch the virtual machine instance in AWS EC2.
			AwsEc2ProductCode *[]string `json:"aws_ec2_product_code,omitempty"`

			// The canonical user identifier for the AWS account associated with the virtual machine instance. For example, `79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be`. For more information, see AWS Account Identifiers in the AWS documentation.
			AwsOwnerId *[]string `json:"aws_owner_id,omitempty"`

			// The region where AWS hosts the virtual machine instance, for example, `us-east-1`. For more information, see Regions and Availability Zones in the AWS documentation.
			AwsRegion *[]string `json:"aws_region,omitempty"`

			// The unique identifier of the AWS subnet where the virtual machine instance was running at the time of the scan.
			AwsSubnetId *[]string `json:"aws_subnet_id,omitempty"`

			// The unique identifier for the public cloud that hosts the AWS virtual machine instance. For more information, see the Amazon Virtual Private Cloud User Guide.
			AwsVpcId *[]string `json:"aws_vpc_id,omitempty"`

			// The unique identifier of the resource in the Azure Resource Manager. For more information, see the Azure Resource Manager Documentation.
			AzureResourceId *[]string `json:"azure_resource_id,omitempty"`

			// The unique identifier of the Microsoft Azure virtual machine instance. For more information, see "Accessing and Using Azure VM Unique ID" in the Microsoft Azure documentation.
			AzureVmId *[]string `json:"azure_vm_id,omitempty"`

			// The BIOS UUID that scans have associated with the asset.
			BiosUuid *[]string `json:"bios_uuid,omitempty"`

			// Counts of vulnerabilities on the asset, as well as counts of audit checks performed on the asset. For more information about this object, see [Common Asset Attributes](doc:common-asset-attributes).
			Counts *map[string]interface{} `json:"counts,omitempty"`

			// The time and date when Tenable.io created the asset record.
			CreatedAt *string `json:"created_at,omitempty"`

			// The Asset Exposure Score (AES) for the asset. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			ExposureScore *int `json:"exposure_score,omitempty"`

			// The time and date when a scan first identified the asset.
			FirstSeen *string `json:"first_seen,omitempty"`

			// The fully-qualified domain names that scans have associated with the asset record.
			Fqdn *[]string `json:"fqdn,omitempty"`

			// The unique identifier of the virtual machine instance in GCP.
			GcpInstanceId *[]string `json:"gcp_instance_id,omitempty"`

			// The customized name of the project to which the virtual machine instance belongs in Google Cloud Platform (GCP). For more information, see "Creating and Managing Projects" in the GCP documentation.
			GcpProjectId *[]string `json:"gcp_project_id,omitempty"`

			// The zone where the virtual machine instance runs in GCP. For more information, see "Regions and Zones" in the GCP documentation.
			GcpZone *[]string `json:"gcp_zone,omitempty"`

			// A value specifying whether a Nessus agent scan detected the asset.
			HasAgent *bool `json:"has_agent,omitempty"`

			// The hostnames that scans have associated with the asset record.
			Hostname *[]string `json:"hostname,omitempty"`

			// The UUID of the asset.
			Id *string `json:"id,omitempty"`

			// A list of Common Platform Enumeration (CPE) values that represent software applications a scan identified as present on an asset. This attribute supports the CPE 2.2 format. For more information, see the "Component Syntax" section of the [CPE Specification, Version 2.2](https://cpe.mitre.org/files/cpe-specification_2.2.pdf). For assets identified in Tenable scans, this attribute contains data only if a scan using [Nessus Plugin ID 45590](https://www.tenable.com/plugins/nessus/45590) has evaluated the asset.
			//
			// **Note:** If no scan detects an application within 30 days of the scan that originally detected the application, Tenable.io considers the detection of that application expired. As a result, the next time a scan evaluates the asset, Tenable.io removes the expired application from the installed_software attribute. This activity is logged as a `remove` type of `attribute_change` update in the asset activity log.
			InstalledSoftware *[]string `json:"installed_software,omitempty"`

			// The IPv4 addresses that scans have associated with the asset record.
			Ipv4 *[]string `json:"ipv4,omitempty"`

			// The IPv6 addresses that scans have associated with the asset record.
			Ipv6 *[]string `json:"ipv6,omitempty"`

			// The time and date of the last credentialed scan run on the asset.
			LastAuthenticatedScanDate *string `json:"last_authenticated_scan_date,omitempty"`

			// The time and date of the last scan that identified the asset as licensed. Tenable.io categorizes an asset as licensed if a scan of that asset has returned results from a non-discovery plugin within the last 90 days.
			LastLicensedScanDate *string `json:"last_licensed_scan_date,omitempty"`

			// The IPv4 address, IPv6 address, or FQDN that the scanner last used to evaluate the asset.
			LastScanTarget *string `json:"last_scan_target,omitempty"`

			// The time and date of the scan that most recently identified the asset.
			LastSeen *string `json:"last_seen,omitempty"`

			// The MAC addresses that scans have associated with the asset record.
			MacAddress *[]string `json:"mac_address,omitempty"`

			// The unique identifier of the McAfee ePO agent that identified the asset. For more information, see the McAfee documentation.
			McafeeEpoAgentGuid *[]string `json:"mcafee_epo_agent_guid,omitempty"`

			// The unique identifier of the asset in McAfee ePolicy Orchestrator (ePO). For more information, see the McAfee documentation.
			McafeeEpoGuid *[]string `json:"mcafee_epo_guid,omitempty"`

			// The NetBIOS names that scans have associated with the asset record.
			NetbiosName *[]string `json:"netbios_name,omitempty"`

			// The operating systems that scans have associated with the asset record.
			OperatingSystem *[]string `json:"operating_system,omitempty"`

			// The Asset ID of the asset in Qualys. For more information, see the Qualys documentation.
			QualysAssetId *[]string `json:"qualys_asset_id,omitempty"`

			// The Host ID of the asset in Qualys. For more information, see the Qualys documentation.
			QualysHostId *[]string `json:"qualys_host_id,omitempty"`

			// Information about how often scans ran against the asset during specified intervals. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			ScanFrequency *[]struct {
				// The number of times that a scan ran against the asset during the specified interval.
				Frequency *int `json:"frequency,omitempty"`

				// The number of days over which Tenable searches for scans involving the asset.
				Interval *int `json:"interval,omitempty"`

				// Indicates whether the asset was licensed at the time of the identified scans.
				Licensed *bool `json:"licensed,omitempty"`
			} `json:"scan_frequency,omitempty"`

			// The unique record identifier of the asset in ServiceNow. For more information, see the ServiceNow documentation.
			ServicenowSysid *[]string `json:"servicenow_sysid,omitempty"`

			// The sources of the scans that identified the asset.
			Sources *[]struct {
				// The ISO timestamp when the source first reported the asset.
				FirstSeen *string `json:"first_seen,omitempty"`

				// The ISO timestamp when the source last reported the asset.
				LastSeen *string `json:"last_seen,omitempty"`

				// The name of the entity that reported the asset details. Sources can include sensors, connectors, and API imports. Source names can be customized by your organization (for example, you specify a name when you import asset records). If your organization does not customize source names, system-generated names include:
				//  - AWSYou obtained the asset data from an Amazon Web Services connector.
				//  - NESSUS_AGENTYou obtained the asset data obtained from a Nessus agent scan.
				//  - PVSYou obtained the asset data from a Nessus Network Monitor (NNM) scan.
				//  - NESSUS_SCANYou obtained the asset data from a Nessus scan.
				//  - WASYou obtained the asset data from a  Web Application Scanning scan.
				Name *string `json:"name,omitempty"`
			} `json:"sources,omitempty"`

			// The SSH key fingerprints that scans have associated with the asset record.
			SshFingerprint *[]string `json:"ssh_fingerprint,omitempty"`

			// The system types as reported by Plugin ID 54615. Possible values include `router`, `general-purpose`, `scan-host`, and `embedded`.
			SystemType *[]string `json:"system_type,omitempty"`

			// Category tags assigned to the asset in Tenable.io.
			Tags *[]struct {
				// The ISO timestamp when the tag was assigned to the asset.
				AddedAt *string `json:"added_at,omitempty"`

				// The UUID of the user who assigned the tag to the asset.
				AddedBy *string `json:"added_by,omitempty"`

				// The tag type:
				//  - staticA user manually applied the tag to an asset. You can use the Tenable.io API to create and assign static tags to assets.
				//  - dynamicTenable.io automatically applies the tag based on asset attribute rules. For more information, see [Apply Dynamic Tags](doc:apply-dynamic-tags).
				Source *string `json:"source,omitempty"`

				// The tag category (the first half of the category:value pair).
				TagKey *string `json:"tag_key,omitempty"`

				// The UUID of the tag.
				TagUuid *string `json:"tag_uuid,omitempty"`

				// The tag value (the second half of the category:value pair).
				TagValue *string `json:"tag_value,omitempty"`
			} `json:"tags,omitempty"`

			// The UUID of the agent if an agent is present on the asset. If no agent is present on the asset, then the UUID is a unique identifier assigned by Tenable.io during a credentialed scan when the [Create unique identifier on hosts scanned with credentials](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/Classic/AdvancedSettings.htm) option is enabled. Note that no UUID is set for uncredentialed, non-agent scans.
			TenableUuid *[]string `json:"tenable_uuid,omitempty"`

			// The scan end timestamp, in ISO-8601 format, when the asset was first detected.
			TimeEnd *string `json:"time_end,omitempty"`

			// The scan start timestamp, in ISO-8601 format, when the asset was first detected.
			TimeStart *string `json:"time_start,omitempty"`

			// The time and date when the asset record was last updated.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The UUID of the asset. Use this value as the unique key for the asset.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"info,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesAssetInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesAssetInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesAssetVulnerabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The total number of assets.
		TotalAssetCount *int `json:"total_asset_count,omitempty"`

		// The total number of discovered vulnerabilities.
		TotalVulnerabilityCount *int `json:"total_vulnerability_count,omitempty"`

		// A list of discovered vulnerabilities.
		Vulnerabilities *[]struct {
			// The number of times that a user in the user interface created an accept rule for this vulnerability. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/AboutRecastRules.htm" target="_blank">Recast Rules</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
			AcceptedCount *int32 `json:"accepted_count,omitempty"`

			// The number of times that a scan detected the vulnerability on an asset.
			Count *int `json:"count,omitempty"`

			// The number of times that a scan detected the vulnerability on an asset, grouped by severity level.
			CountsBySeverity *[]struct {
				// The number of times that a scan detected the vulnerability on an asset while the vulnerability was assigned the specified severity level.
				Count *int32 `json:"count,omitempty"`

				// The severity level of the vulnerabilities in the group.
				Value *int `json:"value,omitempty"`
			} `json:"counts by severity,omitempty"`

			// The plugin's family.
			PluginFamily *string `json:"plugin_family,omitempty"`

			// The unique plugin ID.
			PluginId *int `json:"plugin_id,omitempty"`

			// The name of the plugin that detected the vulnerability.
			PluginName *string `json:"plugin_name,omitempty"`

			// The number of times that a user in the user interface created a recast rule for this vulnerability. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/AboutRecastRules.htm" target="_blank">Recast Rules</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
			RecastedCount *int32 `json:"recasted_count,omitempty"`

			// The severity level of the vulnerability, as defined using the Common Vulnerability Scoring System (CVSS) base score. Possible values include:
			//  - 0The vulnerability has a CVSS score of 0, which corresponds to the "info" severity level.
			//  - 1The vulnerability has a CVSS score between 0.1 and 3.9, which corresponds to the "low" severity level.
			//  - 2The vulnerability has a CVSS score between 4.0 and 6.9, which corresponds to the "medium" severity level.
			//  - 3The vulnerability has a CVSS score between 7.0 and 9.9, which corresponds to the "high" severity level.
			//  - 4The vulnerability has a CVSS score of 10.0, which corresponds to the "critical" severity level.
			Severity *int32 `json:"severity,omitempty"`

			// The Vulnerability Priority Rating (VPR) for the vulnerability. If a plugin is designed to detect multiple vulnerabilities, the VPR represents the highest value calculated for a vulnerability associated with the plugin. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/RiskMetrics.htm" target="_blank">Severity vs. VPR</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
			VprScore *float32 `json:"vpr_score,omitempty"`

			// The current state of the reported plugin. Possible states include:
			//  - ActiveThe vulnerability is currently present on an asset.
			//  - NewThe vulnerability is active on an asset, and was first detected within the last 14 days.
			//  - FixedA subsequent scan detected that the formerly-active vulnerability is no longer present on an asset.
			//  - ResurfacedThe vulnerability was previously marked as fixed on an asset, but a subsequent scan detected the vulnerability on the asset again.
			VulnerabilityState *string `json:"vulnerability_state,omitempty"`
		} `json:"vulnerabilities,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesAssetVulnerabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesAssetVulnerabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesAssetVulnerabilityInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Info *struct {
			// A count of the vulnerability occurrences.
			Count *int32 `json:"count,omitempty"`

			// The description of the vulnerability.
			Description *string `json:"description,omitempty"`
			Discovery   *struct {
				// The Unix timestamp of the scan that first detected the vulnerability on an asset.
				SeenFirst *string `json:"seen_first,omitempty"`

				// The Unix timestamp of the scan that most recently detected the vulnerability on an asset.
				SeenLast *string `json:"seen_last,omitempty"`
			} `json:"discovery,omitempty"`
			PluginDetails *struct {
				// The plugin family.
				Family *string `json:"family,omitempty"`

				// The ISO timestamp when Tenable last updated the plugin definition.
				ModificationDate *string `json:"modification_date,omitempty"`

				// The name of the plugin.
				Name *string `json:"name,omitempty"`

				// The ISO timestamp when Tenable first published the plugin definition.
				PublicationDate *string `json:"publication_date,omitempty"`

				// The severity level of the plugin.
				Severity *int32 `json:"severity,omitempty"`

				// The type of scan that uses the plugin, either a network scan (`remote`) or a credentialed scan (`local`).
				Type *string `json:"type,omitempty"`

				// The plugin version.
				Version *string `json:"version,omitempty"`
			} `json:"plugin_details,omitempty"`
			ReferenceInformation *[]struct {
				// The source of the reference information about the vulnerability. Possible values include:
				//  - bidBugtraq (Symantec Connect)
				//  - certCERT/CC Vulnerability Notes Database
				//  - cveNIST National Vulnerability Database (NVD)
				//  - edb-idThe Exploit Database
				//  - iavainformation assurance vulnerability alert
				//  - osvdbOpen Sourced Vulnerability Database
				Name *string `json:"name,omitempty"`

				// The URL of the source site, if available.
				Url *string `json:"url,omitempty"`

				// The unique identifier(s) for the vulnerability at the source.
				Values *[]string `json:"values,omitempty"`
			} `json:"reference_information,omitempty"`
			RiskInformation *struct {
				// The CVSSv3 base score (intrinsic and fundamental characteristics of a vulnerability that are constant over time and user environments).
				Cvss3BaseScore *string `json:"cvss3_base_score,omitempty"`

				// The CVSSv3 temporal score (characteristics of a vulnerability that change over time but not among user environments).
				Cvss3TemporalScore *string `json:"cvss3_temporal_score,omitempty"`

				// CVSSv3 temporal metrics for the vulnerability.
				Cvss3TemporalVector *string `json:"cvss3_temporal_vector,omitempty"`

				// The raw CVSSv3 metrics for the vulnerability. For more information, see CVSSv3 documentation.
				Cvss3Vector *string `json:"cvss3_vector,omitempty"`

				// The CVSSv2 base score (intrinsic and fundamental characteristics of a vulnerability that are constant over time and user environments).
				CvssBaseScore *string `json:"cvss_base_score,omitempty"`

				// The CVSSv2 temporal score (characteristics of a vulnerability that change over time but not among user environments).
				CvssTemporalScore *string `json:"cvss_temporal_score,omitempty"`

				// The raw CVSSv2 temporal metrics for the vulnerability.
				CvssTemporalVector *string `json:"cvss_temporal_vector,omitempty"`

				// The raw CVSSv2 metrics for the vulnerability. For more information, see CVSSv2 documentation.
				CvssVector *string `json:"cvss_vector,omitempty"`

				// The risk factor associated with the plugin. Possible values are: `Low`, `Medium`, `High`, or `Critical`. See the `risk_factor` attribute in [Tenable Plugin Attributes](doc:tenable-plugin-attributes).
				RiskFactor *string `json:"risk_factor,omitempty"`

				// Security Technical Implementation Guide (STIG) severity code for the vulnerability.
				StigSeverity *string `json:"stig_severity,omitempty"`
			} `json:"risk_information,omitempty"`

			// Links to external websites that contain helpful information about the vulnerability.
			SeeAlso *[]string `json:"see_also,omitempty"`

			// The severity level of the vulnerability.
			Severity *int `json:"severity,omitempty"`

			// Information on how to fix the vulnerability.
			Solution *string `json:"solution,omitempty"`

			// A brief summary of the vulnerability.
			Synopsis *string `json:"synopsis,omitempty"`

			// Information about the Vulnerability Priority Rating (VPR) for the vulnerability.
			Vpr *struct {
				// The key drivers Tenable uses to calculate a vulnerability's VPR. For more information, see <[Vulnerability Priority Rating Drivers](doc:vpr-drivers-tio).
				Drivers *map[string]interface{} `json:"drivers,omitempty"`

				// The Vulnerability Priority Rating (VPR) for the vulnerability. If a plugin is designed to detect multiple vulnerabilities, the VPR represents the highest value calculated for a vulnerability associated with the plugin. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/RiskMetrics.htm" target="_blank">Severity vs. VPR</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
				Score *float32 `json:"score,omitempty"`

				// The ISO timestamp when Tenable.io last imported the VPR for this vulnerability. Tenable.io imports a VPR value the first time you scan a vulnerability on your network. Then, Tenable.io automatically re-imports new and updated VPR values daily.
				Updated *string `json:"updated,omitempty"`
			} `json:"vpr,omitempty"`
			VulnCount                *int32 `json:"vuln_count,omitempty"`
			VulnerabilityInformation *struct {
				AssetInventory *string `json:"asset_inventory,omitempty"`

				// The Common Platform Enumeration (CPE) number for the plugin.
				Cpe            *string `json:"cpe,omitempty"`
				DefaultAccount *string `json:"default_account,omitempty"`

				// A value specifying whether a public exploit exists for the vulnerability.
				ExploitAvailable *bool `json:"exploit_available,omitempty"`

				// A list of exploit frameworks that have identified the vulnerability.
				ExploitFrameworks *[]struct {
					// A list of exploits associated with the vulnerability in the specified exploit framework.
					Exploits *[]struct {
						// The name of the identified exploit.
						Name *string `json:"name,omitempty"`

						// The URL for the exploit in the framework.
						Url *string `json:"url,omitempty"`
					} `json:"exploits,omitempty"`

					// The name of the exploit framework.
					Name *string `json:"name,omitempty"`
				} `json:"exploit_frameworks,omitempty"`

				// Description of how easy it is to exploit the issue.
				ExploitabilityEase *string `json:"exploitability_ease,omitempty"`

				// The vulnerability discovered by this plugin is known to be exploited by malware.
				ExploitedByMalware *bool `json:"exploited_by_malware,omitempty"`

				// A value specifying whether Nessus exploited the vulnerability during the process of identification.
				ExploitedByNessus *bool `json:"exploited_by_nessus,omitempty"`

				// A value specifying whether this plugin has received media attention (for example, ShellShock, Meltdown).
				InTheNews *bool   `json:"in_the_news,omitempty"`
				Malware   *string `json:"malware,omitempty"`

				// The ISO timestamp for date on which the vendor published a patch for the vulnerability.
				PatchPublicationDate *string `json:"patch_publication_date,omitempty"`

				// Software found by this plugin is unsupported by the software's vendor (for example, Windows 95 or Firefox 3).
				UnsupportedByVendor *bool `json:"unsupported_by_vendor,omitempty"`

				// The ISO timestamp for the first publication date of the plugin.
				VulnerabilityPublicationDate *string `json:"vulnerability_publication_date,omitempty"`
			} `json:"vulnerability_information,omitempty"`
		} `json:"info,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesAssetVulnerabilityInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesAssetVulnerabilityInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesAssetVulnerabilityOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A list of vulnerabilities discovered by the plugin.
		Outputs *[]struct {
			// The plugin's output about the vulnerability. May be an empty string.
			PluginOutput *string `json:"plugin_output,omitempty"`

			// Vulnerability state items.
			States *[]struct {
				// The current state of the reported plugin (Active, Fixed, New, etc.)
				Name    *string `json:"name,omitempty"`
				Results *[]struct {
					// The application protocol where this vulnerability was found.
					ApplicationProtocol *string `json:"application_protocol,omitempty"`

					// A list of assets where this output was found.
					Assets *[]struct {
						// Indicates when the asset was discovered by a scan.
						FirstSeen *time.Time `json:"first_seen,omitempty"`

						// The FQDN of the asset.
						Fqdn *string `json:"fqdn,omitempty"`

						// The host name of the asset.
						Hostname *string `json:"hostname,omitempty"`

						// The ID of the asset.
						Id *string `json:"id,omitempty"`

						// The IPV4 of the asset.
						Ipv4 *string `json:"ipv4,omitempty"`

						// Indicates when the asset was last observed by a scan.
						LastSeen *time.Time `json:"last_seen,omitempty"`

						// The NetBios name of the asset.
						NetbiosName *string `json:"netbios_name,omitempty"`

						// The UUID of the asset. Use this value as the unique key for the asset.
						Uuid *string `json:"uuid,omitempty"`
					} `json:"assets,omitempty"`

					// The port number where this vulnerability was found.
					Port *int `json:"port,omitempty"`

					// Integer [0-4] indicating how severe the vulnerability is, where 0 is info only.
					Severity *int `json:"severity,omitempty"`

					// The transportation protocol (TCP or UDP) where this vulnerability was found.
					TransportProtocol *string `json:"transport_protocol,omitempty"`
				} `json:"results,omitempty"`
			} `json:"states,omitempty"`
		} `json:"outputs,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesAssetVulnerabilityOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesAssetVulnerabilityOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesAssetsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *interface{}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesAssetsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesAssetsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesAssetsActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Details *struct {
			// The UUID of the asset.
			AssetId *string `json:"assetId,omitempty"`

			// The UUID of your Tenable.io instance.
			ContainerId *string `json:"containerId,omitempty"`

			// The timestamp of the asset creation. The timestamp is reported in ISO 8601 format in UTC time.
			CreatedAt *int `json:"createdAt,omitempty"`

			// If deleted, the timestamp of asset deletion. The timestamp is reported in ISO 8601 format in UTC time.
			DeletedAt *int `json:"deletedAt,omitempty"`

			// The UUID of the user that deleted the asset.
			DeletedBy *string `json:"deletedBy,omitempty"`

			// The timestamp of the completion of the scan that discovered or observed the asset for the first time. The timestamp is reported in ISO 8601 format in UTC time.
			FirstScanTime *int `json:"firstScanTime,omitempty"`

			// Specifies whether the asset has an agent installed.
			HasAgent *bool `json:"hasAgent,omitempty"`

			// Specifies whether or not any plugin results match this asset.
			HasPluginResults *bool `json:"hasPluginResults,omitempty"`

			// The timestamp of the completion of the last authenticated scan of the asset. The timestamp is reported in ISO 8601 format in UTC time.
			LastAuthenticatedScanTime *int `json:"lastAuthenticatedScanTime,omitempty"`

			// The timestamp of the scan completion time when asset was last scanned and matched license v1 requirements. The timestamp is reported in ISO 8601 format in UTC time.
			LastLicensedScanTime *int `json:"lastLicensedScanTime,omitempty"`

			// The timestamp of the scan completion time when asset was last scanned and matched license v2 requirements. The timestamp is reported in ISO 8601 format in UTC time.
			LastLicensedScanTimeV2 *int `json:"lastLicensedScanTimeV2,omitempty"`

			// The timestamp of the completion of the last asset scan. The timestamp is reported in ISO 8601 format in UTC time.
			LastScanTime *int `json:"lastScanTime,omitempty"`

			// Additional asset attributes. For attribute definitions, see [Common Asset Attributes](doc:common-asset-attributes).
			Properties *map[string]interface{} `json:"properties,omitempty"`

			// An array of source objects representing the entity that logged the event.
			Sources *[]struct {
				// The ISO timestamp when the source first reported the asset.
				FirstSeen *string `json:"firstSeen,omitempty"`

				// The ISO timestamp when the source last reported the asset.
				LastSeen *string `json:"lastSeen,omitempty"`

				// The name of the entity that reported the asset details. Sources can include sensors, connectors, and API imports. Source names can be customized by your organization (for example, you specify a name when you import asset records). If your organization does not customize source names, system-generated names include:
				//  - AWSYou obtained the asset data from an Amazon Web Services connector.
				//  - NESSUS_AGENTYou obtained the asset data obtained from a Nessus agent scan.
				//  - PVSYou obtained the asset data from a Nessus Network Monitor (NNM) scan.
				//  - NESSUS_SCANYou obtained the asset data from a Nessus scan.
				//  - WASYou obtained the asset data from a  Web Application Scanning scan.
				Name *string `json:"name,omitempty"`
			} `json:"sources,omitempty"`

			// If terminated, the timestamp of asset termination. The timestamp is reported in ISO 8601 format in UTC time.
			TerminatedAt *int `json:"terminatedAt,omitempty"`

			// The UUID of the user that terminated the asset.
			TerminatedBy *string `json:"terminatedBy,omitempty"`

			// The timestamp of the asset update time. The timestamp is reported in ISO 8601 format in UTC time.
			UpdatedAt *int `json:"updatedAt,omitempty"`
		} `json:"details,omitempty"`

		// The UUID of the scan that logged the event.
		ScanId *string `json:"scan_id,omitempty"`

		// The ID of the scheduled scan associated with the event.
		ScheduleId *string `json:"schedule_id,omitempty"`

		// The entity that logged the event, for example, NESSUS_AGENT, NESSUS_AGENT, PVS, or WAS.
		Source *string `json:"source,omitempty"`

		// The timestamp of the event. The timestamp is reported in ISO 8601 format in UTC time.
		Timestamp *int `json:"timestamp,omitempty"`

		// Event type:
		//  - discoveredAsset created (for example, by a network scan or import).
		//  - seenAsset observed by a network scan without any changes to its attributes.
		//  - taggingTag added to or removed from asset.
		//  - attribute_changeA scan identified new or changed attributes for the asset (for example, new software applications installed on the asset).
		//  - updatedAsset updated either manually by a user or automatically by a new scan.
		Type *string `json:"type,omitempty"`

		// (attribute_change entries only) A list of updates to the asset's attributes.
		Updates *[]struct {
			// The update method. Possible values include:
			//  - addA scan identified a new software application installed on the asset.
			//  - removeTenable.io identified the specified application as expired and removed it from the installed_software attribute of the asset. Tenable.io considers an application detection expired if no scan detects the application within 30 days of the scan that originally detected the application.
			Method *string `json:"method,omitempty"`

			// The name of the updated attribute.
			Property *string `json:"property,omitempty"`

			// The updated value of the attribute.
			Value *string `json:"value,omitempty"`
		} `json:"updates,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesAssetsActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesAssetsActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesExportRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The ID of the generated file.
		File *int `json:"file,omitempty"`
	}
	JSON400 *struct {
		// Standard HTTP error name, or a brief message about the cause of the error.
		Error *string `json:"error,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesExportRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesExportRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesExportDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WorkbenchesExportDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesExportDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesExportStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The number of already processed items.
		Progress *string `json:"progress,omitempty"`

		// The total number of items included in export.
		ProgressTotal *string `json:"progress_total,omitempty"`

		// The export processing status, for example, READY or LOADING.
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesExportStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesExportStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesVulnerabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// The total number of assets.
		TotalAssetCount *int `json:"total_asset_count,omitempty"`

		// The total number of discovered vulnerabilities.
		TotalVulnerabilityCount *int `json:"total_vulnerability_count,omitempty"`

		// A list of discovered vulnerabilities.
		Vulnerabilities *[]struct {
			// The number of times that a user in the user interface created an accept rule for this vulnerability. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/AboutRecastRules.htm" target="_blank">Recast Rules</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
			AcceptedCount *int32 `json:"accepted_count,omitempty"`

			// The number of times that a scan detected the vulnerability on an asset.
			Count *int `json:"count,omitempty"`

			// The number of times that a scan detected the vulnerability on an asset, grouped by severity level.
			CountsBySeverity *[]struct {
				// The number of times that a scan detected the vulnerability on an asset while the vulnerability was assigned the specified severity level.
				Count *int32 `json:"count,omitempty"`

				// The severity level of the vulnerabilities in the group.
				Value *int `json:"value,omitempty"`
			} `json:"counts by severity,omitempty"`

			// The plugin's family.
			PluginFamily *string `json:"plugin_family,omitempty"`

			// The unique plugin ID.
			PluginId *int `json:"plugin_id,omitempty"`

			// The name of the plugin that detected the vulnerability.
			PluginName *string `json:"plugin_name,omitempty"`

			// The number of times that a user in the user interface created a recast rule for this vulnerability. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/AboutRecastRules.htm" target="_blank">Recast Rules</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
			RecastedCount *int32 `json:"recasted_count,omitempty"`

			// The severity level of the vulnerability, as defined using the Common Vulnerability Scoring System (CVSS) base score. Possible values include:
			//  - 0The vulnerability has a CVSS score of 0, which corresponds to the "info" severity level.
			//  - 1The vulnerability has a CVSS score between 0.1 and 3.9, which corresponds to the "low" severity level.
			//  - 2The vulnerability has a CVSS score between 4.0 and 6.9, which corresponds to the "medium" severity level.
			//  - 3The vulnerability has a CVSS score between 7.0 and 9.9, which corresponds to the "high" severity level.
			//  - 4The vulnerability has a CVSS score of 10.0, which corresponds to the "critical" severity level.
			Severity *int32 `json:"severity,omitempty"`

			// The Vulnerability Priority Rating (VPR) for the vulnerability. If a plugin is designed to detect multiple vulnerabilities, the VPR represents the highest value calculated for a vulnerability associated with the plugin. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/RiskMetrics.htm" target="_blank">Severity vs. VPR</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
			VprScore *float32 `json:"vpr_score,omitempty"`

			// The current state of the reported plugin. Possible states include:
			//  - ActiveThe vulnerability is currently present on an asset.
			//  - NewThe vulnerability is active on an asset, and was first detected within the last 14 days.
			//  - FixedA subsequent scan detected that the formerly-active vulnerability is no longer present on an asset.
			//  - ResurfacedThe vulnerability was previously marked as fixed on an asset, but a subsequent scan detected the vulnerability on the asset again.
			VulnerabilityState *string `json:"vulnerability_state,omitempty"`
		} `json:"vulnerabilities,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesVulnerabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesVulnerabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesVulnerabilityInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// A count of the vulnerability occurrences.
		Count *int32 `json:"count,omitempty"`

		// The description of the vulnerability.
		Description *string `json:"description,omitempty"`
		Discovery   *struct {
			// The Unix timestamp of the scan that first detected the vulnerability on an asset.
			SeenFirst *string `json:"seen_first,omitempty"`

			// The Unix timestamp of the scan that most recently detected the vulnerability on an asset.
			SeenLast *string `json:"seen_last,omitempty"`
		} `json:"discovery,omitempty"`
		PluginDetails *struct {
			// The plugin family.
			Family *string `json:"family,omitempty"`

			// The ISO timestamp when Tenable last updated the plugin definition.
			ModificationDate *string `json:"modification_date,omitempty"`

			// The name of the plugin.
			Name *string `json:"name,omitempty"`

			// The ISO timestamp when Tenable first published the plugin definition.
			PublicationDate *string `json:"publication_date,omitempty"`

			// The severity level of the plugin.
			Severity *int32 `json:"severity,omitempty"`

			// The type of scan that uses the plugin, either a network scan (`remote`) or a credentialed scan (`local`).
			Type *string `json:"type,omitempty"`

			// The plugin version.
			Version *string `json:"version,omitempty"`
		} `json:"plugin_details,omitempty"`
		ReferenceInformation *[]struct {
			// The source of the reference information about the vulnerability. Possible values include:
			//  - bidBugtraq (Symantec Connect)
			//  - certCERT/CC Vulnerability Notes Database
			//  - cveNIST National Vulnerability Database (NVD)
			//  - edb-idThe Exploit Database
			//  - iavainformation assurance vulnerability alert
			//  - osvdbOpen Sourced Vulnerability Database
			Name *string `json:"name,omitempty"`

			// The URL of the source site, if available.
			Url *string `json:"url,omitempty"`

			// The unique identifier(s) for the vulnerability at the source.
			Values *[]string `json:"values,omitempty"`
		} `json:"reference_information,omitempty"`
		RiskInformation *struct {
			// The CVSSv3 base score (intrinsic and fundamental characteristics of a vulnerability that are constant over time and user environments).
			Cvss3BaseScore *string `json:"cvss3_base_score,omitempty"`

			// The CVSSv3 temporal score (characteristics of a vulnerability that change over time but not among user environments).
			Cvss3TemporalScore *string `json:"cvss3_temporal_score,omitempty"`

			// CVSSv3 temporal metrics for the vulnerability.
			Cvss3TemporalVector *string `json:"cvss3_temporal_vector,omitempty"`

			// The raw CVSSv3 metrics for the vulnerability. For more information, see CVSSv3 documentation.
			Cvss3Vector *string `json:"cvss3_vector,omitempty"`

			// The CVSSv2 base score (intrinsic and fundamental characteristics of a vulnerability that are constant over time and user environments).
			CvssBaseScore *string `json:"cvss_base_score,omitempty"`

			// The CVSSv2 temporal score (characteristics of a vulnerability that change over time but not among user environments).
			CvssTemporalScore *string `json:"cvss_temporal_score,omitempty"`

			// The raw CVSSv2 temporal metrics for the vulnerability.
			CvssTemporalVector *string `json:"cvss_temporal_vector,omitempty"`

			// The raw CVSSv2 metrics for the vulnerability. For more information, see CVSSv2 documentation.
			CvssVector *string `json:"cvss_vector,omitempty"`

			// The risk factor associated with the plugin. Possible values are: `Low`, `Medium`, `High`, or `Critical`. See the `risk_factor` attribute in [Tenable Plugin Attributes](doc:tenable-plugin-attributes).
			RiskFactor *string `json:"risk_factor,omitempty"`

			// Security Technical Implementation Guide (STIG) severity code for the vulnerability.
			StigSeverity *string `json:"stig_severity,omitempty"`
		} `json:"risk_information,omitempty"`

		// Links to external websites that contain helpful information about the vulnerability.
		SeeAlso *[]string `json:"see_also,omitempty"`

		// The severity level of the vulnerability.
		Severity *int `json:"severity,omitempty"`

		// Information on how to fix the vulnerability.
		Solution *string `json:"solution,omitempty"`

		// A brief summary of the vulnerability.
		Synopsis *string `json:"synopsis,omitempty"`

		// Information about the Vulnerability Priority Rating (VPR) for the vulnerability.
		Vpr *struct {
			// The key drivers Tenable uses to calculate a vulnerability's VPR. For more information, see <[Vulnerability Priority Rating Drivers](doc:vpr-drivers-tio).
			Drivers *map[string]interface{} `json:"drivers,omitempty"`

			// The Vulnerability Priority Rating (VPR) for the vulnerability. If a plugin is designed to detect multiple vulnerabilities, the VPR represents the highest value calculated for a vulnerability associated with the plugin. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/RiskMetrics.htm" target="_blank">Severity vs. VPR</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
			Score *float32 `json:"score,omitempty"`

			// The ISO timestamp when Tenable.io last imported the VPR for this vulnerability. Tenable.io imports a VPR value the first time you scan a vulnerability on your network. Then, Tenable.io automatically re-imports new and updated VPR values daily.
			Updated *string `json:"updated,omitempty"`
		} `json:"vpr,omitempty"`
		VulnCount                *int32 `json:"vuln_count,omitempty"`
		VulnerabilityInformation *struct {
			AssetInventory *string `json:"asset_inventory,omitempty"`

			// The Common Platform Enumeration (CPE) number for the plugin.
			Cpe            *string `json:"cpe,omitempty"`
			DefaultAccount *string `json:"default_account,omitempty"`

			// A value specifying whether a public exploit exists for the vulnerability.
			ExploitAvailable *bool `json:"exploit_available,omitempty"`

			// A list of exploit frameworks that have identified the vulnerability.
			ExploitFrameworks *[]struct {
				// A list of exploits associated with the vulnerability in the specified exploit framework.
				Exploits *[]struct {
					// The name of the identified exploit.
					Name *string `json:"name,omitempty"`

					// The URL for the exploit in the framework.
					Url *string `json:"url,omitempty"`
				} `json:"exploits,omitempty"`

				// The name of the exploit framework.
				Name *string `json:"name,omitempty"`
			} `json:"exploit_frameworks,omitempty"`

			// Description of how easy it is to exploit the issue.
			ExploitabilityEase *string `json:"exploitability_ease,omitempty"`

			// The vulnerability discovered by this plugin is known to be exploited by malware.
			ExploitedByMalware *bool `json:"exploited_by_malware,omitempty"`

			// A value specifying whether Nessus exploited the vulnerability during the process of identification.
			ExploitedByNessus *bool `json:"exploited_by_nessus,omitempty"`

			// A value specifying whether this plugin has received media attention (for example, ShellShock, Meltdown).
			InTheNews *bool   `json:"in_the_news,omitempty"`
			Malware   *string `json:"malware,omitempty"`

			// The ISO timestamp for date on which the vendor published a patch for the vulnerability.
			PatchPublicationDate *string `json:"patch_publication_date,omitempty"`

			// Software found by this plugin is unsupported by the software's vendor (for example, Windows 95 or Firefox 3).
			UnsupportedByVendor *bool `json:"unsupported_by_vendor,omitempty"`

			// The ISO timestamp for the first publication date of the plugin.
			VulnerabilityPublicationDate *string `json:"vulnerability_publication_date,omitempty"`
		} `json:"vulnerability_information,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesVulnerabilityInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesVulnerabilityInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkbenchesVulnerabilityOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// The plugin's output about the vulnerability. May be an empty string.
		PluginOutput *string `json:"plugin_output,omitempty"`

		// Vulnerability state items.
		States *[]struct {
			// The current state of the reported plugin (Active, Fixed, New, etc.)
			Name    *string `json:"name,omitempty"`
			Results *[]struct {
				// The application protocol where this vulnerability was found.
				ApplicationProtocol *string `json:"application_protocol,omitempty"`

				// A list of assets where this output was found.
				Assets *[]struct {
					// Indicates when the asset was discovered by a scan.
					FirstSeen *time.Time `json:"first_seen,omitempty"`

					// The FQDN of the asset.
					Fqdn *string `json:"fqdn,omitempty"`

					// The host name of the asset.
					Hostname *string `json:"hostname,omitempty"`

					// The ID of the asset.
					Id *string `json:"id,omitempty"`

					// The IPV4 of the asset.
					Ipv4 *string `json:"ipv4,omitempty"`

					// Indicates when the asset was last observed by a scan.
					LastSeen *time.Time `json:"last_seen,omitempty"`

					// The NetBios name of the asset.
					NetbiosName *string `json:"netbios_name,omitempty"`

					// The UUID of the asset. Use this value as the unique key for the asset.
					Uuid *string `json:"uuid,omitempty"`
				} `json:"assets,omitempty"`

				// The port number where this vulnerability was found.
				Port *int `json:"port,omitempty"`

				// Integer [0-4] indicating how severe the vulnerability is, where 0 is info only.
				Severity *int `json:"severity,omitempty"`

				// The transportation protocol (TCP or UDP) where this vulnerability was found.
				TransportProtocol *string `json:"transport_protocol,omitempty"`
			} `json:"results,omitempty"`
		} `json:"states,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WorkbenchesVulnerabilityOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkbenchesVulnerabilityOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// IoV1AccessGroupsListWithResponse request returning *IoV1AccessGroupsListResponse
func (c *ClientWithResponses) IoV1AccessGroupsListWithResponse(ctx context.Context, params *IoV1AccessGroupsListParams, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsListResponse, error) {
	rsp, err := c.IoV1AccessGroupsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV1AccessGroupsListResponse(rsp)
}

// IoV1AccessGroupsCreateWithBodyWithResponse request with arbitrary body returning *IoV1AccessGroupsCreateResponse
func (c *ClientWithResponses) IoV1AccessGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsCreateResponse, error) {
	rsp, err := c.IoV1AccessGroupsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV1AccessGroupsCreateResponse(rsp)
}

func (c *ClientWithResponses) IoV1AccessGroupsCreateWithResponse(ctx context.Context, body IoV1AccessGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsCreateResponse, error) {
	rsp, err := c.IoV1AccessGroupsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV1AccessGroupsCreateResponse(rsp)
}

// IoV1AccessGroupsListFiltersWithResponse request returning *IoV1AccessGroupsListFiltersResponse
func (c *ClientWithResponses) IoV1AccessGroupsListFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsListFiltersResponse, error) {
	rsp, err := c.IoV1AccessGroupsListFilters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV1AccessGroupsListFiltersResponse(rsp)
}

// IoV1AccessGroupsListRuleFiltersWithResponse request returning *IoV1AccessGroupsListRuleFiltersResponse
func (c *ClientWithResponses) IoV1AccessGroupsListRuleFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsListRuleFiltersResponse, error) {
	rsp, err := c.IoV1AccessGroupsListRuleFilters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV1AccessGroupsListRuleFiltersResponse(rsp)
}

// IoV1AccessGroupsDeleteWithResponse request returning *IoV1AccessGroupsDeleteResponse
func (c *ClientWithResponses) IoV1AccessGroupsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsDeleteResponse, error) {
	rsp, err := c.IoV1AccessGroupsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV1AccessGroupsDeleteResponse(rsp)
}

// IoV1AccessGroupsDetailsWithResponse request returning *IoV1AccessGroupsDetailsResponse
func (c *ClientWithResponses) IoV1AccessGroupsDetailsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsDetailsResponse, error) {
	rsp, err := c.IoV1AccessGroupsDetails(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV1AccessGroupsDetailsResponse(rsp)
}

// IoV1AccessGroupsEditWithBodyWithResponse request with arbitrary body returning *IoV1AccessGroupsEditResponse
func (c *ClientWithResponses) IoV1AccessGroupsEditWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsEditResponse, error) {
	rsp, err := c.IoV1AccessGroupsEditWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV1AccessGroupsEditResponse(rsp)
}

func (c *ClientWithResponses) IoV1AccessGroupsEditWithResponse(ctx context.Context, id string, body IoV1AccessGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*IoV1AccessGroupsEditResponse, error) {
	rsp, err := c.IoV1AccessGroupsEdit(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV1AccessGroupsEditResponse(rsp)
}

// AssetsBulkUpdateAcrWithBodyWithResponse request with arbitrary body returning *AssetsBulkUpdateAcrResponse
func (c *ClientWithResponses) AssetsBulkUpdateAcrWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetsBulkUpdateAcrResponse, error) {
	rsp, err := c.AssetsBulkUpdateAcrWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetsBulkUpdateAcrResponse(rsp)
}

func (c *ClientWithResponses) AssetsBulkUpdateAcrWithResponse(ctx context.Context, body AssetsBulkUpdateAcrJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetsBulkUpdateAcrResponse, error) {
	rsp, err := c.AssetsBulkUpdateAcr(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetsBulkUpdateAcrResponse(rsp)
}

// AssetsBulkDeleteWithBodyWithResponse request with arbitrary body returning *AssetsBulkDeleteResponse
func (c *ClientWithResponses) AssetsBulkDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetsBulkDeleteResponse, error) {
	rsp, err := c.AssetsBulkDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetsBulkDeleteResponse(rsp)
}

func (c *ClientWithResponses) AssetsBulkDeleteWithResponse(ctx context.Context, body AssetsBulkDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetsBulkDeleteResponse, error) {
	rsp, err := c.AssetsBulkDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetsBulkDeleteResponse(rsp)
}

// AssetsBulkMoveWithBodyWithResponse request with arbitrary body returning *AssetsBulkMoveResponse
func (c *ClientWithResponses) AssetsBulkMoveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetsBulkMoveResponse, error) {
	rsp, err := c.AssetsBulkMoveWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetsBulkMoveResponse(rsp)
}

func (c *ClientWithResponses) AssetsBulkMoveWithResponse(ctx context.Context, body AssetsBulkMoveJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetsBulkMoveResponse, error) {
	rsp, err := c.AssetsBulkMove(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetsBulkMoveResponse(rsp)
}

// VulnerabilitiesImportV2WithBodyWithResponse request with arbitrary body returning *VulnerabilitiesImportV2Response
func (c *ClientWithResponses) VulnerabilitiesImportV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VulnerabilitiesImportV2Response, error) {
	rsp, err := c.VulnerabilitiesImportV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVulnerabilitiesImportV2Response(rsp)
}

func (c *ClientWithResponses) VulnerabilitiesImportV2WithResponse(ctx context.Context, body VulnerabilitiesImportV2JSONRequestBody, reqEditors ...RequestEditorFn) (*VulnerabilitiesImportV2Response, error) {
	rsp, err := c.VulnerabilitiesImportV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVulnerabilitiesImportV2Response(rsp)
}

// AssetsListAssetsWithResponse request returning *AssetsListAssetsResponse
func (c *ClientWithResponses) AssetsListAssetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AssetsListAssetsResponse, error) {
	rsp, err := c.AssetsListAssets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetsListAssetsResponse(rsp)
}

// ExportsAssetsRequestExportWithBodyWithResponse request with arbitrary body returning *ExportsAssetsRequestExportResponse
func (c *ClientWithResponses) ExportsAssetsRequestExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportsAssetsRequestExportResponse, error) {
	rsp, err := c.ExportsAssetsRequestExportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportsAssetsRequestExportResponse(rsp)
}

func (c *ClientWithResponses) ExportsAssetsRequestExportWithResponse(ctx context.Context, body ExportsAssetsRequestExportJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportsAssetsRequestExportResponse, error) {
	rsp, err := c.ExportsAssetsRequestExport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportsAssetsRequestExportResponse(rsp)
}

// ExportsAssetsExportStatusRecentWithResponse request returning *ExportsAssetsExportStatusRecentResponse
func (c *ClientWithResponses) ExportsAssetsExportStatusRecentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportsAssetsExportStatusRecentResponse, error) {
	rsp, err := c.ExportsAssetsExportStatusRecent(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportsAssetsExportStatusRecentResponse(rsp)
}

// ExportsAssetsExportCancelWithResponse request returning *ExportsAssetsExportCancelResponse
func (c *ClientWithResponses) ExportsAssetsExportCancelWithResponse(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*ExportsAssetsExportCancelResponse, error) {
	rsp, err := c.ExportsAssetsExportCancel(ctx, exportUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportsAssetsExportCancelResponse(rsp)
}

// ExportsAssetsDownloadChunkWithResponse request returning *ExportsAssetsDownloadChunkResponse
func (c *ClientWithResponses) ExportsAssetsDownloadChunkWithResponse(ctx context.Context, exportUuid string, chunkId int32, reqEditors ...RequestEditorFn) (*ExportsAssetsDownloadChunkResponse, error) {
	rsp, err := c.ExportsAssetsDownloadChunk(ctx, exportUuid, chunkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportsAssetsDownloadChunkResponse(rsp)
}

// ExportsAssetsExportStatusWithResponse request returning *ExportsAssetsExportStatusResponse
func (c *ClientWithResponses) ExportsAssetsExportStatusWithResponse(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*ExportsAssetsExportStatusResponse, error) {
	rsp, err := c.ExportsAssetsExportStatus(ctx, exportUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportsAssetsExportStatusResponse(rsp)
}

// AssetsAssetInfoWithResponse request returning *AssetsAssetInfoResponse
func (c *ClientWithResponses) AssetsAssetInfoWithResponse(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*AssetsAssetInfoResponse, error) {
	rsp, err := c.AssetsAssetInfo(ctx, assetUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetsAssetInfoResponse(rsp)
}

// AuditLogEventsWithResponse request returning *AuditLogEventsResponse
func (c *ClientWithResponses) AuditLogEventsWithResponse(ctx context.Context, params *AuditLogEventsParams, reqEditors ...RequestEditorFn) (*AuditLogEventsResponse, error) {
	rsp, err := c.AuditLogEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuditLogEventsResponse(rsp)
}

// IoExportsComplianceCreateWithBodyWithResponse request with arbitrary body returning *IoExportsComplianceCreateResponse
func (c *ClientWithResponses) IoExportsComplianceCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoExportsComplianceCreateResponse, error) {
	rsp, err := c.IoExportsComplianceCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoExportsComplianceCreateResponse(rsp)
}

func (c *ClientWithResponses) IoExportsComplianceCreateWithResponse(ctx context.Context, body IoExportsComplianceCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IoExportsComplianceCreateResponse, error) {
	rsp, err := c.IoExportsComplianceCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoExportsComplianceCreateResponse(rsp)
}

// IoExportsComplianceCancelWithResponse request returning *IoExportsComplianceCancelResponse
func (c *ClientWithResponses) IoExportsComplianceCancelWithResponse(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*IoExportsComplianceCancelResponse, error) {
	rsp, err := c.IoExportsComplianceCancel(ctx, exportUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoExportsComplianceCancelResponse(rsp)
}

// IoExportsComplianceDownloadWithResponse request returning *IoExportsComplianceDownloadResponse
func (c *ClientWithResponses) IoExportsComplianceDownloadWithResponse(ctx context.Context, exportUuid string, chunkId int32, reqEditors ...RequestEditorFn) (*IoExportsComplianceDownloadResponse, error) {
	rsp, err := c.IoExportsComplianceDownload(ctx, exportUuid, chunkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoExportsComplianceDownloadResponse(rsp)
}

// IoExportsComplianceStatusWithResponse request returning *IoExportsComplianceStatusResponse
func (c *ClientWithResponses) IoExportsComplianceStatusWithResponse(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*IoExportsComplianceStatusResponse, error) {
	rsp, err := c.IoExportsComplianceStatus(ctx, exportUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoExportsComplianceStatusResponse(rsp)
}

// CredentialsListWithResponse request returning *CredentialsListResponse
func (c *ClientWithResponses) CredentialsListWithResponse(ctx context.Context, params *CredentialsListParams, reqEditors ...RequestEditorFn) (*CredentialsListResponse, error) {
	rsp, err := c.CredentialsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialsListResponse(rsp)
}

// CredentialsCreateWithBodyWithResponse request with arbitrary body returning *CredentialsCreateResponse
func (c *ClientWithResponses) CredentialsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CredentialsCreateResponse, error) {
	rsp, err := c.CredentialsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialsCreateResponse(rsp)
}

func (c *ClientWithResponses) CredentialsCreateWithResponse(ctx context.Context, body CredentialsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CredentialsCreateResponse, error) {
	rsp, err := c.CredentialsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialsCreateResponse(rsp)
}

// CredentialsFileUploadWithBodyWithResponse request with arbitrary body returning *CredentialsFileUploadResponse
func (c *ClientWithResponses) CredentialsFileUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CredentialsFileUploadResponse, error) {
	rsp, err := c.CredentialsFileUploadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialsFileUploadResponse(rsp)
}

// CredentialsListCredentialTypesWithResponse request returning *CredentialsListCredentialTypesResponse
func (c *ClientWithResponses) CredentialsListCredentialTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CredentialsListCredentialTypesResponse, error) {
	rsp, err := c.CredentialsListCredentialTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialsListCredentialTypesResponse(rsp)
}

// CredentialsDeleteWithResponse request returning *CredentialsDeleteResponse
func (c *ClientWithResponses) CredentialsDeleteWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*CredentialsDeleteResponse, error) {
	rsp, err := c.CredentialsDelete(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialsDeleteResponse(rsp)
}

// CredentialsDetailsWithResponse request returning *CredentialsDetailsResponse
func (c *ClientWithResponses) CredentialsDetailsWithResponse(ctx context.Context, uuid string, reqEditors ...RequestEditorFn) (*CredentialsDetailsResponse, error) {
	rsp, err := c.CredentialsDetails(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialsDetailsResponse(rsp)
}

// CredentialsUpdateWithBodyWithResponse request with arbitrary body returning *CredentialsUpdateResponse
func (c *ClientWithResponses) CredentialsUpdateWithBodyWithResponse(ctx context.Context, uuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CredentialsUpdateResponse, error) {
	rsp, err := c.CredentialsUpdateWithBody(ctx, uuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialsUpdateResponse(rsp)
}

func (c *ClientWithResponses) CredentialsUpdateWithResponse(ctx context.Context, uuid string, body CredentialsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CredentialsUpdateResponse, error) {
	rsp, err := c.CredentialsUpdate(ctx, uuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCredentialsUpdateResponse(rsp)
}

// EditorPluginDescriptionWithResponse request returning *EditorPluginDescriptionResponse
func (c *ClientWithResponses) EditorPluginDescriptionWithResponse(ctx context.Context, policyId int32, familyId int32, pluginId int32, reqEditors ...RequestEditorFn) (*EditorPluginDescriptionResponse, error) {
	rsp, err := c.EditorPluginDescription(ctx, policyId, familyId, pluginId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditorPluginDescriptionResponse(rsp)
}

// EditorListTemplatesWithResponse request returning *EditorListTemplatesResponse
func (c *ClientWithResponses) EditorListTemplatesWithResponse(ctx context.Context, pType EditorListTemplatesParamsType, reqEditors ...RequestEditorFn) (*EditorListTemplatesResponse, error) {
	rsp, err := c.EditorListTemplates(ctx, pType, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditorListTemplatesResponse(rsp)
}

// EditorTemplateDetailsWithResponse request returning *EditorTemplateDetailsResponse
func (c *ClientWithResponses) EditorTemplateDetailsWithResponse(ctx context.Context, pType EditorTemplateDetailsParamsType, templateUuid string, reqEditors ...RequestEditorFn) (*EditorTemplateDetailsResponse, error) {
	rsp, err := c.EditorTemplateDetails(ctx, pType, templateUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditorTemplateDetailsResponse(rsp)
}

// EditorDetailsWithResponse request returning *EditorDetailsResponse
func (c *ClientWithResponses) EditorDetailsWithResponse(ctx context.Context, pType EditorDetailsParamsType, id int32, reqEditors ...RequestEditorFn) (*EditorDetailsResponse, error) {
	rsp, err := c.EditorDetails(ctx, pType, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditorDetailsResponse(rsp)
}

// EditorAuditsWithResponse request returning *EditorAuditsResponse
func (c *ClientWithResponses) EditorAuditsWithResponse(ctx context.Context, pType EditorAuditsParamsType, objectId int32, fileId int32, reqEditors ...RequestEditorFn) (*EditorAuditsResponse, error) {
	rsp, err := c.EditorAudits(ctx, pType, objectId, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditorAuditsResponse(rsp)
}

// ExclusionsListWithResponse request returning *ExclusionsListResponse
func (c *ClientWithResponses) ExclusionsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExclusionsListResponse, error) {
	rsp, err := c.ExclusionsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExclusionsListResponse(rsp)
}

// ExclusionsCreateWithBodyWithResponse request with arbitrary body returning *ExclusionsCreateResponse
func (c *ClientWithResponses) ExclusionsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExclusionsCreateResponse, error) {
	rsp, err := c.ExclusionsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExclusionsCreateResponse(rsp)
}

func (c *ClientWithResponses) ExclusionsCreateWithResponse(ctx context.Context, body ExclusionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ExclusionsCreateResponse, error) {
	rsp, err := c.ExclusionsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExclusionsCreateResponse(rsp)
}

// ExclusionsImportWithBodyWithResponse request with arbitrary body returning *ExclusionsImportResponse
func (c *ClientWithResponses) ExclusionsImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExclusionsImportResponse, error) {
	rsp, err := c.ExclusionsImportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExclusionsImportResponse(rsp)
}

func (c *ClientWithResponses) ExclusionsImportWithResponse(ctx context.Context, body ExclusionsImportJSONRequestBody, reqEditors ...RequestEditorFn) (*ExclusionsImportResponse, error) {
	rsp, err := c.ExclusionsImport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExclusionsImportResponse(rsp)
}

// ExclusionsDeleteWithResponse request returning *ExclusionsDeleteResponse
func (c *ClientWithResponses) ExclusionsDeleteWithResponse(ctx context.Context, exclusionId int32, reqEditors ...RequestEditorFn) (*ExclusionsDeleteResponse, error) {
	rsp, err := c.ExclusionsDelete(ctx, exclusionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExclusionsDeleteResponse(rsp)
}

// ExclusionsDetailsWithResponse request returning *ExclusionsDetailsResponse
func (c *ClientWithResponses) ExclusionsDetailsWithResponse(ctx context.Context, exclusionId int32, reqEditors ...RequestEditorFn) (*ExclusionsDetailsResponse, error) {
	rsp, err := c.ExclusionsDetails(ctx, exclusionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExclusionsDetailsResponse(rsp)
}

// ExclusionsEditWithBodyWithResponse request with arbitrary body returning *ExclusionsEditResponse
func (c *ClientWithResponses) ExclusionsEditWithBodyWithResponse(ctx context.Context, exclusionId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExclusionsEditResponse, error) {
	rsp, err := c.ExclusionsEditWithBody(ctx, exclusionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExclusionsEditResponse(rsp)
}

func (c *ClientWithResponses) ExclusionsEditWithResponse(ctx context.Context, exclusionId int32, body ExclusionsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*ExclusionsEditResponse, error) {
	rsp, err := c.ExclusionsEdit(ctx, exclusionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExclusionsEditResponse(rsp)
}

// FileUploadWithBodyWithResponse request with arbitrary body returning *FileUploadResponse
func (c *ClientWithResponses) FileUploadWithBodyWithResponse(ctx context.Context, params *FileUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FileUploadResponse, error) {
	rsp, err := c.FileUploadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileUploadResponse(rsp)
}

// IoFiltersCredentialsListWithResponse request returning *IoFiltersCredentialsListResponse
func (c *ClientWithResponses) IoFiltersCredentialsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoFiltersCredentialsListResponse, error) {
	rsp, err := c.IoFiltersCredentialsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoFiltersCredentialsListResponse(rsp)
}

// IoFiltersAgentsListWithResponse request returning *IoFiltersAgentsListResponse
func (c *ClientWithResponses) IoFiltersAgentsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoFiltersAgentsListResponse, error) {
	rsp, err := c.IoFiltersAgentsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoFiltersAgentsListResponse(rsp)
}

// IoFiltersScanListWithResponse request returning *IoFiltersScanListResponse
func (c *ClientWithResponses) IoFiltersScanListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoFiltersScanListResponse, error) {
	rsp, err := c.IoFiltersScanList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoFiltersScanListResponse(rsp)
}

// IoFiltersScanHistoryListWithResponse request returning *IoFiltersScanHistoryListResponse
func (c *ClientWithResponses) IoFiltersScanHistoryListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoFiltersScanHistoryListResponse, error) {
	rsp, err := c.IoFiltersScanHistoryList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoFiltersScanHistoryListResponse(rsp)
}

// IoFiltersAssetsListWithResponse request returning *IoFiltersAssetsListResponse
func (c *ClientWithResponses) IoFiltersAssetsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoFiltersAssetsListResponse, error) {
	rsp, err := c.IoFiltersAssetsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoFiltersAssetsListResponse(rsp)
}

// IoFiltersAssetsListV2WithBodyWithResponse request with arbitrary body returning *IoFiltersAssetsListV2Response
func (c *ClientWithResponses) IoFiltersAssetsListV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoFiltersAssetsListV2Response, error) {
	rsp, err := c.IoFiltersAssetsListV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoFiltersAssetsListV2Response(rsp)
}

func (c *ClientWithResponses) IoFiltersAssetsListV2WithResponse(ctx context.Context, body IoFiltersAssetsListV2JSONRequestBody, reqEditors ...RequestEditorFn) (*IoFiltersAssetsListV2Response, error) {
	rsp, err := c.IoFiltersAssetsListV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoFiltersAssetsListV2Response(rsp)
}

// IoFiltersVulnerabilitiesWorkbenchListWithResponse request returning *IoFiltersVulnerabilitiesWorkbenchListResponse
func (c *ClientWithResponses) IoFiltersVulnerabilitiesWorkbenchListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoFiltersVulnerabilitiesWorkbenchListResponse, error) {
	rsp, err := c.IoFiltersVulnerabilitiesWorkbenchList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoFiltersVulnerabilitiesWorkbenchListResponse(rsp)
}

// IoFiltersVulnerabilitiesWorkbenchListV2WithBodyWithResponse request with arbitrary body returning *IoFiltersVulnerabilitiesWorkbenchListV2Response
func (c *ClientWithResponses) IoFiltersVulnerabilitiesWorkbenchListV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoFiltersVulnerabilitiesWorkbenchListV2Response, error) {
	rsp, err := c.IoFiltersVulnerabilitiesWorkbenchListV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoFiltersVulnerabilitiesWorkbenchListV2Response(rsp)
}

func (c *ClientWithResponses) IoFiltersVulnerabilitiesWorkbenchListV2WithResponse(ctx context.Context, body IoFiltersVulnerabilitiesWorkbenchListV2JSONRequestBody, reqEditors ...RequestEditorFn) (*IoFiltersVulnerabilitiesWorkbenchListV2Response, error) {
	rsp, err := c.IoFiltersVulnerabilitiesWorkbenchListV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoFiltersVulnerabilitiesWorkbenchListV2Response(rsp)
}

// FoldersListWithResponse request returning *FoldersListResponse
func (c *ClientWithResponses) FoldersListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*FoldersListResponse, error) {
	rsp, err := c.FoldersList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFoldersListResponse(rsp)
}

// FoldersCreateWithBodyWithResponse request with arbitrary body returning *FoldersCreateResponse
func (c *ClientWithResponses) FoldersCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FoldersCreateResponse, error) {
	rsp, err := c.FoldersCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFoldersCreateResponse(rsp)
}

func (c *ClientWithResponses) FoldersCreateWithResponse(ctx context.Context, body FoldersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FoldersCreateResponse, error) {
	rsp, err := c.FoldersCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFoldersCreateResponse(rsp)
}

// FoldersDeleteWithResponse request returning *FoldersDeleteResponse
func (c *ClientWithResponses) FoldersDeleteWithResponse(ctx context.Context, folderId int32, reqEditors ...RequestEditorFn) (*FoldersDeleteResponse, error) {
	rsp, err := c.FoldersDelete(ctx, folderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFoldersDeleteResponse(rsp)
}

// FoldersEditWithBodyWithResponse request with arbitrary body returning *FoldersEditResponse
func (c *ClientWithResponses) FoldersEditWithBodyWithResponse(ctx context.Context, folderId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FoldersEditResponse, error) {
	rsp, err := c.FoldersEditWithBody(ctx, folderId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFoldersEditResponse(rsp)
}

func (c *ClientWithResponses) FoldersEditWithResponse(ctx context.Context, folderId int32, body FoldersEditJSONRequestBody, reqEditors ...RequestEditorFn) (*FoldersEditResponse, error) {
	rsp, err := c.FoldersEdit(ctx, folderId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFoldersEditResponse(rsp)
}

// AssetsListImportJobsWithResponse request returning *AssetsListImportJobsResponse
func (c *ClientWithResponses) AssetsListImportJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AssetsListImportJobsResponse, error) {
	rsp, err := c.AssetsListImportJobs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetsListImportJobsResponse(rsp)
}

// AssetsImportJobInfoWithResponse request returning *AssetsImportJobInfoResponse
func (c *ClientWithResponses) AssetsImportJobInfoWithResponse(ctx context.Context, assetImportJobUuid string, reqEditors ...RequestEditorFn) (*AssetsImportJobInfoResponse, error) {
	rsp, err := c.AssetsImportJobInfo(ctx, assetImportJobUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetsImportJobInfoResponse(rsp)
}

// AssetsImportWithBodyWithResponse request with arbitrary body returning *AssetsImportResponse
func (c *ClientWithResponses) AssetsImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssetsImportResponse, error) {
	rsp, err := c.AssetsImportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetsImportResponse(rsp)
}

func (c *ClientWithResponses) AssetsImportWithResponse(ctx context.Context, body AssetsImportJSONRequestBody, reqEditors ...RequestEditorFn) (*AssetsImportResponse, error) {
	rsp, err := c.AssetsImport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssetsImportResponse(rsp)
}

// VulnerabilitiesImportWithBodyWithResponse request with arbitrary body returning *VulnerabilitiesImportResponse
func (c *ClientWithResponses) VulnerabilitiesImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VulnerabilitiesImportResponse, error) {
	rsp, err := c.VulnerabilitiesImportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVulnerabilitiesImportResponse(rsp)
}

func (c *ClientWithResponses) VulnerabilitiesImportWithResponse(ctx context.Context, body VulnerabilitiesImportJSONRequestBody, reqEditors ...RequestEditorFn) (*VulnerabilitiesImportResponse, error) {
	rsp, err := c.VulnerabilitiesImport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVulnerabilitiesImportResponse(rsp)
}

// NetworksListWithResponse request returning *NetworksListResponse
func (c *ClientWithResponses) NetworksListWithResponse(ctx context.Context, params *NetworksListParams, reqEditors ...RequestEditorFn) (*NetworksListResponse, error) {
	rsp, err := c.NetworksList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworksListResponse(rsp)
}

// NetworksCreateWithBodyWithResponse request with arbitrary body returning *NetworksCreateResponse
func (c *ClientWithResponses) NetworksCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NetworksCreateResponse, error) {
	rsp, err := c.NetworksCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworksCreateResponse(rsp)
}

func (c *ClientWithResponses) NetworksCreateWithResponse(ctx context.Context, body NetworksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*NetworksCreateResponse, error) {
	rsp, err := c.NetworksCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworksCreateResponse(rsp)
}

// NetworksDeleteWithResponse request returning *NetworksDeleteResponse
func (c *ClientWithResponses) NetworksDeleteWithResponse(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*NetworksDeleteResponse, error) {
	rsp, err := c.NetworksDelete(ctx, networkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworksDeleteResponse(rsp)
}

// NetworksDetailsWithResponse request returning *NetworksDetailsResponse
func (c *ClientWithResponses) NetworksDetailsWithResponse(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*NetworksDetailsResponse, error) {
	rsp, err := c.NetworksDetails(ctx, networkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworksDetailsResponse(rsp)
}

// NetworksUpdateWithBodyWithResponse request with arbitrary body returning *NetworksUpdateResponse
func (c *ClientWithResponses) NetworksUpdateWithBodyWithResponse(ctx context.Context, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NetworksUpdateResponse, error) {
	rsp, err := c.NetworksUpdateWithBody(ctx, networkId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworksUpdateResponse(rsp)
}

func (c *ClientWithResponses) NetworksUpdateWithResponse(ctx context.Context, networkId string, body NetworksUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*NetworksUpdateResponse, error) {
	rsp, err := c.NetworksUpdate(ctx, networkId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworksUpdateResponse(rsp)
}

// NetworksListAssignableScannersWithResponse request returning *NetworksListAssignableScannersResponse
func (c *ClientWithResponses) NetworksListAssignableScannersWithResponse(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*NetworksListAssignableScannersResponse, error) {
	rsp, err := c.NetworksListAssignableScanners(ctx, networkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworksListAssignableScannersResponse(rsp)
}

// IoNetworksAssetCountDetailsWithResponse request returning *IoNetworksAssetCountDetailsResponse
func (c *ClientWithResponses) IoNetworksAssetCountDetailsWithResponse(ctx context.Context, networkId string, numDays int, reqEditors ...RequestEditorFn) (*IoNetworksAssetCountDetailsResponse, error) {
	rsp, err := c.IoNetworksAssetCountDetails(ctx, networkId, numDays, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoNetworksAssetCountDetailsResponse(rsp)
}

// NetworksListScannersWithResponse request returning *NetworksListScannersResponse
func (c *ClientWithResponses) NetworksListScannersWithResponse(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*NetworksListScannersResponse, error) {
	rsp, err := c.NetworksListScanners(ctx, networkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworksListScannersResponse(rsp)
}

// NetworksAssignScannerBulkWithBodyWithResponse request with arbitrary body returning *NetworksAssignScannerBulkResponse
func (c *ClientWithResponses) NetworksAssignScannerBulkWithBodyWithResponse(ctx context.Context, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NetworksAssignScannerBulkResponse, error) {
	rsp, err := c.NetworksAssignScannerBulkWithBody(ctx, networkId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworksAssignScannerBulkResponse(rsp)
}

func (c *ClientWithResponses) NetworksAssignScannerBulkWithResponse(ctx context.Context, networkId string, body NetworksAssignScannerBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*NetworksAssignScannerBulkResponse, error) {
	rsp, err := c.NetworksAssignScannerBulk(ctx, networkId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworksAssignScannerBulkResponse(rsp)
}

// NetworksAssignScannerWithResponse request returning *NetworksAssignScannerResponse
func (c *ClientWithResponses) NetworksAssignScannerWithResponse(ctx context.Context, networkId string, scannerUuid string, reqEditors ...RequestEditorFn) (*NetworksAssignScannerResponse, error) {
	rsp, err := c.NetworksAssignScanner(ctx, networkId, scannerUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworksAssignScannerResponse(rsp)
}

// PermissionsListWithResponse request returning *PermissionsListResponse
func (c *ClientWithResponses) PermissionsListWithResponse(ctx context.Context, objectType PermissionsListParamsObjectType, objectId int32, reqEditors ...RequestEditorFn) (*PermissionsListResponse, error) {
	rsp, err := c.PermissionsList(ctx, objectType, objectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermissionsListResponse(rsp)
}

// PermissionsChangeWithBodyWithResponse request with arbitrary body returning *PermissionsChangeResponse
func (c *ClientWithResponses) PermissionsChangeWithBodyWithResponse(ctx context.Context, objectType PermissionsChangeParamsObjectType, objectId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermissionsChangeResponse, error) {
	rsp, err := c.PermissionsChangeWithBody(ctx, objectType, objectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermissionsChangeResponse(rsp)
}

func (c *ClientWithResponses) PermissionsChangeWithResponse(ctx context.Context, objectType PermissionsChangeParamsObjectType, objectId int32, body PermissionsChangeJSONRequestBody, reqEditors ...RequestEditorFn) (*PermissionsChangeResponse, error) {
	rsp, err := c.PermissionsChange(ctx, objectType, objectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermissionsChangeResponse(rsp)
}

// IoPluginsFamiliesListWithResponse request returning *IoPluginsFamiliesListResponse
func (c *ClientWithResponses) IoPluginsFamiliesListWithResponse(ctx context.Context, params *IoPluginsFamiliesListParams, reqEditors ...RequestEditorFn) (*IoPluginsFamiliesListResponse, error) {
	rsp, err := c.IoPluginsFamiliesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoPluginsFamiliesListResponse(rsp)
}

// IoPluginsFamilyDetailsWithResponse request returning *IoPluginsFamilyDetailsResponse
func (c *ClientWithResponses) IoPluginsFamilyDetailsWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*IoPluginsFamilyDetailsResponse, error) {
	rsp, err := c.IoPluginsFamilyDetails(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoPluginsFamilyDetailsResponse(rsp)
}

// IoPluginsListWithResponse request returning *IoPluginsListResponse
func (c *ClientWithResponses) IoPluginsListWithResponse(ctx context.Context, params *IoPluginsListParams, reqEditors ...RequestEditorFn) (*IoPluginsListResponse, error) {
	rsp, err := c.IoPluginsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoPluginsListResponse(rsp)
}

// IoPluginsDetailsWithResponse request returning *IoPluginsDetailsResponse
func (c *ClientWithResponses) IoPluginsDetailsWithResponse(ctx context.Context, id int32, reqEditors ...RequestEditorFn) (*IoPluginsDetailsResponse, error) {
	rsp, err := c.IoPluginsDetails(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoPluginsDetailsResponse(rsp)
}

// PoliciesListWithResponse request returning *PoliciesListResponse
func (c *ClientWithResponses) PoliciesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PoliciesListResponse, error) {
	rsp, err := c.PoliciesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePoliciesListResponse(rsp)
}

// PoliciesCreateWithBodyWithResponse request with arbitrary body returning *PoliciesCreateResponse
func (c *ClientWithResponses) PoliciesCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PoliciesCreateResponse, error) {
	rsp, err := c.PoliciesCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePoliciesCreateResponse(rsp)
}

func (c *ClientWithResponses) PoliciesCreateWithResponse(ctx context.Context, body PoliciesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PoliciesCreateResponse, error) {
	rsp, err := c.PoliciesCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePoliciesCreateResponse(rsp)
}

// PoliciesImportWithBodyWithResponse request with arbitrary body returning *PoliciesImportResponse
func (c *ClientWithResponses) PoliciesImportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PoliciesImportResponse, error) {
	rsp, err := c.PoliciesImportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePoliciesImportResponse(rsp)
}

func (c *ClientWithResponses) PoliciesImportWithResponse(ctx context.Context, body PoliciesImportJSONRequestBody, reqEditors ...RequestEditorFn) (*PoliciesImportResponse, error) {
	rsp, err := c.PoliciesImport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePoliciesImportResponse(rsp)
}

// PoliciesDeleteWithResponse request returning *PoliciesDeleteResponse
func (c *ClientWithResponses) PoliciesDeleteWithResponse(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*PoliciesDeleteResponse, error) {
	rsp, err := c.PoliciesDelete(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePoliciesDeleteResponse(rsp)
}

// PoliciesDetailsWithResponse request returning *PoliciesDetailsResponse
func (c *ClientWithResponses) PoliciesDetailsWithResponse(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*PoliciesDetailsResponse, error) {
	rsp, err := c.PoliciesDetails(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePoliciesDetailsResponse(rsp)
}

// PoliciesConfigureWithResponse request returning *PoliciesConfigureResponse
func (c *ClientWithResponses) PoliciesConfigureWithResponse(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*PoliciesConfigureResponse, error) {
	rsp, err := c.PoliciesConfigure(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePoliciesConfigureResponse(rsp)
}

// PoliciesCopyWithResponse request returning *PoliciesCopyResponse
func (c *ClientWithResponses) PoliciesCopyWithResponse(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*PoliciesCopyResponse, error) {
	rsp, err := c.PoliciesCopy(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePoliciesCopyResponse(rsp)
}

// PoliciesExportWithResponse request returning *PoliciesExportResponse
func (c *ClientWithResponses) PoliciesExportWithResponse(ctx context.Context, policyId int32, reqEditors ...RequestEditorFn) (*PoliciesExportResponse, error) {
	rsp, err := c.PoliciesExport(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePoliciesExportResponse(rsp)
}

// ScannerGroupsListWithResponse request returning *ScannerGroupsListResponse
func (c *ClientWithResponses) ScannerGroupsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScannerGroupsListResponse, error) {
	rsp, err := c.ScannerGroupsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannerGroupsListResponse(rsp)
}

// ScannerGroupsCreateWithBodyWithResponse request with arbitrary body returning *ScannerGroupsCreateResponse
func (c *ClientWithResponses) ScannerGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScannerGroupsCreateResponse, error) {
	rsp, err := c.ScannerGroupsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannerGroupsCreateResponse(rsp)
}

func (c *ClientWithResponses) ScannerGroupsCreateWithResponse(ctx context.Context, body ScannerGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScannerGroupsCreateResponse, error) {
	rsp, err := c.ScannerGroupsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannerGroupsCreateResponse(rsp)
}

// ScannerGroupsDeleteWithResponse request returning *ScannerGroupsDeleteResponse
func (c *ClientWithResponses) ScannerGroupsDeleteWithResponse(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*ScannerGroupsDeleteResponse, error) {
	rsp, err := c.ScannerGroupsDelete(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannerGroupsDeleteResponse(rsp)
}

// ScannerGroupsDetailsWithResponse request returning *ScannerGroupsDetailsResponse
func (c *ClientWithResponses) ScannerGroupsDetailsWithResponse(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*ScannerGroupsDetailsResponse, error) {
	rsp, err := c.ScannerGroupsDetails(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannerGroupsDetailsResponse(rsp)
}

// ScannerGroupsEditWithBodyWithResponse request with arbitrary body returning *ScannerGroupsEditResponse
func (c *ClientWithResponses) ScannerGroupsEditWithBodyWithResponse(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScannerGroupsEditResponse, error) {
	rsp, err := c.ScannerGroupsEditWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannerGroupsEditResponse(rsp)
}

func (c *ClientWithResponses) ScannerGroupsEditWithResponse(ctx context.Context, groupId int32, body ScannerGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*ScannerGroupsEditResponse, error) {
	rsp, err := c.ScannerGroupsEdit(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannerGroupsEditResponse(rsp)
}

// IoScannerGroupsListRoutesWithResponse request returning *IoScannerGroupsListRoutesResponse
func (c *ClientWithResponses) IoScannerGroupsListRoutesWithResponse(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*IoScannerGroupsListRoutesResponse, error) {
	rsp, err := c.IoScannerGroupsListRoutes(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoScannerGroupsListRoutesResponse(rsp)
}

// IoScannerGroupsUpdateRoutesWithBodyWithResponse request with arbitrary body returning *IoScannerGroupsUpdateRoutesResponse
func (c *ClientWithResponses) IoScannerGroupsUpdateRoutesWithBodyWithResponse(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoScannerGroupsUpdateRoutesResponse, error) {
	rsp, err := c.IoScannerGroupsUpdateRoutesWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoScannerGroupsUpdateRoutesResponse(rsp)
}

func (c *ClientWithResponses) IoScannerGroupsUpdateRoutesWithResponse(ctx context.Context, groupId int32, body IoScannerGroupsUpdateRoutesJSONRequestBody, reqEditors ...RequestEditorFn) (*IoScannerGroupsUpdateRoutesResponse, error) {
	rsp, err := c.IoScannerGroupsUpdateRoutes(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoScannerGroupsUpdateRoutesResponse(rsp)
}

// ScannerGroupsListScannersWithResponse request returning *ScannerGroupsListScannersResponse
func (c *ClientWithResponses) ScannerGroupsListScannersWithResponse(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*ScannerGroupsListScannersResponse, error) {
	rsp, err := c.ScannerGroupsListScanners(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannerGroupsListScannersResponse(rsp)
}

// ScannerGroupsDeleteScannerWithResponse request returning *ScannerGroupsDeleteScannerResponse
func (c *ClientWithResponses) ScannerGroupsDeleteScannerWithResponse(ctx context.Context, groupId int32, scannerId int32, reqEditors ...RequestEditorFn) (*ScannerGroupsDeleteScannerResponse, error) {
	rsp, err := c.ScannerGroupsDeleteScanner(ctx, groupId, scannerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannerGroupsDeleteScannerResponse(rsp)
}

// ScannerGroupsAddScannerWithResponse request returning *ScannerGroupsAddScannerResponse
func (c *ClientWithResponses) ScannerGroupsAddScannerWithResponse(ctx context.Context, groupId int32, scannerId int32, reqEditors ...RequestEditorFn) (*ScannerGroupsAddScannerResponse, error) {
	rsp, err := c.ScannerGroupsAddScanner(ctx, groupId, scannerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannerGroupsAddScannerResponse(rsp)
}

// ScannersListWithResponse request returning *ScannersListResponse
func (c *ClientWithResponses) ScannersListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScannersListResponse, error) {
	rsp, err := c.ScannersList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannersListResponse(rsp)
}

// BulkAddAgentsWithBodyWithResponse request with arbitrary body returning *BulkAddAgentsResponse
func (c *ClientWithResponses) BulkAddAgentsWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkAddAgentsResponse, error) {
	rsp, err := c.BulkAddAgentsWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddAgentsResponse(rsp)
}

func (c *ClientWithResponses) BulkAddAgentsWithResponse(ctx context.Context, groupId string, body BulkAddAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkAddAgentsResponse, error) {
	rsp, err := c.BulkAddAgents(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkAddAgentsResponse(rsp)
}

// IoAgentBulkOperationsGroupDirectiveWithBodyWithResponse request with arbitrary body returning *IoAgentBulkOperationsGroupDirectiveResponse
func (c *ClientWithResponses) IoAgentBulkOperationsGroupDirectiveWithBodyWithResponse(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsGroupDirectiveResponse, error) {
	rsp, err := c.IoAgentBulkOperationsGroupDirectiveWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoAgentBulkOperationsGroupDirectiveResponse(rsp)
}

func (c *ClientWithResponses) IoAgentBulkOperationsGroupDirectiveWithResponse(ctx context.Context, groupId int32, body IoAgentBulkOperationsGroupDirectiveJSONRequestBody, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsGroupDirectiveResponse, error) {
	rsp, err := c.IoAgentBulkOperationsGroupDirective(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoAgentBulkOperationsGroupDirectiveResponse(rsp)
}

// BulkRemoveAgentsWithBodyWithResponse request with arbitrary body returning *BulkRemoveAgentsResponse
func (c *ClientWithResponses) BulkRemoveAgentsWithBodyWithResponse(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkRemoveAgentsResponse, error) {
	rsp, err := c.BulkRemoveAgentsWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkRemoveAgentsResponse(rsp)
}

func (c *ClientWithResponses) BulkRemoveAgentsWithResponse(ctx context.Context, groupId int32, body BulkRemoveAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkRemoveAgentsResponse, error) {
	rsp, err := c.BulkRemoveAgents(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkRemoveAgentsResponse(rsp)
}

// BulkTaskAgentGroupStatusWithResponse request returning *BulkTaskAgentGroupStatusResponse
func (c *ClientWithResponses) BulkTaskAgentGroupStatusWithResponse(ctx context.Context, groupId int32, taskUuid string, reqEditors ...RequestEditorFn) (*BulkTaskAgentGroupStatusResponse, error) {
	rsp, err := c.BulkTaskAgentGroupStatus(ctx, groupId, taskUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkTaskAgentGroupStatusResponse(rsp)
}

// IoAgentBulkOperationsAddToNetworkWithBodyWithResponse request with arbitrary body returning *IoAgentBulkOperationsAddToNetworkResponse
func (c *ClientWithResponses) IoAgentBulkOperationsAddToNetworkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsAddToNetworkResponse, error) {
	rsp, err := c.IoAgentBulkOperationsAddToNetworkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoAgentBulkOperationsAddToNetworkResponse(rsp)
}

func (c *ClientWithResponses) IoAgentBulkOperationsAddToNetworkWithResponse(ctx context.Context, body IoAgentBulkOperationsAddToNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsAddToNetworkResponse, error) {
	rsp, err := c.IoAgentBulkOperationsAddToNetwork(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoAgentBulkOperationsAddToNetworkResponse(rsp)
}

// IoAgentBulkOperationsDirectiveWithBodyWithResponse request with arbitrary body returning *IoAgentBulkOperationsDirectiveResponse
func (c *ClientWithResponses) IoAgentBulkOperationsDirectiveWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsDirectiveResponse, error) {
	rsp, err := c.IoAgentBulkOperationsDirectiveWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoAgentBulkOperationsDirectiveResponse(rsp)
}

func (c *ClientWithResponses) IoAgentBulkOperationsDirectiveWithResponse(ctx context.Context, body IoAgentBulkOperationsDirectiveJSONRequestBody, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsDirectiveResponse, error) {
	rsp, err := c.IoAgentBulkOperationsDirective(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoAgentBulkOperationsDirectiveResponse(rsp)
}

// IoAgentBulkOperationsRemoveFromNetworkWithBodyWithResponse request with arbitrary body returning *IoAgentBulkOperationsRemoveFromNetworkResponse
func (c *ClientWithResponses) IoAgentBulkOperationsRemoveFromNetworkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsRemoveFromNetworkResponse, error) {
	rsp, err := c.IoAgentBulkOperationsRemoveFromNetworkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoAgentBulkOperationsRemoveFromNetworkResponse(rsp)
}

func (c *ClientWithResponses) IoAgentBulkOperationsRemoveFromNetworkWithResponse(ctx context.Context, body IoAgentBulkOperationsRemoveFromNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*IoAgentBulkOperationsRemoveFromNetworkResponse, error) {
	rsp, err := c.IoAgentBulkOperationsRemoveFromNetwork(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoAgentBulkOperationsRemoveFromNetworkResponse(rsp)
}

// BulkUnlinkAgentsWithBodyWithResponse request with arbitrary body returning *BulkUnlinkAgentsResponse
func (c *ClientWithResponses) BulkUnlinkAgentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUnlinkAgentsResponse, error) {
	rsp, err := c.BulkUnlinkAgentsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUnlinkAgentsResponse(rsp)
}

func (c *ClientWithResponses) BulkUnlinkAgentsWithResponse(ctx context.Context, body BulkUnlinkAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUnlinkAgentsResponse, error) {
	rsp, err := c.BulkUnlinkAgents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUnlinkAgentsResponse(rsp)
}

// BulkTaskAgentStatusWithResponse request returning *BulkTaskAgentStatusResponse
func (c *ClientWithResponses) BulkTaskAgentStatusWithResponse(ctx context.Context, taskUuid string, reqEditors ...RequestEditorFn) (*BulkTaskAgentStatusResponse, error) {
	rsp, err := c.BulkTaskAgentStatus(ctx, taskUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkTaskAgentStatusResponse(rsp)
}

// ScannersDeleteWithResponse request returning *ScannersDeleteResponse
func (c *ClientWithResponses) ScannersDeleteWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*ScannersDeleteResponse, error) {
	rsp, err := c.ScannersDelete(ctx, scannerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannersDeleteResponse(rsp)
}

// ScannersDetailsWithResponse request returning *ScannersDetailsResponse
func (c *ClientWithResponses) ScannersDetailsWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*ScannersDetailsResponse, error) {
	rsp, err := c.ScannersDetails(ctx, scannerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannersDetailsResponse(rsp)
}

// ScannersEditWithBodyWithResponse request with arbitrary body returning *ScannersEditResponse
func (c *ClientWithResponses) ScannersEditWithBodyWithResponse(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScannersEditResponse, error) {
	rsp, err := c.ScannersEditWithBody(ctx, scannerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannersEditResponse(rsp)
}

func (c *ClientWithResponses) ScannersEditWithResponse(ctx context.Context, scannerId int32, body ScannersEditJSONRequestBody, reqEditors ...RequestEditorFn) (*ScannersEditResponse, error) {
	rsp, err := c.ScannersEdit(ctx, scannerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannersEditResponse(rsp)
}

// AgentGroupsListWithResponse request returning *AgentGroupsListResponse
func (c *ClientWithResponses) AgentGroupsListWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*AgentGroupsListResponse, error) {
	rsp, err := c.AgentGroupsList(ctx, scannerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentGroupsListResponse(rsp)
}

// AgentGroupsCreateWithBodyWithResponse request with arbitrary body returning *AgentGroupsCreateResponse
func (c *ClientWithResponses) AgentGroupsCreateWithBodyWithResponse(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AgentGroupsCreateResponse, error) {
	rsp, err := c.AgentGroupsCreateWithBody(ctx, scannerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentGroupsCreateResponse(rsp)
}

func (c *ClientWithResponses) AgentGroupsCreateWithResponse(ctx context.Context, scannerId int32, body AgentGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AgentGroupsCreateResponse, error) {
	rsp, err := c.AgentGroupsCreate(ctx, scannerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentGroupsCreateResponse(rsp)
}

// AgentGroupListAgentsWithResponse request returning *AgentGroupListAgentsResponse
func (c *ClientWithResponses) AgentGroupListAgentsWithResponse(ctx context.Context, scannerId int32, agentGroupId int32, params *AgentGroupListAgentsParams, reqEditors ...RequestEditorFn) (*AgentGroupListAgentsResponse, error) {
	rsp, err := c.AgentGroupListAgents(ctx, scannerId, agentGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentGroupListAgentsResponse(rsp)
}

// AgentGroupsDeleteWithResponse request returning *AgentGroupsDeleteResponse
func (c *ClientWithResponses) AgentGroupsDeleteWithResponse(ctx context.Context, scannerId int32, groupId int32, reqEditors ...RequestEditorFn) (*AgentGroupsDeleteResponse, error) {
	rsp, err := c.AgentGroupsDelete(ctx, scannerId, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentGroupsDeleteResponse(rsp)
}

// AgentGroupsDetailsWithResponse request returning *AgentGroupsDetailsResponse
func (c *ClientWithResponses) AgentGroupsDetailsWithResponse(ctx context.Context, scannerId int32, groupId int32, params *AgentGroupsDetailsParams, reqEditors ...RequestEditorFn) (*AgentGroupsDetailsResponse, error) {
	rsp, err := c.AgentGroupsDetails(ctx, scannerId, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentGroupsDetailsResponse(rsp)
}

// AgentGroupsConfigureWithBodyWithResponse request with arbitrary body returning *AgentGroupsConfigureResponse
func (c *ClientWithResponses) AgentGroupsConfigureWithBodyWithResponse(ctx context.Context, scannerId int32, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AgentGroupsConfigureResponse, error) {
	rsp, err := c.AgentGroupsConfigureWithBody(ctx, scannerId, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentGroupsConfigureResponse(rsp)
}

func (c *ClientWithResponses) AgentGroupsConfigureWithResponse(ctx context.Context, scannerId int32, groupId int32, body AgentGroupsConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*AgentGroupsConfigureResponse, error) {
	rsp, err := c.AgentGroupsConfigure(ctx, scannerId, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentGroupsConfigureResponse(rsp)
}

// AgentGroupsDeleteAgentWithResponse request returning *AgentGroupsDeleteAgentResponse
func (c *ClientWithResponses) AgentGroupsDeleteAgentWithResponse(ctx context.Context, scannerId int32, groupId int32, agentId int32, reqEditors ...RequestEditorFn) (*AgentGroupsDeleteAgentResponse, error) {
	rsp, err := c.AgentGroupsDeleteAgent(ctx, scannerId, groupId, agentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentGroupsDeleteAgentResponse(rsp)
}

// AgentGroupsAddAgentWithResponse request returning *AgentGroupsAddAgentResponse
func (c *ClientWithResponses) AgentGroupsAddAgentWithResponse(ctx context.Context, scannerId int32, groupId int32, agentId int32, reqEditors ...RequestEditorFn) (*AgentGroupsAddAgentResponse, error) {
	rsp, err := c.AgentGroupsAddAgent(ctx, scannerId, groupId, agentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentGroupsAddAgentResponse(rsp)
}

// AgentsListWithResponse request returning *AgentsListResponse
func (c *ClientWithResponses) AgentsListWithResponse(ctx context.Context, scannerId int32, params *AgentsListParams, reqEditors ...RequestEditorFn) (*AgentsListResponse, error) {
	rsp, err := c.AgentsList(ctx, scannerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentsListResponse(rsp)
}

// AgentConfigDetailsWithResponse request returning *AgentConfigDetailsResponse
func (c *ClientWithResponses) AgentConfigDetailsWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*AgentConfigDetailsResponse, error) {
	rsp, err := c.AgentConfigDetails(ctx, scannerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentConfigDetailsResponse(rsp)
}

// AgentConfigEditWithBodyWithResponse request with arbitrary body returning *AgentConfigEditResponse
func (c *ClientWithResponses) AgentConfigEditWithBodyWithResponse(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AgentConfigEditResponse, error) {
	rsp, err := c.AgentConfigEditWithBody(ctx, scannerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentConfigEditResponse(rsp)
}

func (c *ClientWithResponses) AgentConfigEditWithResponse(ctx context.Context, scannerId int32, body AgentConfigEditJSONRequestBody, reqEditors ...RequestEditorFn) (*AgentConfigEditResponse, error) {
	rsp, err := c.AgentConfigEdit(ctx, scannerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentConfigEditResponse(rsp)
}

// AgentExclusionsListWithResponse request returning *AgentExclusionsListResponse
func (c *ClientWithResponses) AgentExclusionsListWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*AgentExclusionsListResponse, error) {
	rsp, err := c.AgentExclusionsList(ctx, scannerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentExclusionsListResponse(rsp)
}

// AgentExclusionsCreateWithBodyWithResponse request with arbitrary body returning *AgentExclusionsCreateResponse
func (c *ClientWithResponses) AgentExclusionsCreateWithBodyWithResponse(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AgentExclusionsCreateResponse, error) {
	rsp, err := c.AgentExclusionsCreateWithBody(ctx, scannerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentExclusionsCreateResponse(rsp)
}

func (c *ClientWithResponses) AgentExclusionsCreateWithResponse(ctx context.Context, scannerId int32, body AgentExclusionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*AgentExclusionsCreateResponse, error) {
	rsp, err := c.AgentExclusionsCreate(ctx, scannerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentExclusionsCreateResponse(rsp)
}

// AgentExclusionsDeleteWithResponse request returning *AgentExclusionsDeleteResponse
func (c *ClientWithResponses) AgentExclusionsDeleteWithResponse(ctx context.Context, scannerId int32, exclusionId int32, reqEditors ...RequestEditorFn) (*AgentExclusionsDeleteResponse, error) {
	rsp, err := c.AgentExclusionsDelete(ctx, scannerId, exclusionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentExclusionsDeleteResponse(rsp)
}

// AgentExclusionsDetailsWithResponse request returning *AgentExclusionsDetailsResponse
func (c *ClientWithResponses) AgentExclusionsDetailsWithResponse(ctx context.Context, scannerId int32, exclusionId int32, reqEditors ...RequestEditorFn) (*AgentExclusionsDetailsResponse, error) {
	rsp, err := c.AgentExclusionsDetails(ctx, scannerId, exclusionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentExclusionsDetailsResponse(rsp)
}

// AgentExclusionsEditWithBodyWithResponse request with arbitrary body returning *AgentExclusionsEditResponse
func (c *ClientWithResponses) AgentExclusionsEditWithBodyWithResponse(ctx context.Context, scannerId int32, exclusionId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AgentExclusionsEditResponse, error) {
	rsp, err := c.AgentExclusionsEditWithBody(ctx, scannerId, exclusionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentExclusionsEditResponse(rsp)
}

func (c *ClientWithResponses) AgentExclusionsEditWithResponse(ctx context.Context, scannerId int32, exclusionId int32, body AgentExclusionsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*AgentExclusionsEditResponse, error) {
	rsp, err := c.AgentExclusionsEdit(ctx, scannerId, exclusionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentExclusionsEditResponse(rsp)
}

// AgentsDeleteWithResponse request returning *AgentsDeleteResponse
func (c *ClientWithResponses) AgentsDeleteWithResponse(ctx context.Context, scannerId int32, agentId int32, reqEditors ...RequestEditorFn) (*AgentsDeleteResponse, error) {
	rsp, err := c.AgentsDelete(ctx, scannerId, agentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentsDeleteResponse(rsp)
}

// AgentsGetWithResponse request returning *AgentsGetResponse
func (c *ClientWithResponses) AgentsGetWithResponse(ctx context.Context, scannerId int32, agentId int32, reqEditors ...RequestEditorFn) (*AgentsGetResponse, error) {
	rsp, err := c.AgentsGet(ctx, scannerId, agentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAgentsGetResponse(rsp)
}

// ScannersGetAwsTargetsWithResponse request returning *ScannersGetAwsTargetsResponse
func (c *ClientWithResponses) ScannersGetAwsTargetsWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*ScannersGetAwsTargetsResponse, error) {
	rsp, err := c.ScannersGetAwsTargets(ctx, scannerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannersGetAwsTargetsResponse(rsp)
}

// ScannersGetScannerKeyWithResponse request returning *ScannersGetScannerKeyResponse
func (c *ClientWithResponses) ScannersGetScannerKeyWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*ScannersGetScannerKeyResponse, error) {
	rsp, err := c.ScannersGetScannerKey(ctx, scannerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannersGetScannerKeyResponse(rsp)
}

// ScannersToggleLinkStateWithBodyWithResponse request with arbitrary body returning *ScannersToggleLinkStateResponse
func (c *ClientWithResponses) ScannersToggleLinkStateWithBodyWithResponse(ctx context.Context, scannerId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScannersToggleLinkStateResponse, error) {
	rsp, err := c.ScannersToggleLinkStateWithBody(ctx, scannerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannersToggleLinkStateResponse(rsp)
}

func (c *ClientWithResponses) ScannersToggleLinkStateWithResponse(ctx context.Context, scannerId int32, body ScannersToggleLinkStateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScannersToggleLinkStateResponse, error) {
	rsp, err := c.ScannersToggleLinkState(ctx, scannerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannersToggleLinkStateResponse(rsp)
}

// ScannersGetScansWithResponse request returning *ScannersGetScansResponse
func (c *ClientWithResponses) ScannersGetScansWithResponse(ctx context.Context, scannerId int32, reqEditors ...RequestEditorFn) (*ScannersGetScansResponse, error) {
	rsp, err := c.ScannersGetScans(ctx, scannerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannersGetScansResponse(rsp)
}

// ScannersControlScansWithBodyWithResponse request with arbitrary body returning *ScannersControlScansResponse
func (c *ClientWithResponses) ScannersControlScansWithBodyWithResponse(ctx context.Context, scannerId int32, scanUuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScannersControlScansResponse, error) {
	rsp, err := c.ScannersControlScansWithBody(ctx, scannerId, scanUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannersControlScansResponse(rsp)
}

func (c *ClientWithResponses) ScannersControlScansWithResponse(ctx context.Context, scannerId int32, scanUuid string, body ScannersControlScansJSONRequestBody, reqEditors ...RequestEditorFn) (*ScannersControlScansResponse, error) {
	rsp, err := c.ScannersControlScans(ctx, scannerId, scanUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannersControlScansResponse(rsp)
}

// ScansListWithResponse request returning *ScansListResponse
func (c *ClientWithResponses) ScansListWithResponse(ctx context.Context, params *ScansListParams, reqEditors ...RequestEditorFn) (*ScansListResponse, error) {
	rsp, err := c.ScansList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansListResponse(rsp)
}

// ScansCreateWithBodyWithResponse request with arbitrary body returning *ScansCreateResponse
func (c *ClientWithResponses) ScansCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansCreateResponse, error) {
	rsp, err := c.ScansCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansCreateResponse(rsp)
}

func (c *ClientWithResponses) ScansCreateWithResponse(ctx context.Context, body ScansCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansCreateResponse, error) {
	rsp, err := c.ScansCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansCreateResponse(rsp)
}

// IoScansCheckAutoTargetsWithBodyWithResponse request with arbitrary body returning *IoScansCheckAutoTargetsResponse
func (c *ClientWithResponses) IoScansCheckAutoTargetsWithBodyWithResponse(ctx context.Context, params *IoScansCheckAutoTargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoScansCheckAutoTargetsResponse, error) {
	rsp, err := c.IoScansCheckAutoTargetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoScansCheckAutoTargetsResponse(rsp)
}

func (c *ClientWithResponses) IoScansCheckAutoTargetsWithResponse(ctx context.Context, params *IoScansCheckAutoTargetsParams, body IoScansCheckAutoTargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*IoScansCheckAutoTargetsResponse, error) {
	rsp, err := c.IoScansCheckAutoTargets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoScansCheckAutoTargetsResponse(rsp)
}

// ScansImportWithBodyWithResponse request with arbitrary body returning *ScansImportResponse
func (c *ClientWithResponses) ScansImportWithBodyWithResponse(ctx context.Context, params *ScansImportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansImportResponse, error) {
	rsp, err := c.ScansImportWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansImportResponse(rsp)
}

func (c *ClientWithResponses) ScansImportWithResponse(ctx context.Context, params *ScansImportParams, body ScansImportJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansImportResponse, error) {
	rsp, err := c.ScansImport(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansImportResponse(rsp)
}

// IoScansRemediationListWithResponse request returning *IoScansRemediationListResponse
func (c *ClientWithResponses) IoScansRemediationListWithResponse(ctx context.Context, params *IoScansRemediationListParams, reqEditors ...RequestEditorFn) (*IoScansRemediationListResponse, error) {
	rsp, err := c.IoScansRemediationList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoScansRemediationListResponse(rsp)
}

// IoScansRemediationCreateWithBodyWithResponse request with arbitrary body returning *IoScansRemediationCreateResponse
func (c *ClientWithResponses) IoScansRemediationCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoScansRemediationCreateResponse, error) {
	rsp, err := c.IoScansRemediationCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoScansRemediationCreateResponse(rsp)
}

func (c *ClientWithResponses) IoScansRemediationCreateWithResponse(ctx context.Context, body IoScansRemediationCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IoScansRemediationCreateResponse, error) {
	rsp, err := c.IoScansRemediationCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoScansRemediationCreateResponse(rsp)
}

// ScansTimezonesWithResponse request returning *ScansTimezonesResponse
func (c *ClientWithResponses) ScansTimezonesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ScansTimezonesResponse, error) {
	rsp, err := c.ScansTimezones(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansTimezonesResponse(rsp)
}

// ScansDeleteWithResponse request returning *ScansDeleteResponse
func (c *ClientWithResponses) ScansDeleteWithResponse(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*ScansDeleteResponse, error) {
	rsp, err := c.ScansDelete(ctx, scanId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansDeleteResponse(rsp)
}

// ScansDetailsWithResponse request returning *ScansDetailsResponse
func (c *ClientWithResponses) ScansDetailsWithResponse(ctx context.Context, scanId string, params *ScansDetailsParams, reqEditors ...RequestEditorFn) (*ScansDetailsResponse, error) {
	rsp, err := c.ScansDetails(ctx, scanId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansDetailsResponse(rsp)
}

// ScansConfigureWithBodyWithResponse request with arbitrary body returning *ScansConfigureResponse
func (c *ClientWithResponses) ScansConfigureWithBodyWithResponse(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansConfigureResponse, error) {
	rsp, err := c.ScansConfigureWithBody(ctx, scanId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansConfigureResponse(rsp)
}

func (c *ClientWithResponses) ScansConfigureWithResponse(ctx context.Context, scanId string, body ScansConfigureJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansConfigureResponse, error) {
	rsp, err := c.ScansConfigure(ctx, scanId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansConfigureResponse(rsp)
}

// ScansAttachmentsWithResponse request returning *ScansAttachmentsResponse
func (c *ClientWithResponses) ScansAttachmentsWithResponse(ctx context.Context, scanId string, attachmentId string, params *ScansAttachmentsParams, reqEditors ...RequestEditorFn) (*ScansAttachmentsResponse, error) {
	rsp, err := c.ScansAttachments(ctx, scanId, attachmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansAttachmentsResponse(rsp)
}

// ScansCopyWithBodyWithResponse request with arbitrary body returning *ScansCopyResponse
func (c *ClientWithResponses) ScansCopyWithBodyWithResponse(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansCopyResponse, error) {
	rsp, err := c.ScansCopyWithBody(ctx, scanId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansCopyResponse(rsp)
}

func (c *ClientWithResponses) ScansCopyWithResponse(ctx context.Context, scanId string, body ScansCopyJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansCopyResponse, error) {
	rsp, err := c.ScansCopy(ctx, scanId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansCopyResponse(rsp)
}

// IoScansCredentialsConvertWithBodyWithResponse request with arbitrary body returning *IoScansCredentialsConvertResponse
func (c *ClientWithResponses) IoScansCredentialsConvertWithBodyWithResponse(ctx context.Context, scanId int, credentialsId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoScansCredentialsConvertResponse, error) {
	rsp, err := c.IoScansCredentialsConvertWithBody(ctx, scanId, credentialsId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoScansCredentialsConvertResponse(rsp)
}

func (c *ClientWithResponses) IoScansCredentialsConvertWithResponse(ctx context.Context, scanId int, credentialsId int, body IoScansCredentialsConvertJSONRequestBody, reqEditors ...RequestEditorFn) (*IoScansCredentialsConvertResponse, error) {
	rsp, err := c.IoScansCredentialsConvert(ctx, scanId, credentialsId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoScansCredentialsConvertResponse(rsp)
}

// ScansExportRequestWithBodyWithResponse request with arbitrary body returning *ScansExportRequestResponse
func (c *ClientWithResponses) ScansExportRequestWithBodyWithResponse(ctx context.Context, scanId string, params *ScansExportRequestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansExportRequestResponse, error) {
	rsp, err := c.ScansExportRequestWithBody(ctx, scanId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansExportRequestResponse(rsp)
}

func (c *ClientWithResponses) ScansExportRequestWithResponse(ctx context.Context, scanId string, params *ScansExportRequestParams, body ScansExportRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansExportRequestResponse, error) {
	rsp, err := c.ScansExportRequest(ctx, scanId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansExportRequestResponse(rsp)
}

// ScansExportDownloadWithResponse request returning *ScansExportDownloadResponse
func (c *ClientWithResponses) ScansExportDownloadWithResponse(ctx context.Context, scanId string, fileId string, reqEditors ...RequestEditorFn) (*ScansExportDownloadResponse, error) {
	rsp, err := c.ScansExportDownload(ctx, scanId, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansExportDownloadResponse(rsp)
}

// ScansExportStatusWithResponse request returning *ScansExportStatusResponse
func (c *ClientWithResponses) ScansExportStatusWithResponse(ctx context.Context, scanId string, fileId string, reqEditors ...RequestEditorFn) (*ScansExportStatusResponse, error) {
	rsp, err := c.ScansExportStatus(ctx, scanId, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansExportStatusResponse(rsp)
}

// ScansHistoryWithResponse request returning *ScansHistoryResponse
func (c *ClientWithResponses) ScansHistoryWithResponse(ctx context.Context, scanId string, params *ScansHistoryParams, reqEditors ...RequestEditorFn) (*ScansHistoryResponse, error) {
	rsp, err := c.ScansHistory(ctx, scanId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansHistoryResponse(rsp)
}

// ScansDeleteHistoryWithResponse request returning *ScansDeleteHistoryResponse
func (c *ClientWithResponses) ScansDeleteHistoryWithResponse(ctx context.Context, scanId string, historyId int32, reqEditors ...RequestEditorFn) (*ScansDeleteHistoryResponse, error) {
	rsp, err := c.ScansDeleteHistory(ctx, scanId, historyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansDeleteHistoryResponse(rsp)
}

// ScansHistoryDetailsWithResponse request returning *ScansHistoryDetailsResponse
func (c *ClientWithResponses) ScansHistoryDetailsWithResponse(ctx context.Context, scanId string, historyUuid string, reqEditors ...RequestEditorFn) (*ScansHistoryDetailsResponse, error) {
	rsp, err := c.ScansHistoryDetails(ctx, scanId, historyUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansHistoryDetailsResponse(rsp)
}

// ScansGetLatestStatusWithResponse request returning *ScansGetLatestStatusResponse
func (c *ClientWithResponses) ScansGetLatestStatusWithResponse(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*ScansGetLatestStatusResponse, error) {
	rsp, err := c.ScansGetLatestStatus(ctx, scanId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansGetLatestStatusResponse(rsp)
}

// ScansLaunchWithBodyWithResponse request with arbitrary body returning *ScansLaunchResponse
func (c *ClientWithResponses) ScansLaunchWithBodyWithResponse(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansLaunchResponse, error) {
	rsp, err := c.ScansLaunchWithBody(ctx, scanId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansLaunchResponse(rsp)
}

func (c *ClientWithResponses) ScansLaunchWithResponse(ctx context.Context, scanId string, body ScansLaunchJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansLaunchResponse, error) {
	rsp, err := c.ScansLaunch(ctx, scanId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansLaunchResponse(rsp)
}

// ScansPauseWithResponse request returning *ScansPauseResponse
func (c *ClientWithResponses) ScansPauseWithResponse(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*ScansPauseResponse, error) {
	rsp, err := c.ScansPause(ctx, scanId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansPauseResponse(rsp)
}

// ScansResumeWithResponse request returning *ScansResumeResponse
func (c *ClientWithResponses) ScansResumeWithResponse(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*ScansResumeResponse, error) {
	rsp, err := c.ScansResume(ctx, scanId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansResumeResponse(rsp)
}

// ScansScheduleWithBodyWithResponse request with arbitrary body returning *ScansScheduleResponse
func (c *ClientWithResponses) ScansScheduleWithBodyWithResponse(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansScheduleResponse, error) {
	rsp, err := c.ScansScheduleWithBody(ctx, scanId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansScheduleResponse(rsp)
}

func (c *ClientWithResponses) ScansScheduleWithResponse(ctx context.Context, scanId string, body ScansScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansScheduleResponse, error) {
	rsp, err := c.ScansSchedule(ctx, scanId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansScheduleResponse(rsp)
}

// ScansReadStatusWithBodyWithResponse request with arbitrary body returning *ScansReadStatusResponse
func (c *ClientWithResponses) ScansReadStatusWithBodyWithResponse(ctx context.Context, scanId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScansReadStatusResponse, error) {
	rsp, err := c.ScansReadStatusWithBody(ctx, scanId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansReadStatusResponse(rsp)
}

func (c *ClientWithResponses) ScansReadStatusWithResponse(ctx context.Context, scanId string, body ScansReadStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*ScansReadStatusResponse, error) {
	rsp, err := c.ScansReadStatus(ctx, scanId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansReadStatusResponse(rsp)
}

// ScansStopWithResponse request returning *ScansStopResponse
func (c *ClientWithResponses) ScansStopWithResponse(ctx context.Context, scanId string, reqEditors ...RequestEditorFn) (*ScansStopResponse, error) {
	rsp, err := c.ScansStop(ctx, scanId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansStopResponse(rsp)
}

// ScansHostDetailsWithResponse request returning *ScansHostDetailsResponse
func (c *ClientWithResponses) ScansHostDetailsWithResponse(ctx context.Context, scanUuid string, hostId int32, params *ScansHostDetailsParams, reqEditors ...RequestEditorFn) (*ScansHostDetailsResponse, error) {
	rsp, err := c.ScansHostDetails(ctx, scanUuid, hostId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansHostDetailsResponse(rsp)
}

// ScansPluginOutputWithResponse request returning *ScansPluginOutputResponse
func (c *ClientWithResponses) ScansPluginOutputWithResponse(ctx context.Context, scanUuid string, hostId int32, pluginId int32, params *ScansPluginOutputParams, reqEditors ...RequestEditorFn) (*ScansPluginOutputResponse, error) {
	rsp, err := c.ScansPluginOutput(ctx, scanUuid, hostId, pluginId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScansPluginOutputResponse(rsp)
}

// ServerPropertiesWithResponse request returning *ServerPropertiesResponse
func (c *ClientWithResponses) ServerPropertiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ServerPropertiesResponse, error) {
	rsp, err := c.ServerProperties(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServerPropertiesResponse(rsp)
}

// ServerStatusWithResponse request returning *ServerStatusResponse
func (c *ClientWithResponses) ServerStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ServerStatusResponse, error) {
	rsp, err := c.ServerStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServerStatusResponse(rsp)
}

// TagsAssignAssetTagsWithBodyWithResponse request with arbitrary body returning *TagsAssignAssetTagsResponse
func (c *ClientWithResponses) TagsAssignAssetTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsAssignAssetTagsResponse, error) {
	rsp, err := c.TagsAssignAssetTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsAssignAssetTagsResponse(rsp)
}

func (c *ClientWithResponses) TagsAssignAssetTagsWithResponse(ctx context.Context, body TagsAssignAssetTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsAssignAssetTagsResponse, error) {
	rsp, err := c.TagsAssignAssetTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsAssignAssetTagsResponse(rsp)
}

// TagsListAssetFiltersWithResponse request returning *TagsListAssetFiltersResponse
func (c *ClientWithResponses) TagsListAssetFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TagsListAssetFiltersResponse, error) {
	rsp, err := c.TagsListAssetFilters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsListAssetFiltersResponse(rsp)
}

// TagsListAssetTagsWithResponse request returning *TagsListAssetTagsResponse
func (c *ClientWithResponses) TagsListAssetTagsWithResponse(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*TagsListAssetTagsResponse, error) {
	rsp, err := c.TagsListAssetTags(ctx, assetUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsListAssetTagsResponse(rsp)
}

// TagsListTagCategoriesWithResponse request returning *TagsListTagCategoriesResponse
func (c *ClientWithResponses) TagsListTagCategoriesWithResponse(ctx context.Context, params *TagsListTagCategoriesParams, reqEditors ...RequestEditorFn) (*TagsListTagCategoriesResponse, error) {
	rsp, err := c.TagsListTagCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsListTagCategoriesResponse(rsp)
}

// TagsCreateTagCategoryWithBodyWithResponse request with arbitrary body returning *TagsCreateTagCategoryResponse
func (c *ClientWithResponses) TagsCreateTagCategoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsCreateTagCategoryResponse, error) {
	rsp, err := c.TagsCreateTagCategoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsCreateTagCategoryResponse(rsp)
}

func (c *ClientWithResponses) TagsCreateTagCategoryWithResponse(ctx context.Context, body TagsCreateTagCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsCreateTagCategoryResponse, error) {
	rsp, err := c.TagsCreateTagCategory(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsCreateTagCategoryResponse(rsp)
}

// TagsDeleteTagCategoryWithResponse request returning *TagsDeleteTagCategoryResponse
func (c *ClientWithResponses) TagsDeleteTagCategoryWithResponse(ctx context.Context, categoryUuid string, reqEditors ...RequestEditorFn) (*TagsDeleteTagCategoryResponse, error) {
	rsp, err := c.TagsDeleteTagCategory(ctx, categoryUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsDeleteTagCategoryResponse(rsp)
}

// TagsTagCategoryDetailsWithResponse request returning *TagsTagCategoryDetailsResponse
func (c *ClientWithResponses) TagsTagCategoryDetailsWithResponse(ctx context.Context, categoryUuid string, reqEditors ...RequestEditorFn) (*TagsTagCategoryDetailsResponse, error) {
	rsp, err := c.TagsTagCategoryDetails(ctx, categoryUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsTagCategoryDetailsResponse(rsp)
}

// TagsEditTagCategoryWithBodyWithResponse request with arbitrary body returning *TagsEditTagCategoryResponse
func (c *ClientWithResponses) TagsEditTagCategoryWithBodyWithResponse(ctx context.Context, categoryUuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsEditTagCategoryResponse, error) {
	rsp, err := c.TagsEditTagCategoryWithBody(ctx, categoryUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsEditTagCategoryResponse(rsp)
}

func (c *ClientWithResponses) TagsEditTagCategoryWithResponse(ctx context.Context, categoryUuid string, body TagsEditTagCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsEditTagCategoryResponse, error) {
	rsp, err := c.TagsEditTagCategory(ctx, categoryUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsEditTagCategoryResponse(rsp)
}

// TagsListTagValuesWithResponse request returning *TagsListTagValuesResponse
func (c *ClientWithResponses) TagsListTagValuesWithResponse(ctx context.Context, params *TagsListTagValuesParams, reqEditors ...RequestEditorFn) (*TagsListTagValuesResponse, error) {
	rsp, err := c.TagsListTagValues(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsListTagValuesResponse(rsp)
}

// TagsCreateTagValueWithBodyWithResponse request with arbitrary body returning *TagsCreateTagValueResponse
func (c *ClientWithResponses) TagsCreateTagValueWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsCreateTagValueResponse, error) {
	rsp, err := c.TagsCreateTagValueWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsCreateTagValueResponse(rsp)
}

func (c *ClientWithResponses) TagsCreateTagValueWithResponse(ctx context.Context, body TagsCreateTagValueJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsCreateTagValueResponse, error) {
	rsp, err := c.TagsCreateTagValue(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsCreateTagValueResponse(rsp)
}

// TagsDeleteTagValuesBulkWithBodyWithResponse request with arbitrary body returning *TagsDeleteTagValuesBulkResponse
func (c *ClientWithResponses) TagsDeleteTagValuesBulkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsDeleteTagValuesBulkResponse, error) {
	rsp, err := c.TagsDeleteTagValuesBulkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsDeleteTagValuesBulkResponse(rsp)
}

func (c *ClientWithResponses) TagsDeleteTagValuesBulkWithResponse(ctx context.Context, body TagsDeleteTagValuesBulkJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsDeleteTagValuesBulkResponse, error) {
	rsp, err := c.TagsDeleteTagValuesBulk(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsDeleteTagValuesBulkResponse(rsp)
}

// TagsDeleteTagValueWithResponse request returning *TagsDeleteTagValueResponse
func (c *ClientWithResponses) TagsDeleteTagValueWithResponse(ctx context.Context, valueUuid string, reqEditors ...RequestEditorFn) (*TagsDeleteTagValueResponse, error) {
	rsp, err := c.TagsDeleteTagValue(ctx, valueUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsDeleteTagValueResponse(rsp)
}

// TagsTagValueDetailsWithResponse request returning *TagsTagValueDetailsResponse
func (c *ClientWithResponses) TagsTagValueDetailsWithResponse(ctx context.Context, valueUuid string, reqEditors ...RequestEditorFn) (*TagsTagValueDetailsResponse, error) {
	rsp, err := c.TagsTagValueDetails(ctx, valueUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsTagValueDetailsResponse(rsp)
}

// TagsUpdateTagValueWithBodyWithResponse request with arbitrary body returning *TagsUpdateTagValueResponse
func (c *ClientWithResponses) TagsUpdateTagValueWithBodyWithResponse(ctx context.Context, valueUuid string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TagsUpdateTagValueResponse, error) {
	rsp, err := c.TagsUpdateTagValueWithBody(ctx, valueUuid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsUpdateTagValueResponse(rsp)
}

func (c *ClientWithResponses) TagsUpdateTagValueWithResponse(ctx context.Context, valueUuid string, body TagsUpdateTagValueJSONRequestBody, reqEditors ...RequestEditorFn) (*TagsUpdateTagValueResponse, error) {
	rsp, err := c.TagsUpdateTagValue(ctx, valueUuid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTagsUpdateTagValueResponse(rsp)
}

// TargetGroupsListWithResponse request returning *TargetGroupsListResponse
func (c *ClientWithResponses) TargetGroupsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TargetGroupsListResponse, error) {
	rsp, err := c.TargetGroupsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTargetGroupsListResponse(rsp)
}

// TargetGroupsCreateWithBodyWithResponse request with arbitrary body returning *TargetGroupsCreateResponse
func (c *ClientWithResponses) TargetGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TargetGroupsCreateResponse, error) {
	rsp, err := c.TargetGroupsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTargetGroupsCreateResponse(rsp)
}

func (c *ClientWithResponses) TargetGroupsCreateWithResponse(ctx context.Context, body TargetGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TargetGroupsCreateResponse, error) {
	rsp, err := c.TargetGroupsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTargetGroupsCreateResponse(rsp)
}

// TargetGroupsDeleteWithResponse request returning *TargetGroupsDeleteResponse
func (c *ClientWithResponses) TargetGroupsDeleteWithResponse(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*TargetGroupsDeleteResponse, error) {
	rsp, err := c.TargetGroupsDelete(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTargetGroupsDeleteResponse(rsp)
}

// TargetGroupsDetailsWithResponse request returning *TargetGroupsDetailsResponse
func (c *ClientWithResponses) TargetGroupsDetailsWithResponse(ctx context.Context, groupId int32, reqEditors ...RequestEditorFn) (*TargetGroupsDetailsResponse, error) {
	rsp, err := c.TargetGroupsDetails(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTargetGroupsDetailsResponse(rsp)
}

// TargetGroupsEditWithBodyWithResponse request with arbitrary body returning *TargetGroupsEditResponse
func (c *ClientWithResponses) TargetGroupsEditWithBodyWithResponse(ctx context.Context, groupId int32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TargetGroupsEditResponse, error) {
	rsp, err := c.TargetGroupsEditWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTargetGroupsEditResponse(rsp)
}

func (c *ClientWithResponses) TargetGroupsEditWithResponse(ctx context.Context, groupId int32, body TargetGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*TargetGroupsEditResponse, error) {
	rsp, err := c.TargetGroupsEdit(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTargetGroupsEditResponse(rsp)
}

// IoV2AccessGroupsListWithResponse request returning *IoV2AccessGroupsListResponse
func (c *ClientWithResponses) IoV2AccessGroupsListWithResponse(ctx context.Context, params *IoV2AccessGroupsListParams, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsListResponse, error) {
	rsp, err := c.IoV2AccessGroupsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV2AccessGroupsListResponse(rsp)
}

// IoV2AccessGroupsCreateWithBodyWithResponse request with arbitrary body returning *IoV2AccessGroupsCreateResponse
func (c *ClientWithResponses) IoV2AccessGroupsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsCreateResponse, error) {
	rsp, err := c.IoV2AccessGroupsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV2AccessGroupsCreateResponse(rsp)
}

func (c *ClientWithResponses) IoV2AccessGroupsCreateWithResponse(ctx context.Context, body IoV2AccessGroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsCreateResponse, error) {
	rsp, err := c.IoV2AccessGroupsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV2AccessGroupsCreateResponse(rsp)
}

// IoV2AccessGroupsListFiltersWithResponse request returning *IoV2AccessGroupsListFiltersResponse
func (c *ClientWithResponses) IoV2AccessGroupsListFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsListFiltersResponse, error) {
	rsp, err := c.IoV2AccessGroupsListFilters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV2AccessGroupsListFiltersResponse(rsp)
}

// IoV2AccessGroupsListRuleFiltersWithResponse request returning *IoV2AccessGroupsListRuleFiltersResponse
func (c *ClientWithResponses) IoV2AccessGroupsListRuleFiltersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsListRuleFiltersResponse, error) {
	rsp, err := c.IoV2AccessGroupsListRuleFilters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV2AccessGroupsListRuleFiltersResponse(rsp)
}

// IoV2AccessGroupsDeleteWithResponse request returning *IoV2AccessGroupsDeleteResponse
func (c *ClientWithResponses) IoV2AccessGroupsDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsDeleteResponse, error) {
	rsp, err := c.IoV2AccessGroupsDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV2AccessGroupsDeleteResponse(rsp)
}

// IoV2AccessGroupsDetailsWithResponse request returning *IoV2AccessGroupsDetailsResponse
func (c *ClientWithResponses) IoV2AccessGroupsDetailsWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsDetailsResponse, error) {
	rsp, err := c.IoV2AccessGroupsDetails(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV2AccessGroupsDetailsResponse(rsp)
}

// IoV2AccessGroupsEditWithBodyWithResponse request with arbitrary body returning *IoV2AccessGroupsEditResponse
func (c *ClientWithResponses) IoV2AccessGroupsEditWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsEditResponse, error) {
	rsp, err := c.IoV2AccessGroupsEditWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV2AccessGroupsEditResponse(rsp)
}

func (c *ClientWithResponses) IoV2AccessGroupsEditWithResponse(ctx context.Context, id string, body IoV2AccessGroupsEditJSONRequestBody, reqEditors ...RequestEditorFn) (*IoV2AccessGroupsEditResponse, error) {
	rsp, err := c.IoV2AccessGroupsEdit(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIoV2AccessGroupsEditResponse(rsp)
}

// ExportsVulnsRequestExportWithBodyWithResponse request with arbitrary body returning *ExportsVulnsRequestExportResponse
func (c *ClientWithResponses) ExportsVulnsRequestExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportsVulnsRequestExportResponse, error) {
	rsp, err := c.ExportsVulnsRequestExportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportsVulnsRequestExportResponse(rsp)
}

func (c *ClientWithResponses) ExportsVulnsRequestExportWithResponse(ctx context.Context, body ExportsVulnsRequestExportJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportsVulnsRequestExportResponse, error) {
	rsp, err := c.ExportsVulnsRequestExport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportsVulnsRequestExportResponse(rsp)
}

// ExportsVulnsExportStatusRecentWithResponse request returning *ExportsVulnsExportStatusRecentResponse
func (c *ClientWithResponses) ExportsVulnsExportStatusRecentWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExportsVulnsExportStatusRecentResponse, error) {
	rsp, err := c.ExportsVulnsExportStatusRecent(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportsVulnsExportStatusRecentResponse(rsp)
}

// ExportsVulnsExportCancelWithResponse request returning *ExportsVulnsExportCancelResponse
func (c *ClientWithResponses) ExportsVulnsExportCancelWithResponse(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*ExportsVulnsExportCancelResponse, error) {
	rsp, err := c.ExportsVulnsExportCancel(ctx, exportUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportsVulnsExportCancelResponse(rsp)
}

// ExportsVulnsDownloadChunkWithResponse request returning *ExportsVulnsDownloadChunkResponse
func (c *ClientWithResponses) ExportsVulnsDownloadChunkWithResponse(ctx context.Context, exportUuid string, chunkId int32, reqEditors ...RequestEditorFn) (*ExportsVulnsDownloadChunkResponse, error) {
	rsp, err := c.ExportsVulnsDownloadChunk(ctx, exportUuid, chunkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportsVulnsDownloadChunkResponse(rsp)
}

// ExportsVulnsExportStatusWithResponse request returning *ExportsVulnsExportStatusResponse
func (c *ClientWithResponses) ExportsVulnsExportStatusWithResponse(ctx context.Context, exportUuid string, reqEditors ...RequestEditorFn) (*ExportsVulnsExportStatusResponse, error) {
	rsp, err := c.ExportsVulnsExportStatus(ctx, exportUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportsVulnsExportStatusResponse(rsp)
}

// WorkbenchesAssetsWithResponse request returning *WorkbenchesAssetsResponse
func (c *ClientWithResponses) WorkbenchesAssetsWithResponse(ctx context.Context, params *WorkbenchesAssetsParams, reqEditors ...RequestEditorFn) (*WorkbenchesAssetsResponse, error) {
	rsp, err := c.WorkbenchesAssets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesAssetsResponse(rsp)
}

// WorkbenchesAssetsVulnerabilitiesWithResponse request returning *WorkbenchesAssetsVulnerabilitiesResponse
func (c *ClientWithResponses) WorkbenchesAssetsVulnerabilitiesWithResponse(ctx context.Context, params *WorkbenchesAssetsVulnerabilitiesParams, reqEditors ...RequestEditorFn) (*WorkbenchesAssetsVulnerabilitiesResponse, error) {
	rsp, err := c.WorkbenchesAssetsVulnerabilities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesAssetsVulnerabilitiesResponse(rsp)
}

// WorkbenchesAssetInfoWithResponse request returning *WorkbenchesAssetInfoResponse
func (c *ClientWithResponses) WorkbenchesAssetInfoWithResponse(ctx context.Context, assetId string, params *WorkbenchesAssetInfoParams, reqEditors ...RequestEditorFn) (*WorkbenchesAssetInfoResponse, error) {
	rsp, err := c.WorkbenchesAssetInfo(ctx, assetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesAssetInfoResponse(rsp)
}

// WorkbenchesAssetVulnerabilitiesWithResponse request returning *WorkbenchesAssetVulnerabilitiesResponse
func (c *ClientWithResponses) WorkbenchesAssetVulnerabilitiesWithResponse(ctx context.Context, assetId string, params *WorkbenchesAssetVulnerabilitiesParams, reqEditors ...RequestEditorFn) (*WorkbenchesAssetVulnerabilitiesResponse, error) {
	rsp, err := c.WorkbenchesAssetVulnerabilities(ctx, assetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesAssetVulnerabilitiesResponse(rsp)
}

// WorkbenchesAssetVulnerabilityInfoWithResponse request returning *WorkbenchesAssetVulnerabilityInfoResponse
func (c *ClientWithResponses) WorkbenchesAssetVulnerabilityInfoWithResponse(ctx context.Context, assetId string, pluginId int32, params *WorkbenchesAssetVulnerabilityInfoParams, reqEditors ...RequestEditorFn) (*WorkbenchesAssetVulnerabilityInfoResponse, error) {
	rsp, err := c.WorkbenchesAssetVulnerabilityInfo(ctx, assetId, pluginId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesAssetVulnerabilityInfoResponse(rsp)
}

// WorkbenchesAssetVulnerabilityOutputWithResponse request returning *WorkbenchesAssetVulnerabilityOutputResponse
func (c *ClientWithResponses) WorkbenchesAssetVulnerabilityOutputWithResponse(ctx context.Context, assetId string, pluginId int32, params *WorkbenchesAssetVulnerabilityOutputParams, reqEditors ...RequestEditorFn) (*WorkbenchesAssetVulnerabilityOutputResponse, error) {
	rsp, err := c.WorkbenchesAssetVulnerabilityOutput(ctx, assetId, pluginId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesAssetVulnerabilityOutputResponse(rsp)
}

// WorkbenchesAssetsDeleteWithResponse request returning *WorkbenchesAssetsDeleteResponse
func (c *ClientWithResponses) WorkbenchesAssetsDeleteWithResponse(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*WorkbenchesAssetsDeleteResponse, error) {
	rsp, err := c.WorkbenchesAssetsDelete(ctx, assetUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesAssetsDeleteResponse(rsp)
}

// WorkbenchesAssetsActivityWithResponse request returning *WorkbenchesAssetsActivityResponse
func (c *ClientWithResponses) WorkbenchesAssetsActivityWithResponse(ctx context.Context, assetUuid string, reqEditors ...RequestEditorFn) (*WorkbenchesAssetsActivityResponse, error) {
	rsp, err := c.WorkbenchesAssetsActivity(ctx, assetUuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesAssetsActivityResponse(rsp)
}

// WorkbenchesExportRequestWithResponse request returning *WorkbenchesExportRequestResponse
func (c *ClientWithResponses) WorkbenchesExportRequestWithResponse(ctx context.Context, params *WorkbenchesExportRequestParams, reqEditors ...RequestEditorFn) (*WorkbenchesExportRequestResponse, error) {
	rsp, err := c.WorkbenchesExportRequest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesExportRequestResponse(rsp)
}

// WorkbenchesExportDownloadWithResponse request returning *WorkbenchesExportDownloadResponse
func (c *ClientWithResponses) WorkbenchesExportDownloadWithResponse(ctx context.Context, fileId int32, reqEditors ...RequestEditorFn) (*WorkbenchesExportDownloadResponse, error) {
	rsp, err := c.WorkbenchesExportDownload(ctx, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesExportDownloadResponse(rsp)
}

// WorkbenchesExportStatusWithResponse request returning *WorkbenchesExportStatusResponse
func (c *ClientWithResponses) WorkbenchesExportStatusWithResponse(ctx context.Context, fileId int32, reqEditors ...RequestEditorFn) (*WorkbenchesExportStatusResponse, error) {
	rsp, err := c.WorkbenchesExportStatus(ctx, fileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesExportStatusResponse(rsp)
}

// WorkbenchesVulnerabilitiesWithResponse request returning *WorkbenchesVulnerabilitiesResponse
func (c *ClientWithResponses) WorkbenchesVulnerabilitiesWithResponse(ctx context.Context, params *WorkbenchesVulnerabilitiesParams, reqEditors ...RequestEditorFn) (*WorkbenchesVulnerabilitiesResponse, error) {
	rsp, err := c.WorkbenchesVulnerabilities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesVulnerabilitiesResponse(rsp)
}

// WorkbenchesVulnerabilityInfoWithResponse request returning *WorkbenchesVulnerabilityInfoResponse
func (c *ClientWithResponses) WorkbenchesVulnerabilityInfoWithResponse(ctx context.Context, pluginId int32, params *WorkbenchesVulnerabilityInfoParams, reqEditors ...RequestEditorFn) (*WorkbenchesVulnerabilityInfoResponse, error) {
	rsp, err := c.WorkbenchesVulnerabilityInfo(ctx, pluginId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesVulnerabilityInfoResponse(rsp)
}

// WorkbenchesVulnerabilityOutputWithResponse request returning *WorkbenchesVulnerabilityOutputResponse
func (c *ClientWithResponses) WorkbenchesVulnerabilityOutputWithResponse(ctx context.Context, pluginId int32, params *WorkbenchesVulnerabilityOutputParams, reqEditors ...RequestEditorFn) (*WorkbenchesVulnerabilityOutputResponse, error) {
	rsp, err := c.WorkbenchesVulnerabilityOutput(ctx, pluginId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkbenchesVulnerabilityOutputResponse(rsp)
}

// ParseIoV1AccessGroupsListResponse parses an HTTP response from a IoV1AccessGroupsListWithResponse call
func ParseIoV1AccessGroupsListResponse(rsp *http.Response) (*IoV1AccessGroupsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV1AccessGroupsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccessGroups *struct {
				// Specifies whether the access group is the system-provided All Assets access group:
				//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) endpoint.
				//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
				AllAssets *bool `json:"all_assets,omitempty"`

				// Specifies whether assets in the access group can be viewed by all or only some users in your organization:
				//  - If `true`, all users in your organization have Can View access to the assets defined in the rules parameter. If `true` in a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request, Tenable.io ignores any principal parameters in the request.
				//  - If `false`, only specified users have Can View access to the assets defined in the rules parameter. You define which users or user groups have access in the principals parameter of a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request.
				//
				// **Note:** If a [PUT /access-groups/{id}]ref:io-v1-access-groups-edit) endpoint request sets this parameter to `true` for an access group where the parameter was previously set to `false`, Tenable.io removes all principal data previously associated with the access group.
				AllUsers *bool `json:"all_users,omitempty"`

				// The UUID of your Tenable.io instance.
				ContainerUuid *string `json:"container_uuid,omitempty"`

				// An ISO timestamp indicating the date and time on which the access group was created.
				CreatedAt *string `json:"created_at,omitempty"`

				// The name of the user who created the access group.
				CreatedByName *string `json:"created_by_name,omitempty"`

				// The UUID of the user who created the access group.
				CreatedByUuid *string `json:"created_by_uuid,omitempty"`

				// The UUID of the access group.
				Id *string `json:"id,omitempty"`

				// The name of the access group. This name must be:
				// * Unique within your Tenable.io instance.
				// * A maximum of 255 characters.
				// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
				Name *string `json:"name,omitempty"`

				// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
				ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

				// The status of the process evaluating and assigning assets to the access group. Possible values are:
				//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
				//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
				//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
				Status *string `json:"status,omitempty"`

				// An ISO timestamp indicating the time and date on which the access group was last modified.
				UpdatedAt *string `json:"updated_at,omitempty"`

				// The name of the user who last modified the access group.
				UpdatedByName *string `json:"updated_by_name,omitempty"`

				// The UUID of the user who last modified the access group.
				UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`
			} `json:"access_groups,omitempty"`
			Pagination *struct {
				// The number of records requested (or the default value if omitted from the request).
				Limit *int32 `json:"limit,omitempty"`

				// The starting record you requested (or zero if omitted).
				Offset *int32 `json:"offset,omitempty"`

				// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
				Sort *[]struct {
					// The field on which Tenable.io sorted the results.
					Name *string `json:"name,omitempty"`

					// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
					Order *string `json:"order,omitempty"`
				} `json:"sort,omitempty"`

				// The total number of records matching your search criteria.
				Total *int32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoV1AccessGroupsCreateResponse parses an HTTP response from a IoV1AccessGroupsCreateWithResponse call
func ParseIoV1AccessGroupsCreateResponse(rsp *http.Response) (*IoV1AccessGroupsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV1AccessGroupsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Specifies whether the access group is the system-provided All Assets access group:
			//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) endpoint.
			//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
			AllAssets *bool `json:"all_assets,omitempty"`

			// Specifies whether assets in the access group can be viewed by all or only some users in your organization:
			//  - If `true`, all users in your organization have Can View access to the assets defined in the rules parameter. If `true` in a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request, Tenable.io ignores any principal parameters in the request.
			//  - If `false`, only specified users have Can View access to the assets defined in the rules parameter. You define which users or user groups have access in the principals parameter of a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request.
			//
			// **Note:** If a [PUT /access-groups/{id}]ref:io-v1-access-groups-edit) endpoint request sets this parameter to `true` for an access group where the parameter was previously set to `false`, Tenable.io removes all principal data previously associated with the access group.
			AllUsers *bool `json:"all_users,omitempty"`

			// The UUID of your Tenable.io instance.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the access group was created.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the access group.
			CreatedByName *string `json:"created_by_name,omitempty"`

			// The UUID of the user who created the access group.
			CreatedByUuid *string `json:"created_by_uuid,omitempty"`

			// The UUID of the access group.
			Id *string `json:"id,omitempty"`

			// The name of the access group. This name must be:
			// * Unique within your Tenable.io instance.
			// * A maximum of 255 characters.
			// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
			Name *string `json:"name,omitempty"`

			// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
			ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

			// The status of the process evaluating and assigning assets to the access group. Possible values are:
			//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
			//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
			//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
			Status *string `json:"status,omitempty"`

			// An ISO timestamp indicating the time and date on which the access group was last modified.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last modified the access group.
			UpdatedByName *string `json:"updated_by_name,omitempty"`

			// The UUID of the user who last modified the access group.
			UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoV1AccessGroupsListFiltersResponse parses an HTTP response from a IoV1AccessGroupsListFiltersWithResponse call
func ParseIoV1AccessGroupsListFiltersResponse(rsp *http.Response) (*IoV1AccessGroupsListFiltersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV1AccessGroupsListFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The filters and operators for each field you can use when constructing filter (`f` parameter) values in the [GET /access-groups](ref:io-v1-access-groups-list) endpoint.
			Filters *[]struct {
				// Indicates how the parameter appears in the Tenable.io user interface.
				Control *string `json:"control,omitempty"`

				// Corresponds to the field component of the `f` parameter.
				Name *string `json:"name,omitempty"`

				// Corresponds to the operator component of the `f` parameter.
				Operators *[]string `json:"operators,omitempty"`

				// The name of the parameter as it appears in the Tenable.io user interface.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filters,omitempty"`

			// The fields you can use when constructing `sort` parameter values for the [GET /access-groups](ref:io-v1-access-groups-list) endpoint.
			Sort *[]struct {
				// The names of the fields you can use when constructing `sort` parameter values for the [GET /access-groups](ref:io-v1-access-groups-list) endpoint.
				SortableFields *string `json:"sortable_fields,omitempty"`
			} `json:"sort,omitempty"`

			// The fields you can use as a wildcard (`wf` parameter) value in the [GET /access-groups](ref:io-v1-access-groups-list) endpoint.
			WildcardFields *[]string `json:"wildcard_fields,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoV1AccessGroupsListRuleFiltersResponse parses an HTTP response from a IoV1AccessGroupsListRuleFiltersWithResponse call
func ParseIoV1AccessGroupsListRuleFiltersResponse(rsp *http.Response) (*IoV1AccessGroupsListRuleFiltersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV1AccessGroupsListRuleFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// An array specifying values to use when constructing an asset rule for the [POST /access-groups](ref:io-v1-access-groups-create) and [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) methods.
			Filters *[]struct {
				// Indicates how the field appears in the Tenable.io user interface.
				Control *string `json:"control,omitempty"`

				// The name of the filter parameter. Corresponds to the asset rule type.
				Name *string `json:"name,omitempty"`

				// The operator that specifies how Tenable.io matches the terms value to asset data. Corresponds to the operator component of the rules parameter. Possible operators include:
				// * eqTenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
				// * matchTenable.io matches the rule to assets based a partial match of the specified term.
				// * startsTenable.io matches the rule to assets that start with the specified term.
				// * endsTenable.io matches the rule to assets that end with the specified term.
				//  * set-hasTenable.io matches the rule to assets based on an exact match of the specified `tag_uuid`.
				//
				// For a complete list of operators by rule type, use the [GET /access-groups/filters](ref:io-v1-access-groups-list-filters) endpoint.
				Operators *[]string `json:"operators,omitempty"`

				// The name of the field as it appears in the Tenable.io user interface.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filters,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoV1AccessGroupsDeleteResponse parses an HTTP response from a IoV1AccessGroupsDeleteWithResponse call
func ParseIoV1AccessGroupsDeleteResponse(rsp *http.Response) (*IoV1AccessGroupsDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV1AccessGroupsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIoV1AccessGroupsDetailsResponse parses an HTTP response from a IoV1AccessGroupsDetailsWithResponse call
func ParseIoV1AccessGroupsDetailsResponse(rsp *http.Response) (*IoV1AccessGroupsDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV1AccessGroupsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Specifies whether the access group is the system-provided All Assets access group:
			//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) endpoint.
			//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
			AllAssets *bool `json:"all_assets,omitempty"`

			// Specifies whether assets in the access group can be viewed by all or only some users in your organization:
			//  - If `true`, all users in your organization have Can View access to the assets defined in the rules parameter. If `true` in a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request, Tenable.io ignores any principal parameters in the request.
			//  - If `false`, only specified users have Can View access to the assets defined in the rules parameter. You define which users or user groups have access in the principals parameter of a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request.
			//
			// **Note:** If a [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) endpoint request sets this parameter to `true` for an access group where the parameter was previously set to `false`, Tenable.io removes all principal data previously associated with the access group.
			AllUsers *bool `json:"all_users,omitempty"`

			// The UUID of your Tenable.io instance.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the access group was created.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the access group.
			CreatedByName *string `json:"created_by_name,omitempty"`

			// The UUID of the user who created the access group.
			CreatedByUuid *string `json:"created_by_uuid,omitempty"`

			// The UUID of the access group.
			Id *string `json:"id,omitempty"`

			// The name of the access group. This name must be:
			// * Unique within your Tenable.io instance.
			// * A maximum of 255 characters.
			// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
			Name *string `json:"name,omitempty"`

			// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
			Principals *[]struct {
				// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
				PrincipalId *string `json:"principal_id,omitempty"`

				// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
				PrincipalName *string `json:"principal_name,omitempty"`

				// (Required) The type of principal. Valid values include:
				//  - userGrants access to the user you specify.
				//  - groupGrants access to all users assigned to the user group you specify.
				Type *string `json:"type,omitempty"`
			} `json:"principals,omitempty"`

			// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
			ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

			// An array of asset rules. Tenable.io uses these rules to assign assets to the access group. You can specify a maximum of 1,000 rules for an individual access group. If you specify multiple rules for an access group, Tenable.io assigns an asset to the access group if the asset matches any of the rules. You can only add rules to access groups if the `all_assets` parameter is set to `false`.
			Rules *[]struct {
				// The operator that specifies how Tenable.io matches the terms value to asset data.
				//
				// Possible operators include:
				//  - eqTenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
				//  - matchTenable.io matches the rule to assets based a partial match of the specified term.
				//  - startsTenable.io matches the rule to assets that start with the specified term.
				//  - endsTenable.io matches the rule to assets that end with the specified term.
				//  - set-hasTenable.io matches the rule to assets based on an exact match of the specified `tag_uuid`.
				//
				// For a complete list of operators by rule type, use the [GET /access-groups/rules/filters](ref:io-v1-access-groups-list-rule-filters) endpoint.
				Operator *string `json:"operator,omitempty"`

				// The values that Tenable.io uses to match an asset to the rule. A term must correspond to the rule type.
				//
				// For example:
				//  - If the rule type is `aws_account`, the term is an AWS account ID.
				//  - If the rule type is `fqdn`, the term is a hostname or a fully-qualified domain name (FQDN).
				//  - If the rule type is `ipv4`, the term is an individual IPv4 address, a range of IPv4 addresses (for example, 192.0.2.57-192.0.2.60), or a CIDR range (for example, 192.0.2.57/24).
				//
				// For a complete list of supported values by rule type, use the [GET /access-groups/rules/filters](ref:io-v1-access-groups-list-rule-filters) endpoint.
				//
				// If you specify multiple terms values, Tenable.io includes an asset in the access group if the asset's attributes match any of the terms in the rule.
				// <br >You can specify up to 100,000 terms per asset rule.
				Terms *[]string `json:"terms,omitempty"`

				// The type of asset rule. The asset rule type corresponds to the type of data you can specify in the `terms` parameter. For a complete list of supported rule types, use the [GET /access-groups/filters](ref:io-v1-access-groups-list-filters) endpoint.
				Type *string `json:"type,omitempty"`
			} `json:"rules,omitempty"`

			// The status of the process evaluating and assigning assets to the access group. Possible values are:
			//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
			//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
			//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
			Status *string `json:"status,omitempty"`

			// An ISO timestamp indicating the time and date on which the access group was last modified.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last modified the access group.
			UpdatedByName *string `json:"updated_by_name,omitempty"`

			// The UUID of the user who last modified the access group.
			UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoV1AccessGroupsEditResponse parses an HTTP response from a IoV1AccessGroupsEditWithResponse call
func ParseIoV1AccessGroupsEditResponse(rsp *http.Response) (*IoV1AccessGroupsEditResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV1AccessGroupsEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Specifies whether the access group is the system-provided All Assets access group:
			//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) endpoint.
			//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
			AllAssets *bool `json:"all_assets,omitempty"`

			// Specifies whether assets in the access group can be viewed by all or only some users in your organization:
			//  - If `true`, all users in your organization have Can View access to the assets defined in the rules parameter. If `true` in a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request, Tenable.io ignores any principal parameters in the request.
			//  - If `false`, only specified users have Can View access to the assets defined in the rules parameter. You define which users or user groups have access in the principals parameter of a [POST /access-groups](ref:io-v1-access-groups-create) or [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) request.
			//
			// **Note:** If a [PUT /access-groups/{id}](ref:io-v1-access-groups-edit) endpoint request sets this parameter to `true` for an access group where the parameter was previously set to `false`, Tenable.io removes all principal data previously associated with the access group.
			AllUsers *bool `json:"all_users,omitempty"`

			// The UUID of your Tenable.io instance.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the access group was created.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the access group.
			CreatedByName *string `json:"created_by_name,omitempty"`

			// The UUID of the user who created the access group.
			CreatedByUuid *string `json:"created_by_uuid,omitempty"`

			// The UUID of the access group.
			Id *string `json:"id,omitempty"`

			// The name of the access group. This name must be:
			// * Unique within your Tenable.io instance.
			// * A maximum of 255 characters.
			// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
			Name *string `json:"name,omitempty"`

			// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
			Principals *[]struct {
				// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
				PrincipalId *string `json:"principal_id,omitempty"`

				// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
				PrincipalName *string `json:"principal_name,omitempty"`

				// (Required) The type of principal. Valid values include:
				//  - userGrants access to the user you specify.
				//  - groupGrants access to all users assigned to the user group you specify.
				Type *string `json:"type,omitempty"`
			} `json:"principals,omitempty"`

			// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
			ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

			// An array of asset rules. Tenable.io uses these rules to assign assets to the access group. You can specify a maximum of 1,000 rules for an individual access group. If you specify multiple rules for an access group, Tenable.io assigns an asset to the access group if the asset matches any of the rules. You can only add rules to access groups if the `all_assets` parameter is set to `false`.
			Rules *[]struct {
				// The operator that specifies how Tenable.io matches the terms value to asset data.
				//
				// Possible operators include:
				//  - eqTenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
				//  - matchTenable.io matches the rule to assets based a partial match of the specified term.
				//  - startsTenable.io matches the rule to assets that start with the specified term.
				//  - endsTenable.io matches the rule to assets that end with the specified term.
				//  - set-hasTenable.io matches the rule to assets based on an exact match of the specified `tag_uuid`.
				//
				// For a complete list of operators by rule type, use the [GET /access-groups/rules/filters](ref:io-v1-access-groups-list-rule-filters) endpoint.
				Operator *string `json:"operator,omitempty"`

				// The values that Tenable.io uses to match an asset to the rule. A term must correspond to the rule type.
				//
				// For example:
				//  - If the rule type is `aws_account`, the term is an AWS account ID.
				//  - If the rule type is `fqdn`, the term is a hostname or a fully-qualified domain name (FQDN).
				//  - If the rule type is `ipv4`, the term is an individual IPv4 address, a range of IPv4 addresses (for example, 192.0.2.57-192.0.2.60), or a CIDR range (for example, 192.0.2.57/24).
				//
				// For a complete list of supported values by rule type, use the [GET /access-groups/rules/filters](ref:io-v1-access-groups-list-rule-filters) endpoint.
				//
				// If you specify multiple terms values, Tenable.io includes an asset in the access group if the asset's attributes match any of the terms in the rule.
				// <br >You can specify up to 100,000 terms per asset rule.
				Terms *[]string `json:"terms,omitempty"`

				// The type of asset rule. The asset rule type corresponds to the type of data you can specify in the `terms` parameter. For a complete list of supported rule types, use the [GET /access-groups/filters](ref:io-v1-access-groups-list-filters) endpoint.
				Type *string `json:"type,omitempty"`
			} `json:"rules,omitempty"`

			// The status of the process evaluating and assigning assets to the access group. Possible values are:
			//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
			//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
			//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
			Status *string `json:"status,omitempty"`

			// An ISO timestamp indicating the time and date on which the access group was last modified.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last modified the access group.
			UpdatedByName *string `json:"updated_by_name,omitempty"`

			// The UUID of the user who last modified the access group.
			UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetsBulkUpdateAcrResponse parses an HTTP response from a AssetsBulkUpdateAcrWithResponse call
func ParseAssetsBulkUpdateAcrResponse(rsp *http.Response) (*AssetsBulkUpdateAcrResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetsBulkUpdateAcrResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAssetsBulkDeleteResponse parses an HTTP response from a AssetsBulkDeleteWithResponse call
func ParseAssetsBulkDeleteResponse(rsp *http.Response) (*AssetsBulkDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetsBulkDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// The number of assets affected by the operation.
			AssetCount *int `json:"asset_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseAssetsBulkMoveResponse parses an HTTP response from a AssetsBulkMoveWithResponse call
func ParseAssetsBulkMoveResponse(rsp *http.Response) (*AssetsBulkMoveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetsBulkMoveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// The number of assets affected by the operation.
			AssetCount *int `json:"asset_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseVulnerabilitiesImportV2Response parses an HTTP response from a VulnerabilitiesImportV2WithResponse call
func ParseVulnerabilitiesImportV2Response(rsp *http.Response) (*VulnerabilitiesImportV2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VulnerabilitiesImportV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// This attribute is always empty. An empty value does not indicate an error condition.
			JobUuid *string `json:"job_uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetsListAssetsResponse parses an HTTP response from a AssetsListAssetsWithResponse call
func ParseAssetsListAssetsResponse(rsp *http.Response) (*AssetsListAssetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetsListAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A list of assets with details.
			Assets *[]struct {
				// The key drivers that Tenable uses to calculate an asset's Tenable-provided ACR. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
				//
				// This attribute is only present if you have a Lumin license.
				AcrDrivers *[]struct {
					// The type of characteristic.
					DriverName *string `json:"driver_name,omitempty"`

					// The characteristic value.
					DriverValue *[]string `json:"driver_value,omitempty"`
				} `json:"acr_drivers,omitempty"`

				// The Asset Criticality Rating (ACR) for the asset. With Lumin, Tenable assigns an ACR to each asset on your network to represent the asset's relative risk as an integer from 1 to 10. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
				//
				// This attribute is only present if you have a Lumin license.
				AcrScore *int `json:"acr_score,omitempty"`

				// The names of any Nessus agents that scanned and identified the asset.
				AgentName *[]string `json:"agent_name,omitempty"`

				// The name of the virtual machine instance in AWS EC2.
				AwsEc2Name *[]string `json:"aws_ec2_name,omitempty"`

				// The Asset Exposure Score (AES) for the asset. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
				//
				// This attribute is only present if you have a Lumin license.
				ExposureScore *int `json:"exposure_score,omitempty"`

				// A list of fully-qualified domain names (FQDNs) for the asset.
				Fqdn *[]string `json:"fqdn,omitempty"`

				// A value specifying whether a Nessus agent scan detected the asset (`true`).
				HasAgent *bool `json:"has_agent,omitempty"`

				// The UUID of the asset. Use this value as the unique key for the asset.
				Id *string `json:"id,omitempty"`

				// A list of IPv4 addresses for the asset.
				Ipv4 *[]string `json:"ipv4,omitempty"`

				// A list of IPv6 addresses for the asset.
				Ipv6 *[]string `json:"ipv6,omitempty"`

				// The IPv4 address, IPv6 address, or FQDN that the scanner last used to evaluate the asset.
				LastScanTarget *string `json:"last_scan_target,omitempty"`

				// The ISO timestamp of the scan that most recently detected the asset.
				LastSeen *string `json:"last_seen,omitempty"`

				// A list of MAC addresses for the asset.
				MacAddress *[]string `json:"mac_address,omitempty"`

				// The NetBIOS name for the asset.
				NetbiosName *[]string `json:"netbios_name,omitempty"`

				// The operating systems that scans have associated with the asset record.
				OperatingSystem *[]string `json:"operating_system,omitempty"`

				// Information about how often scans ran against the asset during specified intervals. This attribute is only present if you have a Lumin license.
				ScanFrequency *[]struct {
					// The number of times that a scan ran against the asset during the specified interval.
					Frequency *int `json:"frequency,omitempty"`

					// The number of days over which Tenable searches for scans involving the asset.
					Interval *int `json:"interval,omitempty"`

					// Indicates whether the asset was licensed at the time of the identified scans.
					Licensed *bool `json:"licensed,omitempty"`
				} `json:"scan_frequency,omitempty"`

				// The sources of the scans that identified the asset.
				Sources *[][]struct {
					// The ISO timestamp when the source first reported the asset.
					FirstSeen *string `json:"first_seen,omitempty"`

					// The ISO timestamp when the source last reported the asset.
					LastSeen *string `json:"last_seen,omitempty"`

					// The name of the entity that reported the asset details. Sources can include sensors, connectors, and API imports. Source names can be customized by your organization (for example, you specify a name when you import asset records). If your organization does not customize source names, system-generated names include:
					//  - AWSYou obtained the asset data from an Amazon Web Services connector.
					//  - NESSUS_AGENTYou obtained the asset data obtained from a Nessus agent scan.
					//  - PVSYou obtained the asset data from a Nessus Network Monitor (NNM) scan.
					//  - NESSUS_SCANYou obtained the asset data from a Nessus scan.
					//  - WASYou obtained the asset data from a  Web Application Scanning scan.
					Name *string `json:"name,omitempty"`
				} `json:"sources,omitempty"`
			} `json:"assets,omitempty"`

			// The total number of assets in your Tenable.io instance.
			Total *int `json:"total,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExportsAssetsRequestExportResponse parses an HTTP response from a ExportsAssetsRequestExportWithResponse call
func ParseExportsAssetsRequestExportResponse(rsp *http.Response) (*ExportsAssetsRequestExportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportsAssetsRequestExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The UUID of the assets export job.
			ExportUuid *string `json:"export_uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExportsAssetsExportStatusRecentResponse parses an HTTP response from a ExportsAssetsExportStatusRecentWithResponse call
func ParseExportsAssetsExportStatusRecentResponse(rsp *http.Response) (*ExportsAssetsExportStatusRecentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportsAssetsExportStatusRecentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Exports *[]struct {
				// The Unix timestamp when the export job was created.
				Created *int `json:"created,omitempty"`

				// The filters used in the export job request. For a list of possible filters, see the [POST /vulns/export](ref:exports-vulns-export-request-export) and [POST /assets/export](ref:exports-assets-request-export) endpoints.
				Filters *map[string]interface{} `json:"filters,omitempty"`

				// The number of chunks that have been processed and are available for download.
				FinishedChunks *int `json:"finished_chunks,omitempty"`

				// The number of assets contained in each export chunk.
				NumAssetsPerChunk *int `json:"num_assets_per_chunk,omitempty"`

				// The status of the export request. Possible values include:
				//  - QUEUEDTenable.io has queued the export request until it completes other requests currently in process.
				//  - PROCESSINGTenable.io has started processing the export request.
				//  - FINISHEDTenable.io has completed processing the export request. The list of chunks is complete.
				//  - CANCELLEDAn administrator has cancelled the export request.
				//  - ERRORTenable.io encountered an error while processing the export request. Tenable recommends that you retry the request. If the status persists on retry, contact Support.
				Status *string `json:"status,omitempty"`

				// The total number of chunks associated with the export job as a whole.
				TotalChunks *int `json:"total_chunks,omitempty"`

				// The UUID for the export request.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"exports,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExportsAssetsExportCancelResponse parses an HTTP response from a ExportsAssetsExportCancelWithResponse call
func ParseExportsAssetsExportCancelResponse(rsp *http.Response) (*ExportsAssetsExportCancelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportsAssetsExportCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Text describing the export job status, `CANCELLED`.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Text describing the error condition Tenable.io encountered. Possible values include:
			//
			//  - Cannot cancel a completed job
			//  - Export UUID is invalid
			Message *string `json:"message,omitempty"`

			// The HTTP error code.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Text describing the error condition Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP error code.
			Status *int `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseExportsAssetsDownloadChunkResponse parses an HTTP response from a ExportsAssetsDownloadChunkWithResponse call
func ParseExportsAssetsDownloadChunkResponse(rsp *http.Response) (*ExportsAssetsDownloadChunkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportsAssetsDownloadChunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The Asset Criticality Rating (ACR) for the asset. With Lumin, Tenable assigns an ACR to each asset on your network to represent the asset's relative risk as an integer from 1 to 10. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			AcrScore *string `json:"acr_score,omitempty"`

			// The names of any Nessus agents that scanned and identified the asset.
			AgentNames *[]string `json:"agent_names,omitempty"`

			// The unique identifier of the Nessus agent that identified the asset.
			AgentUuid *string `json:"agent_uuid,omitempty"`

			// The availability zone where Amazon Web Services hosts the virtual machine instance, for example, `us-east-1a``. Availability zones are subdivisions of AWS regions. For more information, see "Regions and Availability Zones" in the AWS documentation.
			AwsAvailabilityZone *string `json:"aws_availability_zone,omitempty"`

			// The unique identifier of the Linux AMI image in Amazon Elastic Compute Cloud (Amazon EC2). For more information, see the Amazon Elastic Compute Cloud Documentation.
			AwsEc2InstanceAmiId *string `json:"aws_ec2_instance_ami_id,omitempty"`

			// The virtual machine instance's group in AWS.
			AwsEc2InstanceGroupName *string `json:"aws_ec2_instance_group_name,omitempty"`

			// The unique identifier of the Linux instance in Amazon EC2. For more information, see the Amazon Elastic Compute Cloud Documentation.
			AwsEc2InstanceId *string `json:"aws_ec2_instance_id,omitempty"`

			// The state of the virtual machine instance in AWS at the time of the scan.
			AwsEc2InstanceStateName *string `json:"aws_ec2_instance_state_name,omitempty"`

			// The type of instance in AWS EC2.
			AwsEc2InstanceType *string `json:"aws_ec2_instance_type,omitempty"`

			// The name of the virtual machine instance in AWS EC2.
			AwsEc2Name *string `json:"aws_ec2_name,omitempty"`

			// The product code associated with the AMI used to launch the virtual machine instance in AWS EC2.
			AwsEc2ProductCode *string `json:"aws_ec2_product_code,omitempty"`

			// The canonical user identifier for the AWS account associated with the virtual machine instance. For example, `79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be`. For more information, see AWS Account Identifiers in the AWS documentation.
			AwsOwnerId *string `json:"aws_owner_id,omitempty"`

			// The region where AWS hosts the virtual machine instance, for example, `us-east-1`. For more information, see "Regions and Availability Zones" in the AWS documentation.
			AwsRegion *string `json:"aws_region,omitempty"`

			// The unique identifier of the AWS subnet where the virtual machine instance was running at the time of the scan.
			AwsSubnetId *string `json:"aws_subnet_id,omitempty"`

			// The unique identifier for the virtual public cloud that hosts the AWS virtual machine instance. For more information, see the Amazon Virtual Private Cloud User Guide.
			AwsVpcId *string `json:"aws_vpc_id,omitempty"`

			// The unique identifier of the resource in the Azure Resource Manager. For more information, see the Azure Resource Manager Documentation.
			AzureResourceId *string `json:"azure_resource_id,omitempty"`

			// The unique identifier of the Microsoft Azure virtual machine instance. For more information, see "Accessing and Using Azure VM Unique ID" in the Microsoft Azure documentation.
			AzureVmId *string `json:"azure_vm_id,omitempty"`

			// The unique identifiers of the asset in HCL BigFix. For more information, see the HCL BigFix documentation.
			BigfixAssetId *string `json:"bigfix_asset_id,omitempty"`

			// The BIOS UUID of the asset.
			BiosUuid *string `json:"bios_uuid,omitempty"`

			// The time and date when Tenable.io created the asset record.
			CreatedAt *string `json:"created_at,omitempty"`

			// The time and date when a user deleted the asset record. When a user deletes an asset record, Tenable.io retains the record until the asset ages out of the license count.
			DeletedAt *string `json:"deleted_at,omitempty"`

			// The user who deleted the asset record.
			DeletedBy *string `json:"deleted_by,omitempty"`

			// The Asset Exposure Score (AES) for the asset. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			ExposureScore *string `json:"exposure_score,omitempty"`

			// The time and date of the first scan run against the asset.
			FirstScanTime *string `json:"first_scan_time,omitempty"`

			// The time and date when a scan first identified the asset.
			FirstSeen *string `json:"first_seen,omitempty"`

			// The fully-qualified domain names that scans have associated with the asset record.
			Fqdns *[]string `json:"fqdns,omitempty"`

			// The zone where the virtual machine instance runs in GCP. For more information, see "Regions and Zones" in the GCP documentation.
			GcpInstanceId *string `json:"gcp_instance_id,omitempty"`

			// The unique identifier of the virtual machine instance in Google Cloud Platform (GCP).
			GcpProjectId *string `json:"gcp_project_id,omitempty"`

			// The customized name of the project to which the virtual machine instance belongs in GCP. For more information see "Creating and Managing Projects" in the GCP documentation.
			GcpZone *string `json:"gcp_zone,omitempty"`

			// Specifies whether a Nessus agent scan identified the asset.
			HasAgent *bool `json:"has_agent,omitempty"`

			// Specifies whether the asset has plugin results associated with it.
			HasPluginResults *bool `json:"has_plugin_results,omitempty"`

			// The hostnames that scans have associated with the asset record.
			Hostnames *[]string `json:"hostnames,omitempty"`

			// The UUID of the asset in Tenable.io. Use this value as the unique key for the asset.
			Id *string `json:"id,omitempty"`

			// A list of Common Platform Enumeration (CPE) values that represent software applications a scan identified as present on an asset. This attribute supports the CPE 2.2 format. For more information, see the "Component Syntax" section of the [CPE Specification, Version 2.2](https://cpe.mitre.org/files/cpe-specification_2.2.pdf). For assets identified in Tenable scans, this attribute contains data only if a scan using [Nessus Plugin ID 45590](https://www.tenable.com/plugins/nessus/45590) has evaluated the asset.
			//
			// **Note:** If no scan detects an application within 30 days of the scan that originally detected the application, Tenable.io considers the detection of that application expired. As a result, the next time a scan evaluates the asset, Tenable.io removes the expired application from the installed_software attribute. This activity is logged as a `remove` type of `attribute_change` update in the asset activity log.
			InstalledSoftware *[]string `json:"installed_software,omitempty"`

			// The IPv4 addresses that scans have associated with the asset record.
			Ipv4s *[]string `json:"ipv4s,omitempty"`

			// The IPv6 addresses that scans have associated with the asset record.
			Ipv6s *[]string `json:"ipv6s,omitempty"`

			// The time and date of the last credentialed scan run on the asset.
			LastAuthenticatedScanDate *string `json:"last_authenticated_scan_date,omitempty"`

			// The time and date of the last scan that identified the asset as licensed. Tenable.io categorizes an asset as licensed if a scan of that asset has returned results from a non-discovery plugin within the last 90 days.
			LastLicensedScanDate *string `json:"last_licensed_scan_date,omitempty"`

			// The UUID of the scan configuration used during the last scan of the asset.
			LastScanId *string `json:"last_scan_id,omitempty"`

			// The time and date of the last scan run against the asset.
			LastScanTime *string `json:"last_scan_time,omitempty"`

			// The `schedule_uuid` for the last scan of the asset.
			LastScheduleId *string `json:"last_schedule_id,omitempty"`

			// The time and date of the scan that most recently identified the asset.
			LastSeen *string `json:"last_seen,omitempty"`

			// The MAC addresses that scans have associated with the asset record.
			MacAddresses *[]string `json:"mac_addresses,omitempty"`

			// The manufacturer's unique identifiers of the Trusted Platform Module (TPM) associated with the asset.
			ManufacturerTpmIds *[]string `json:"manufacturer_tpm_ids,omitempty"`

			// The unique identifier of the McAfee ePO agent that identified the asset. For more information, see the McAfee documentation.
			McafeeEpoAgentGuid *string `json:"mcafee_epo_agent_guid,omitempty"`

			// The unique identifier of the asset in McAfee ePolicy Orchestrator (ePO). For more information, see the McAfee documentation.
			McafeeEpoGuid *string `json:"mcafee_epo_guid,omitempty"`

			// The NetBIOS names that scans have associated with the asset record.
			NetbiosNames *[]string `json:"netbios_names,omitempty"`

			// The ID of the network object associated with scanners that identified the asset. The default network ID is `00000000-0000-0000-0000-000000000000`. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkId *string `json:"network_id,omitempty"`

			// The network interfaces that scans identified on the asset.
			NetworkInterfaces *[]struct {
				// One or more FQDN belonging to the interface.
				Fqdn *[]string `json:"fqdn,omitempty"`

				// One or more IPv4 addresses belonging to the interface.
				Ipv4 *[]string `json:"ipv4,omitempty"`

				// One or more IPv6 addresses belonging to the interface.
				Ipv6 *[]string `json:"ipv6,omitempty"`

				// The MAC addresses of the interface.
				MacAddress *[]string `json:"mac_address,omitempty"`

				// The name of the interface.
				Name *string `json:"name,omitempty"`
			} `json:"network_interfaces,omitempty"`

			// The ID of the network object associated with scanners that identified the asset. The default network name is `Default`. All other network names are user-defined. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkName *string `json:"network_name,omitempty"`

			// The operating systems that scans have associated with the asset record.
			OperatingSystems *[]string `json:"operating_systems,omitempty"`

			// The Asset ID of the asset in Qualys. For more information, see the Qualys documentation.
			//
			// **Note:** Tenable is enabling Qualys asset import for customers in a rolling fashion. For more information, contact your Tenable representative.
			QualysAssetIds *[]string `json:"qualys_asset_ids,omitempty"`

			// The Host ID of the asset in Qualys. For more information, see the Qualys documentation.
			//
			// **Note:** Tenable is enabling Qualys asset import for customers in a rolling fashion. For more information, contact your Tenable representative.
			QualysHostIds *[]string `json:"qualys_host_ids,omitempty"`

			// The unique record identifier of the asset in ServiceNow. For more information, see the ServiceNow documentation.
			ServicenowSysid *string `json:"servicenow_sysid,omitempty"`

			// The sources of the scans that identified the asset.
			Sources *[]struct {
				// The ISO timestamp when the source first reported the asset.
				FirstSeen *string `json:"first_seen,omitempty"`

				// The ISO timestamp when the source last reported the asset.
				LastSeen *string `json:"last_seen,omitempty"`

				// The name of the entity that reported the asset details. Sources can include sensors, connectors, and API imports. Source names can be customized by your organization (for example, you specify a name when you import asset records). If your organization does not customize source names, system-generated names include:
				//  - AWSYou obtained the asset data from an Amazon Web Services connector.
				//  - NESSUS_AGENTYou obtained the asset data obtained from a Nessus agent scan.
				//  - PVSYou obtained the asset data from a Nessus Network Monitor (NNM) scan.
				//  - NESSUS_SCANYou obtained the asset data from a Nessus scan.
				//  - WASYou obtained the asset data from a  Web Application Scanning scan.
				Name *string `json:"name,omitempty"`
			} `json:"sources,omitempty"`

			// The SSH key fingerprints that scans have associated with the asset record.
			SshFingerprints *[]string `json:"ssh_fingerprints,omitempty"`

			// The hardware keys for the asset in Symantec Endpoint Protection.
			SymantecEpHardwareKeys *[]string `json:"symantec_ep_hardware_keys,omitempty"`

			// The system types as reported by Plugin ID 54615. Possible values include `router`, `general-purpose`, `scan-host`, and `embedded`.
			SystemTypes *[]string `json:"system_types,omitempty"`

			// Category tags assigned to the asset in Tenable.io.
			Tags *[]struct {
				// The ISO timestamp when the tag was assigned to the asset.
				AddedAt *string `json:"added_at,omitempty"`

				// The UUID of the user who assigned the tag to the asset.
				AddedBy *string `json:"added_by,omitempty"`

				// The tag category(the first half of the category:value pair).
				Key *string `json:"key,omitempty"`

				// The UUID of the tag.
				Uuid *string `json:"uuid,omitempty"`

				// The tag value (the second half of the category:value pair).
				Value *string `json:"value,omitempty"`
			} `json:"tags,omitempty"`

			// The time and date when a user terminated the Amazon Web Service (AWS) virtual machine instance of the asset.
			TerminatedAt *string `json:"terminated_at,omitempty"`

			// The user who terminated the AWSinstance of the asset.
			TerminatedBy *string `json:"terminated_by,omitempty"`

			// The time and date when the asset record was last updated.
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExportsAssetsExportStatusResponse parses an HTTP response from a ExportsAssetsExportStatusWithResponse call
func ParseExportsAssetsExportStatusResponse(rsp *http.Response) (*ExportsAssetsExportStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportsAssetsExportStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A comma-separated list of completed chunks available for download.
			ChunksAvailable *[]int32 `json:"chunks_available,omitempty"`

			// Information about the export job.
			Status *struct {
				// A list of completed chunks available for download.
				ChunksAvailable *[]int32 `json:"chunks_available,omitempty"`

				// The status of the export request. Possible values include:
				//  - QUEUEDTenable.io has queued the export request until it completes other requests currently in process.
				//  - PROCESSINGTenable.io has started processing the export request.
				//  - FINISHEDTenable.io has completed processing the export request. The list of chunks is complete.
				//  - CANCELLEDAn administrator has cancelled the export request.
				//  - ERRORTenable.io encountered an error while processing the export request. Tenable recommends that you retry the request. If the status persists on retry, contact Support.
				Status *string `json:"status,omitempty"`
			} `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetsAssetInfoResponse parses an HTTP response from a AssetsAssetInfoWithResponse call
func ParseAssetsAssetInfoResponse(rsp *http.Response) (*AssetsAssetInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetsAssetInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The key drivers that Tenable uses to calculate an asset's Tenable-provided ACR. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			AcrDrivers *[]struct {
				// The type of characteristic.
				DriverName *string `json:"driver_name,omitempty"`

				// The characteristic value.
				DriverValue *[]string `json:"driver_value,omitempty"`
			} `json:"acr_drivers,omitempty"`

			// The Asset Criticality Rating (ACR) for the asset. Tenable assigns an ACR to each asset on your network to represent the asset's relative risk as an integer from 1 to 10. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			//
			// This attribute is only present if you have a Lumin license.
			AcrScore *int `json:"acr_score,omitempty"`

			// The names of any Nessus agents that scanned and identified the asset.
			AgentName *[]string `json:"agent_name,omitempty"`

			// The availability zone where Amazon Web Services hosts the virtual machine instance, for example, `us-east-1a`. Availability zones are subdivisions of AWS regions. For more information, see Regions and Availability Zones in the AWS documentation.
			AwsAvailabilityZone *[]string `json:"aws_availability_zone,omitempty"`

			// The unique identifier of the Linux AMI image in Amazon Elastic Compute Cloud (Amazon EC2). For more information, see the Amazon Elastic Compute Cloud Documentation.
			AwsEc2InstanceAmiId *[]string `json:"aws_ec2_instance_ami_id,omitempty"`

			// The virtual machine instance's group in AWS.
			AwsEc2InstanceGroupName *[]string `json:"aws_ec2_instance_group_name,omitempty"`

			// The unique identifier of the Linux instance in Amazon EC2. For more information, see the Amazon Elastic Compute Cloud Documentation.
			AwsEc2InstanceId *[]string `json:"aws_ec2_instance_id,omitempty"`

			// The state of the virtual machine instance in AWS at the time of the scan. For more information on instance states, see the AWS documentation.
			AwsEc2InstanceStateName *[]string `json:"aws_ec2_instance_state_name,omitempty"`

			// The type of instance in AWS EC2.
			AwsEc2InstanceType *[]string `json:"aws_ec2_instance_type,omitempty"`

			// The name of the virtual machine instance in AWS EC2.
			AwsEc2Name *[]string `json:"aws_ec2_name,omitempty"`

			// The product code associated with the AMI used to launch the virtual machine instance in AWS EC2.
			AwsEc2ProductCode *[]string `json:"aws_ec2_product_code,omitempty"`

			// The canonical user identifier for the AWS account associated with the virtual machine instance. For example, `79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be`. For more information, see AWS Account Identifiers in the AWS documentation.
			AwsOwnerId *[]string `json:"aws_owner_id,omitempty"`

			// The region where AWS hosts the virtual machine instance, for example, `us-east-1`. For more information, see Regions and Availability Zones in the AWS documentation.
			AwsRegion *[]string `json:"aws_region,omitempty"`

			// The unique identifier of the AWS subnet where the virtual machine instance was running at the time of the scan.
			AwsSubnetId *[]string `json:"aws_subnet_id,omitempty"`

			// The unique identifier for the public cloud that hosts the AWS virtual machine instance. For more information, see the Amazon Virtual Private Cloud User Guide.
			AwsVpcId *[]string `json:"aws_vpc_id,omitempty"`

			// The unique identifier of the resource in the Azure Resource Manager. For more information, see the Azure Resource Manager Documentation.
			AzureResourceId *[]string `json:"azure_resource_id,omitempty"`

			// The unique identifier of the Microsoft Azure virtual machine instance. For more information, see "Accessing and Using Azure VM Unique ID" in the Microsoft Azure documentation.
			AzureVmId *[]string `json:"azure_vm_id,omitempty"`

			// The BIOS UUID that scans have associated with the asset.
			BiosUuid *[]string `json:"bios_uuid,omitempty"`

			// The time and date when Tenable.io created the asset record.
			CreatedAt *string `json:"created_at,omitempty"`

			// The Asset Exposure Score (AES) for the asset. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
			ExposureScore *int `json:"exposure_score,omitempty"`

			// The time and date when a scan first identified the asset.
			FirstSeen *string `json:"first_seen,omitempty"`

			// The fully-qualified domain names that scans have associated with the asset record.
			Fqdn *[]string `json:"fqdn,omitempty"`

			// The unique identifier of the virtual machine instance in GCP.
			GcpInstanceId *[]string `json:"gcp_instance_id,omitempty"`

			// The customized name of the project to which the virtual machine instance belongs in Google Cloud Platform (GCP). For more information, see "Creating and Managing Projects" in the GCP documentation.
			GcpProjectId *[]string `json:"gcp_project_id,omitempty"`

			// The zone where the virtual machine instance runs in GCP. For more information, see "Regions and Zones" in the GCP documentation.
			GcpZone *[]string `json:"gcp_zone,omitempty"`

			// Indicates if a Nessus agent scan detected the asset.
			HasAgent *bool `json:"has_agent,omitempty"`

			// The hostnames that scans have associated with the asset record.
			Hostname *[]string `json:"hostname,omitempty"`

			// The UUID of the asset. Use this value as the unique key for the asset.
			Id *string `json:"id,omitempty"`

			// A list of Common Platform Enumeration (CPE) values that represent software applications a scan identified as present on an asset. This attribute supports the CPE 2.2 format. For more information, see the "Component Syntax" section of the [CPE Specification, Version 2.2](https://cpe.mitre.org/files/cpe-specification_2.2.pdf). For assets identified in Tenable scans, this attribute contains data only if a scan using [Nessus Plugin ID 45590](https://www.tenable.com/plugins/nessus/45590) has evaluated the asset.
			//
			// **Note:** If no scan detects an application within 30 days of the scan that originally detected the application, Tenable.io considers the detection of that application expired. As a result, the next time a scan evaluates the asset, Tenable.io removes the expired application from the installed_software attribute. This activity is logged as a `remove` type of `attribute_change` update in the asset activity log.
			InstalledSoftware *[]string `json:"installed_software,omitempty"`

			// The IPv4 addresses that scans have associated with the asset record.
			Ipv4 *[]string `json:"ipv4,omitempty"`

			// The IPv6 addresses that scans have associated with the asset record.
			Ipv6 *[]string `json:"ipv6,omitempty"`

			// The time and date of the last credentialed scan run on the asset.
			LastAuthenticatedScanDate *string `json:"last_authenticated_scan_date,omitempty"`

			// The time and date of the last scan that identified the asset as licensed. Tenable.io categorizes an asset as licensed if a scan of that asset has returned results from a non-discovery plugin within the last 90 days.
			LastLicensedScanDate *string `json:"last_licensed_scan_date,omitempty"`

			// The IPv4 address, IPv6 address, or FQDN that the scanner last used to evaluate the asset.
			LastScanTarget *string `json:"last_scan_target,omitempty"`

			// The time and date of the scan that most recently identified the asset.
			LastSeen *string `json:"last_seen,omitempty"`

			// The MAC addresses that scans have associated with the asset record.
			MacAddress *[]string `json:"mac_address,omitempty"`

			// The unique identifier of the McAfee ePO agent that identified the asset. For more information, see the McAfee documentation.
			McafeeEpoAgentGuid *[]string `json:"mcafee_epo_agent_guid,omitempty"`

			// The unique identifier of the asset in McAfee ePolicy Orchestrator (ePO). For more information, see the McAfee documentation.
			McafeeEpoGuid *[]string `json:"mcafee_epo_guid,omitempty"`

			// The NetBIOS names that scans have associated with the asset record.
			NetbiosName *[]string `json:"netbios_name,omitempty"`

			// The ID of the network object to which the asset belongs. For more information, see [Manage Networks](doc:manage-networks-tio).
			NetworkId *[]string `json:"network_id,omitempty"`

			// The operating systems that scans have associated with the asset record.
			OperatingSystem *[]string `json:"operating_system,omitempty"`

			// The Asset ID of the asset in Qualys. For more information, see the Qualys documentation.
			QualysAssetId *[]string `json:"qualys_asset_id,omitempty"`

			// The Host ID of the asset in Qualys. For more information, see the Qualys documentation.
			QualysHostId *[]string `json:"qualys_host_id,omitempty"`

			// Information about how often scans ran against the asset during specified intervals.
			ScanFrequency *[]struct {
				// The number of times that a scan ran against the asset during the specified interval.
				Frequency *int `json:"frequency,omitempty"`

				// The number of days over which Tenable searches for scans involving the asset.
				Interval *int `json:"interval,omitempty"`

				// Indicates whether the asset was licensed at the time of the identified scans.
				Licensed *bool `json:"licensed,omitempty"`
			} `json:"scan_frequency,omitempty"`

			// The unique record identifier of the asset in ServiceNow. For more information, see the ServiceNow documentation.
			ServicenowSysid *[]string `json:"servicenow_sysid,omitempty"`

			// The sources of the scans that identified the asset.
			Sources *[][]struct {
				// The ISO timestamp when the source first reported the asset.
				FirstSeen *string `json:"first_seen,omitempty"`

				// The ISO timestamp when the source last reported the asset.
				LastSeen *string `json:"last_seen,omitempty"`

				// The name of the entity that reported the asset details. Sources can include sensors, connectors, and API imports. Source names can be customized by your organization (for example, you specify a name when you import asset records). If your organization does not customize source names, system-generated names include:
				//  - AWSYou obtained the asset data from an Amazon Web Services connector.
				//  - NESSUS_AGENTYou obtained the asset data obtained from a Nessus agent scan.
				//  - PVSYou obtained the asset data from a Nessus Network Monitor (NNM) scan.
				//  - NESSUS_SCANYou obtained the asset data from a Nessus scan.
				//  - WASYou obtained the asset data from a  Web Application Scanning scan.
				Name *string `json:"name,omitempty"`
			} `json:"sources,omitempty"`

			// The SSH key fingerprints that scans have associated with the asset record.
			SshFingerprint *[]string `json:"ssh_fingerprint,omitempty"`

			// The system types as reported by Plugin ID 54615. Possible values include `router`, `general-purpose`, `scan-host`, and `embedded`.
			SystemType *[]string `json:"system_type,omitempty"`

			// Category tags assigned to the asset in Tenable.io.
			Tags *[]struct {
				// The ISO timestamp when the tag was assigned to the asset.
				AddedAt *string `json:"added_at,omitempty"`

				// The UUID of the user who assigned the tag to the asset.
				AddedBy *string `json:"added_by,omitempty"`

				// The tag category(the first half of the category:value pair).
				TagKey *string `json:"tag_key,omitempty"`

				// The UUID of the tag.
				TagUuid *string `json:"tag_uuid,omitempty"`

				// The tag value (the second half of the category:value pair).
				TagValue *string `json:"tag_value,omitempty"`
			} `json:"tags,omitempty"`

			// The UUID of the agent if an agent is present on the asset. If no agent is present on the asset, then the UUID is a unique identifier assigned by Tenable.io during a credentialed scan when the [Create unique identifier on hosts scanned with credentials](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/Classic/AdvancedSettings.htm) option is enabled. Note that no UUID is set for uncredentialed, non-agent scans.
			TenableUuid *[]string `json:"tenable_uuid,omitempty"`

			// The time and date when the asset record was last updated.
			UpdatedAt *string `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAuditLogEventsResponse parses an HTTP response from a AuditLogEventsWithResponse call
func ParseAuditLogEventsResponse(rsp *http.Response) (*AuditLogEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuditLogEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// The action that was taken by the user.
			Action *string `json:"action,omitempty"`
			Actor  *struct {
				// The UUID of the user that took the action.
				Id *string `json:"id,omitempty"`

				// The username of the user that took the action.
				Name *string `json:"name,omitempty"`
			} `json:"actor,omitempty"`

			// Indicates whether the action taken was creating (c), reading (r), updating (u), or deleting (d) an entity.
			Crud *string `json:"crud,omitempty"`

			// A description of the event.
			Description *string `json:"description,omitempty"`
			Fields      *struct {
				Pair *struct {
					// A key. The exact string varies based on the action that was taken.
					Key *string `json:"key,omitempty"`

					// A value that corresponds to a key. The value varies based on the request of the action that was taken.
					Value *string `json:"value,omitempty"`
				} `json:"pair,omitempty"`
			} `json:"fields,omitempty"`

			// The unique ID of the event.
			Id *string `json:"id,omitempty"`

			// Indicates whether the action was performed anonymously.
			IsAnonymous *bool `json:"is_anonymous,omitempty"`

			// Indicates whether the action the user took succeeded or failed. Tenable.io logs an event regardless of whether a user action succeeds.
			IsFailure *bool `json:"is_failure,omitempty"`

			// The date and time the event occured in ISO 8601 format.
			Received *string `json:"received,omitempty"`
			Target   *struct {
				// The UUID of the target entity. For example, a user UUID.
				Id *string `json:"id,omitempty"`

				// The name of the target entity. For example, a username.
				Name *string `json:"name,omitempty"`

				// The type of entity that was the target of the action. For example, a user.
				Type *string `json:"type,omitempty"`
			} `json:"target,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoExportsComplianceCreateResponse parses an HTTP response from a IoExportsComplianceCreateWithResponse call
func ParseIoExportsComplianceCreateResponse(rsp *http.Response) (*IoExportsComplianceCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoExportsComplianceCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The UUID of the compliance export job.
			ExportUuid *string `json:"export_uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoExportsComplianceCancelResponse parses an HTTP response from a IoExportsComplianceCancelWithResponse call
func ParseIoExportsComplianceCancelResponse(rsp *http.Response) (*IoExportsComplianceCancelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoExportsComplianceCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIoExportsComplianceDownloadResponse parses an HTTP response from a IoExportsComplianceDownloadWithResponse call
func ParseIoExportsComplianceDownloadResponse(rsp *http.Response) (*IoExportsComplianceDownloadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoExportsComplianceDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// The actual value (integer, string, or table) evaluated from the compliance check. For example, if a password length compliance check requires passwords to be 8 characters long, but the evaluated value was 7 then `7` is the actual value. For manual checks, this field will contain the output of the command that was executed.
			ActualValue *string `json:"actual_value,omitempty"`

			// The UUID of the asset on which the compliance check was executed.
			AssetUuid *string `json:"asset_uuid,omitempty"`

			// The name of the audit file containing the compliance check.
			AuditFile *string `json:"audit_file,omitempty"`

			// An error message if the compliance evaluation fails.
			CheckError *string `json:"check_error,omitempty"`

			// The unique identifier for the compliance finding.
			CheckId *string `json:"check_id,omitempty"`

			// Full text description of the compliance check.
			CheckInfo *string `json:"check_info,omitempty"`

			// The descriptive name of the compliance check.
			CheckName *string `json:"check_name,omitempty"`

			// The type of database if the compliance check assessed a database.
			DbType *string `json:"db_type,omitempty"`

			// The desired value (integer or string) for the compliance check. For example, if a password length compliance check requires passwords to be 8 characters long then `8` is the expected value. For manual checks, this field will contain the command used for the compliance check.
			ExpectedValue *string `json:"expected_value,omitempty"`

			// The Unix timestamp when a compliance scan first assessed the asset with the compliance check.
			FirstSeen *int64 `json:"first_seen,omitempty"`

			// The Unix timestamp when a compliance scan last assessed the asset with the compliance check.
			LastSeen *int64 `json:"last_seen,omitempty"`

			// The unique ID of the compliance plugin.
			PluginId *int `json:"plugin_id,omitempty"`

			// The name of the profile for the benchmark standard.
			ProfileName *string `json:"profile_name,omitempty"`

			// Industry references for the compliance check.
			Reference *[]struct {
				// The specific control within the compliance framework.
				Control *string `json:"control,omitempty"`

				// The name of the compliance framework.
				Framework *string `json:"framework,omitempty"`
			} `json:"reference,omitempty"`

			// Links to external websites that contain reference information about the compliance check.
			SeeAlso *string `json:"see_also,omitempty"`

			// Remediation information for the compliance check.
			Solution *string `json:"solution,omitempty"`

			// Indicates the result of the compliance check for the given asset.
			//
			// Possible values include:
			//  - PASSEDReturned if the asset has passed the compliance check.
			//  - FAILEDReturned if the asset has failed the compliance check.
			//  - WARNINGReturned in cases where there is no definable passing criteria; for example, an audit where you must verify that members of the administrator group are appropriate for your organization.
			//  - SKIPPEDReturned if the plugin determines that the check is not applicable to the asset. It can also be returned in other various cases; for example, when a check requires that a direct command be run to gather data on an offline network device or if a check contains commands that won't run on the specified OS.
			//  - UNKOWNReturned when a status cannot be determined for the OVAL check. This status is set by the OVAL engine.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoExportsComplianceStatusResponse parses an HTTP response from a IoExportsComplianceStatusWithResponse call
func ParseIoExportsComplianceStatusResponse(rsp *http.Response) (*IoExportsComplianceStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoExportsComplianceStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A comma-separated list of completed chunks available for download.
			ChunksAvailable *[]int32 `json:"chunks_available,omitempty"`

			// The status of the compliance export request. Possible values include:
			//  - PROCESSINGTenable.io has started processing the compliance export request.
			//  - FINISHEDTenable.io has completed processing the export request, the list of chunks is complete, and all chunks are available for download.
			//  - READYSome chunks are now available for download, but Tenable.io is still processing the export request.
			//  - CANCELLEDAn administrator has canceled the export request.
			//  - ERRORTenable.io encountered an error while processing the export request. Tenable recommends that you retry the request. If the status persists on retry, contact Support.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCredentialsListResponse parses an HTTP response from a CredentialsListWithResponse call
func ParseCredentialsListResponse(rsp *http.Response) (*CredentialsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CredentialsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Credentials *[]struct {
				Category *struct {
					// The system name that uniquely identifies the credential category.
					Id *string `json:"id,omitempty"`

					// The display name for the credential category in the user interface.
					Name *string `json:"name,omitempty"`
				} `json:"category,omitempty"`
				CreatedBy *struct {
					// The name of the user who created the credential.
					DisplayName *string `json:"display_name,omitempty"`

					// The ID of the user who created the credential.
					Id *int `json:"id,omitempty"`
				} `json:"created_by,omitempty"`

				// The date (in Unix time) when the managed credential object was created.
				CreatedDate *string `json:"created_date,omitempty"`

				// The definition of the managed credential object. You can specify the description when you create or update the managed credential.
				Description *string `json:"description,omitempty"`
				LastUsedBy  *struct {
					// The name of the user who last used the credential in a scan.
					DisplayName *string `json:"display_name,omitempty"`

					// The ID of the user who last used the credential in a scan.
					Id *int `json:"id,omitempty"`
				} `json:"last_used_by,omitempty"`

				// The name of the managed credential object. You specify the name when you create or update the managed credential.
				Name *string `json:"name,omitempty"`

				// A value specifying the permissions granted to the user or user group for the credential. For possible values, see "Credential Roles" in [Permissions](doc:permissions).
				Permissions *int `json:"permissions,omitempty"`
				Type        *struct {
					// The system name that uniquely identifies the credential type.
					Id *string `json:"id,omitempty"`

					// The display name for the credential type in the user interface.
					Name *string `json:"name,omitempty"`
				} `json:"type,omitempty"`

				// The permissions for the managed credential that are assigned to the user account submitting the API request. For possible values, see "Credential Roles" in [Permissions](doc:permissions).
				UserPermissions *int `json:"user_permissions,omitempty"`

				// The UUID of the managed credential object.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"credentials,omitempty"`
			Pagination *struct {
				// The number of records requested (or the default value if omitted from the request).
				Limit *int32 `json:"limit,omitempty"`

				// The starting record you requested (or zero if omitted).
				Offset *int32 `json:"offset,omitempty"`

				// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
				Sort *[]struct {
					// The field on which Tenable.io sorted the results.
					Name *string `json:"name,omitempty"`

					// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
					Order *string `json:"order,omitempty"`
				} `json:"sort,omitempty"`

				// The total number of records matching your search criteria.
				Total *int32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCredentialsCreateResponse parses an HTTP response from a CredentialsCreateWithResponse call
func ParseCredentialsCreateResponse(rsp *http.Response) (*CredentialsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CredentialsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The UUID of the new managed credential object.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCredentialsFileUploadResponse parses an HTTP response from a CredentialsFileUploadWithResponse call
func ParseCredentialsFileUploadResponse(rsp *http.Response) (*CredentialsFileUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CredentialsFileUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The name of the uploaded file. If the file with the same name already exists, Tenable.io appends an underscore with a number, for example ssh_private_key_1.txt. Use this attribute value when referencing the file for subsequent requests.
			Fileuploaded *string `json:"fileuploaded,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCredentialsListCredentialTypesResponse parses an HTTP response from a CredentialsListCredentialTypesWithResponse call
func ParseCredentialsListCredentialTypesResponse(rsp *http.Response) (*CredentialsListCredentialTypesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CredentialsListCredentialTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Credentials *[]struct {
				// The display name for the category in the user interface.
				Category *string `json:"category,omitempty"`

				// A value specifying whether the list of credential types in the category appears as expanded by default in the user interface.
				DefaultExpand *bool `json:"default_expand,omitempty"`

				// The system name that uniquely identifies the category in Tenable.io.
				Id *string `json:"id,omitempty"`

				// Supported configuration settings for an individual credential type.
				Types *[]struct {
					// The configuration settings for a credential type. For a definition of object attributes, see [Determine Settings for a Credential Type](docs/determine-settings-for-credential-type).
					Configuration *[]struct {
						// Not supported as a parameter in managed credentials.
						AltIds *string `json:"alt_ids,omitempty"`

						// The option that appears as selected by default in the user interface.
						Default *string `json:"default,omitempty"`

						// The system name for the credential parameter. Use this value as the parameter name in request messages configuring credentials.
						Id *string `json:"id,omitempty"`

						// The display name for the credential configuration in the user interface.
						Name *string `json:"name,omitempty"`

						// The supported options for the credential parameter.
						Options *[]struct {
							// The system name for the option.
							Id *string `json:"id,omitempty"`

							// The additional inputs that are required if the user selects this option in the user interface. If the inputs parameter is empty (`\[\]`), selecting the option does not require additional user input.
							Inputs *[]struct {
								// Not supported as a parameter in managed credentials.
								Callback *string `json:"callback,omitempty"`

								// The number of text box rows that appear by default when the input type is `key-value`.
								DefaultRowCount *int `json:"default-row-count,omitempty"`

								// A value specifying whether the user interface hides the value by default when the input type is `key-value`. If `true`, dots appear instead of characters as you type the value in the user interface.
								HideValues *bool `json:"hide-values,omitempty"`

								// Helpful information about the input required, for example, "PEM formatted certificate". Hints appear in the user interface, but can contain information that is relevant to API requests.
								Hint *string `json:"hint,omitempty"`

								// The system name for the input. Use this value as the input name in request messages when configuring credentials.
								Id *string `json:"id,omitempty"`

								// The display name of the option in the user interface.
								Name *string `json:"name,omitempty"`

								// An example of the input value. This value appears as example text in the user interface.
								//
								// This attribute is only present for credential parameters that require text input in the interface.
								//
								// In cases where the input type is `key-value`, this attribute can be an array of strings.
								Placeholder *string `json:"placeholder,omitempty"`

								// A regular expression defining the valid input for the parameter in the user interface.
								Regex *string `json:"regex,omitempty"`

								// A value specifying whether the input is required (`true`) or optional (`false`).
								Required *bool `json:"required,omitempty"`

								// The type of input prompt in the user interface. Possible values include:
								//  - passwordPrompts for input via text box.
								//  - textPrompts for input via text box.
								//  - selectPrompts for input via selectable options.
								//  - filePrompts user to upload file of input data.
								//  - togglePrompts user to select one of two mutually-exclusive options in toggle format.
								//  - checkboxPrompts user to select options via checkboxes. Checkboxes can represent enabling a single option or can allow users to select from multiple, mutually-exclusive options.
								//  - key-value Prompts for text entry of a key-value pair via two text boxes.
								Type *string `json:"type,omitempty"`
							} `json:"inputs,omitempty"`

							// The display name of the option in the user interface.
							Name *string `json:"name,omitempty"`
						} `json:"options,omitempty"`

						// An example of the parameter value. This value appears as example text in the user interface.
						//
						// This attribute is only present for credential parameters that require text input in the user interface.
						Placeholder *string `json:"placeholder,omitempty"`

						// Not supported as a parameter in managed credentials.
						Preferences *[]string `json:"preferences,omitempty"`

						// A value specifying whether the configuration parameter is required (`true`) or optional (`false`). If this attribute is absent, the parameter is optional.
						Required *bool `json:"required,omitempty"`

						// The parameter input type. This attribute reflects how the user interface prompts for parameter input. Possible values include:
						//  - passwordPrompts for input via text box.
						//  - textPrompts for input via text box.
						//  - selectPrompts for input via selectable options.
						//  - filePrompts user to upload file of input data.
						//  - togglePrompts user to toggle an option on or off.
						//  - checkboxPrompts user to select options via checkboxes. Checkboxes can represent enabling a single option or can allow users to select from multiple, mutually-exclusive options.
						Type *string `json:"type,omitempty"`
					} `json:"configuration,omitempty"`

					// A value specifying whether the configuration settings appear expanded by default in the user interface.
					ExpandSettings *bool `json:"expand_settings,omitempty"`

					// The system name that uniquely identifies the credential type.
					Id *string `json:"id,omitempty"`

					// The maximum number of instances of this credential type that Tenable.io supports for an individual scan or policy.
					Max *int `json:"max,omitempty"`

					// The display name for the credential type in the user interface.
					Name *string `json:"name,omitempty"`
				} `json:"types,omitempty"`
			} `json:"credentials,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCredentialsDeleteResponse parses an HTTP response from a CredentialsDeleteWithResponse call
func ParseCredentialsDeleteResponse(rsp *http.Response) (*CredentialsDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CredentialsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Deleted *bool `json:"deleted,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCredentialsDetailsResponse parses an HTTP response from a CredentialsDetailsWithResponse call
func ParseCredentialsDetailsResponse(rsp *http.Response) (*CredentialsDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CredentialsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A value specifying how a user creates a managed credential in the user interface. If `true`, the user created the credential during the scan configuration. If `false`, the user created the credential independently from scan configuration.
			AdHoc    *bool `json:"ad_hoc,omitempty"`
			Category *struct {
				// The system name that uniquely identifies the credential category.
				Id *string `json:"id,omitempty"`

				// The display name for the credential category in the user interface.
				Name *string `json:"name,omitempty"`
			} `json:"category,omitempty"`

			// The definition of the managed credential object. You specify the description when you create or update the managed credential.
			Description *string `json:"description,omitempty"`

			// The name of the managed credential object. You specify the name when you create or update the managed credential.
			Name        *string `json:"name,omitempty"`
			Permissions *[]struct {
				// The UUID of the user or user group granted permissions for the managed credential.
				//
				// This parameter is required when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
				GranteeUuid *string `json:"grantee_uuid,omitempty"`

				// The name of the user or user group that you want to grant permissions for the managed credential.
				//
				// This parameter is optional when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
				Name *string `json:"name,omitempty"`

				// A value specifying the permissions granted to the user or user group for the credential. Possible values are:
				//  - 32The user can view credential information and use the credential in scans. Corresponds to the **Can Use** permission in the user interface.
				//  - 64The user can view and edit credential settings, delete the credential, and use the credential in scans. Corresponds to the **Can Edit** permission in the user interface.
				//
				// This parameter is required when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
				Permissions *int `json:"permissions,omitempty"`

				// A value specifying whether the grantee is a user (`user`) or a user group (`group`).
				//
				// This parameter is required when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
				Type *N200PermissionsType `json:"type,omitempty"`
			} `json:"permissions,omitempty"`

			// The configuration settings for the credential. The parameters of this object vary depending on the credential type. For more information, see [Determine Settings for a Credential Type](doc:determine-settings-for-credential-type).
			Settings *map[string]interface{} `json:"settings,omitempty"`
			Type     *struct {
				// The system name that uniquely identifies the credential type.
				Id *string `json:"id,omitempty"`

				// The display name for the credential type in the user interface.
				Name *string `json:"name,omitempty"`
			} `json:"type,omitempty"`

			// The permissions for the managed credential that are assigned to the user account submitting the API request. For possible values, see "Credential Roles" in [Permissions](doc:permissions).
			UserPermissions *int `json:"user_permissions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCredentialsUpdateResponse parses an HTTP response from a CredentialsUpdateWithResponse call
func ParseCredentialsUpdateResponse(rsp *http.Response) (*CredentialsUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CredentialsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Updated *bool `json:"updated,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditorPluginDescriptionResponse parses an HTTP response from a EditorPluginDescriptionWithResponse call
func ParseEditorPluginDescriptionResponse(rsp *http.Response) (*EditorPluginDescriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditorPluginDescriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The detailed information for a Tenable.io plugin.
			Plugindescription *struct {
				// The attributes of the plugin, including synopsis, description, solution, and risk information.
				Pluginattributes *map[string]interface{} `json:"pluginattributes,omitempty"`

				// The name of the plugin family.
				Pluginfamily *string `json:"pluginfamily,omitempty"`

				// The ID of the plugin.
				Pluginid *int `json:"pluginid,omitempty"`

				// The name of the plugin.
				Pluginname *string `json:"pluginname,omitempty"`

				// The severity level of the vulnerabilities targeted by the plugin
				Severity *string `json:"severity,omitempty"`
			} `json:"plugindescription,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditorListTemplatesResponse parses an HTTP response from a EditorListTemplatesWithResponse call
func ParseEditorListTemplatesResponse(rsp *http.Response) (*EditorListTemplatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditorListTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Templates []struct {
				// If `true`, the template is only available on the cloud.
				CloudOnly *bool `json:"cloud_only,omitempty"`

				// The description of the template.
				Desc *string `json:"desc,omitempty"`

				// If `true`, the template can only be used for agent scans.
				IsAgent *bool `json:"is_agent,omitempty"`

				// If `true`, the template can be used for Web Application Scanning only.
				IsWas *bool `json:"is_was,omitempty"`

				// If `true`, can only be used by manager.
				ManagerOnly *bool `json:"manager_only,omitempty"`

				// The short name of the template.
				Name *string `json:"name,omitempty"`

				// If `true`, the template is only available for subscribers.
				SubscriptionOnly *bool `json:"subscription_only,omitempty"`

				// The long name of the template.
				Title *string `json:"title,omitempty"`

				// If `true`, the template is not supported.
				Unsupported *bool `json:"unsupported,omitempty"`

				// The UUID for the template. Use this value to specify the template when creating scans and policies.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"templates,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditorTemplateDetailsResponse parses an HTTP response from a EditorTemplateDetailsWithResponse call
func ParseEditorTemplateDetailsResponse(rsp *http.Response) (*EditorTemplateDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditorTemplateDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Plugins options enables you to select security checks by Plugin Family or individual plugins checks.
			Compliance *map[string]interface{} `json:"compliance,omitempty"`

			// Credentials that grant the scanner access to the target system without requiring an agent. Credentialed scans can perform a wider variety of checks than non-credentialed scans, which can result in more accurate scan results. This facilitates scanning of a very large network to determine local exposures or compliance violations. You can configure credentials for Cloud Services, Database, Host, Miscellaneous, Mobile Device Management, and Plaintext Authentication.
			Credentials      *map[string]interface{} `json:"credentials,omitempty"`
			FilterAttributes *[]struct {
				Control *struct {
					// A list of options if the input is a dropdown.
					Options *[]map[string]interface{} `json:"options,omitempty"`

					// The placeholder for the input.
					ReadableRegest *string `json:"readable_regest,omitempty"`

					// A regex for checking the value of the input.
					Regex *string `json:"regex,omitempty"`

					// The input type (entry or dropdown).
					Type *string `json:"type,omitempty"`
				} `json:"control,omitempty"`

				// The short name of the filter.
				Name *string `json:"name,omitempty"`

				// The comparison options for the filter.
				Operators *[]map[string]interface{} `json:"operators,omitempty"`

				// The long name of the filter.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filter_attributes,omitempty"`

			// If `true`, the template is for agent scans.
			IsAgent *bool `json:"is_agent,omitempty"`

			// If `true`, the template can be used for Web Application Scanning only. For Vulnerability Management templates, this value is always `null`.
			IsWas *bool `json:"is_was,omitempty"`

			// The short name of the template.
			Name *string `json:"name,omitempty"`

			// The settings for compliance audit checks.
			Plugins *map[string]interface{} `json:"plugins,omitempty"`

			// Scan or policy settings organized into the Basic, Discovery, Assessment, Report, and Advanced configuration categories.
			Settings *struct {
				// The Advanced settings provide increased control over scan efficiency and the operations of a scan, as well as the ability to enabled plugin debugging.
				Advanced *map[string]interface{} `json:"advanced,omitempty"`

				// You can use Assessment settings to configure how a scan identifies vulnerabilities, as well as what vulnerabilities are identified. This includes identifying malware, assessing the vulnerability of a system to brute force attacks, and the susceptibility of web applications.
				Assessment *map[string]interface{} `json:"assessment,omitempty"`

				// The Basic scan settings are used to specify certain organizational and security-related aspects of the scan or policy, including the name of the scan, its targets, whether the scan is scheduled, and who has access to the scan, among other settings.
				Basic *map[string]interface{} `json:"basic,omitempty"`

				// The Discovery settings relate to discovery and port scanning, including port ranges and methods.
				Discovery *map[string]interface{} `json:"discovery,omitempty"`
			} `json:"settings,omitempty"`

			// The long name of the template.
			Title *string `json:"title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditorDetailsResponse parses an HTTP response from a EditorDetailsWithResponse call
func ParseEditorDetailsResponse(rsp *http.Response) (*EditorDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditorDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Plugins options enables you to select security checks by Plugin Family or individual plugins checks.
			Compliance *map[string]interface{} `json:"compliance,omitempty"`

			// Credentials that grant the scanner access to the target system without requiring an agent. Credentialed scans can perform a wider variety of checks than non-credentialed scans, which can result in more accurate scan results. This facilitates scanning of a very large network to determine local exposures or compliance violations. You can configure credentials for Cloud Services, Database, Host, Miscellaneous, Mobile Device Management, and Plaintext Authentication.
			Credentials      *map[string]interface{} `json:"credentials,omitempty"`
			FilterAttributes *[]struct {
				Control *struct {
					// A list of options if the input is a dropdown.
					Options *[]map[string]interface{} `json:"options,omitempty"`

					// The placeholder for the input.
					ReadableRegest *string `json:"readable_regest,omitempty"`

					// A regex for checking the value of the input.
					Regex *string `json:"regex,omitempty"`

					// The input type (entry or dropdown).
					Type *string `json:"type,omitempty"`
				} `json:"control,omitempty"`

				// The short name of the filter.
				Name *string `json:"name,omitempty"`

				// The comparison options for the filter.
				Operators *[]map[string]interface{} `json:"operators,omitempty"`

				// The long name of the filter.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filter_attributes,omitempty"`

			// Indicates whether the scan or user-defined template (policy) can be used for agent scans.
			IsAgent *bool `json:"is_agent,omitempty"`

			// Indicates whether the scan or user-defined template (policy) can be used in Tenable.io Web Application Scanning.
			IsWas *bool `json:"is_was,omitempty"`

			// For scans, the standard text, `custom`. For user-defined templates (policies), the system name for the Tenable-provided template used to create the scan or user-defined template.
			Name *string `json:"name,omitempty"`

			// The username of the owner of the scan or user-defined template (policy).
			Owner *string `json:"owner,omitempty"`

			// The settings for compliance audit checks.
			Plugins *map[string]interface{} `json:"plugins,omitempty"`

			// Scan or policy settings organized into the Basic, Discovery, Assessment, Report, and Advanced configuration categories.
			Settings *struct {
				// The Advanced settings provide increased control over scan efficiency and the operations of a scan, as well as the ability to enabled plugin debugging.
				Advanced *map[string]interface{} `json:"advanced,omitempty"`

				// You can use Assessment settings to configure how a scan identifies vulnerabilities, as well as what vulnerabilities are identified. This includes identifying malware, assessing the vulnerability of a system to brute force attacks, and the susceptibility of web applications.
				Assessment *map[string]interface{} `json:"assessment,omitempty"`

				// The Basic scan settings are used to specify certain organizational and security-related aspects of the scan or policy, including the name of the scan, its targets, whether the scan is scheduled, and who has access to the scan, among other settings.
				Basic *map[string]interface{} `json:"basic,omitempty"`

				// The Discovery settings relate to discovery and port scanning, including port ranges and methods.
				Discovery *map[string]interface{} `json:"discovery,omitempty"`
			} `json:"settings,omitempty"`

			// For scans, the standard text, `Custom Scan`. For user-defined templates (policies), the name of the Tenable-provided template used to create the user-defined template.
			Title *string `json:"title,omitempty"`

			// The scan or policy permissions that the requesting user has for the specified scan or user-defined template (policy). For more information, see [Permissions](doc:permissions).
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the scan or user-defined template (policy).
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEditorAuditsResponse parses an HTTP response from a EditorAuditsWithResponse call
func ParseEditorAuditsResponse(rsp *http.Response) (*EditorAuditsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditorAuditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExclusionsListResponse parses an HTTP response from a ExclusionsListWithResponse call
func ParseExclusionsListResponse(rsp *http.Response) (*ExclusionsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExclusionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// The creation date of the exclusion in Unix time.
			CreationDate *int `json:"creation_date,omitempty"`

			// The description of the exclusion.
			Description *string `json:"description,omitempty"`

			// The unique ID of the exclusion.
			Id *int `json:"id,omitempty"`

			// The last modification date for the exclusion in Unix time.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The targets that you want excluded from scans. Specify multiple targets as a comma-separated string. Targets can be in the following formats:
			//  - an individual IPv4 address (192.0.2.1)
			//  - a range of IPv4 addresses (192.0.2.1-192.0.2.255)
			//  - CIDR notation (192.0.2.0/24)
			//  - a fully-qualified domain name (FQDN) (host.domain.com)
			Members *string `json:"members,omitempty"`

			// The name of the exclusion.
			Name *string `json:"name,omitempty"`

			// The ID of the network object associated with scanners where Tenable.io applies the exclusion. The default network ID is `00000000-0000-0000-0000-000000000000`. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkId *string `json:"network_id,omitempty"`

			// The schedule parameters for the exclusion.
			Schedule *struct {
				// If `true`, the exclusion schedule is active.
				Enabled *bool `json:"enabled,omitempty"`

				// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
				Endtime *string `json:"endtime,omitempty"`

				// The recurrence rules for the exclusion.
				Rrules *struct {
					// The day of the month to repeat a MONTHLY freq rule on.
					Bymonthday *int `json:"bymonthday,omitempty"`

					// A comma-separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
					Byweekday *string `json:"byweekday,omitempty"`

					// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
					Freq *string `json:"freq,omitempty"`

					// The interval of the rule.
					Interval *int `json:"interval,omitempty"`
				} `json:"rrules,omitempty"`

				// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
				Starttime *string `json:"starttime,omitempty"`

				// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
				Timezone *string `json:"timezone,omitempty"`
			} `json:"schedule,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExclusionsCreateResponse parses an HTTP response from a ExclusionsCreateWithResponse call
func ParseExclusionsCreateResponse(rsp *http.Response) (*ExclusionsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExclusionsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The creation date of the exclusion in Unix time.
			CreationDate *int `json:"creation_date,omitempty"`

			// The description of the exclusion.
			Description *string `json:"description,omitempty"`

			// The unique ID of the exclusion.
			Id *int `json:"id,omitempty"`

			// The last modification date for the exclusion in Unix time.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The targets that you want excluded from scans. Specify multiple targets as a comma-separated string. Targets can be in the following formats:
			//  - an individual IPv4 address (192.0.2.1)
			//  - a range of IPv4 addresses (192.0.2.1-192.0.2.255)
			//  - CIDR notation (192.0.2.0/24)
			//  - a fully-qualified domain name (FQDN) (host.domain.com)
			Members *string `json:"members,omitempty"`

			// The name of the exclusion.
			Name *string `json:"name,omitempty"`

			// The ID of the network object associated with scanners where Tenable.io applies the exclusion. The default network ID is `00000000-0000-0000-0000-000000000000`. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkId *string `json:"network_id,omitempty"`

			// The schedule parameters for the exclusion.
			Schedule *struct {
				// If `true`, the exclusion schedule is active.
				Enabled *bool `json:"enabled,omitempty"`

				// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
				Endtime *string `json:"endtime,omitempty"`

				// The recurrence rules for the exclusion.
				Rrules *struct {
					// The day of the month to repeat a MONTHLY freq rule on.
					Bymonthday *int `json:"bymonthday,omitempty"`

					// A comma-separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
					Byweekday *string `json:"byweekday,omitempty"`

					// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
					Freq *string `json:"freq,omitempty"`

					// The interval of the rule.
					Interval *int `json:"interval,omitempty"`
				} `json:"rrules,omitempty"`

				// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
				Starttime *string `json:"starttime,omitempty"`

				// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
				Timezone *string `json:"timezone,omitempty"`
			} `json:"schedule,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExclusionsImportResponse parses an HTTP response from a ExclusionsImportWithResponse call
func ParseExclusionsImportResponse(rsp *http.Response) (*ExclusionsImportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExclusionsImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExclusionsDeleteResponse parses an HTTP response from a ExclusionsDeleteWithResponse call
func ParseExclusionsDeleteResponse(rsp *http.Response) (*ExclusionsDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExclusionsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExclusionsDetailsResponse parses an HTTP response from a ExclusionsDetailsWithResponse call
func ParseExclusionsDetailsResponse(rsp *http.Response) (*ExclusionsDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExclusionsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The creation date of the exclusion in Unix time.
			CreationDate *int `json:"creation_date,omitempty"`

			// The description of the exclusion.
			Description *string `json:"description,omitempty"`

			// The unique ID of the exclusion.
			Id *int `json:"id,omitempty"`

			// The last modification date for the exclusion in Unix time.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The targets that you want excluded from scans. Specify multiple targets as a comma-separated string. Targets can be in the following formats:
			//  - an individual IPv4 address (192.0.2.1)
			//  - a range of IPv4 addresses (192.0.2.1-192.0.2.255)
			//  - CIDR notation (192.0.2.0/24)
			//  - a fully-qualified domain name (FQDN) (host.domain.com)
			Members *string `json:"members,omitempty"`

			// The name of the exclusion.
			Name *string `json:"name,omitempty"`

			// The ID of the network object associated with scanners where Tenable.io applies the exclusion. The default network ID is `00000000-0000-0000-0000-000000000000`. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkId *string `json:"network_id,omitempty"`

			// The schedule parameters for the exclusion.
			Schedule *struct {
				// If `true`, the exclusion schedule is active.
				Enabled *bool `json:"enabled,omitempty"`

				// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
				Endtime *string `json:"endtime,omitempty"`

				// The recurrence rules for the exclusion.
				Rrules *struct {
					// The day of the month to repeat a MONTHLY freq rule on.
					Bymonthday *int `json:"bymonthday,omitempty"`

					// A comma-separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
					Byweekday *string `json:"byweekday,omitempty"`

					// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
					Freq *string `json:"freq,omitempty"`

					// The interval of the rule.
					Interval *int `json:"interval,omitempty"`
				} `json:"rrules,omitempty"`

				// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
				Starttime *string `json:"starttime,omitempty"`

				// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
				Timezone *string `json:"timezone,omitempty"`
			} `json:"schedule,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExclusionsEditResponse parses an HTTP response from a ExclusionsEditWithResponse call
func ParseExclusionsEditResponse(rsp *http.Response) (*ExclusionsEditResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExclusionsEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFileUploadResponse parses an HTTP response from a FileUploadWithResponse call
func ParseFileUploadResponse(rsp *http.Response) (*FileUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The name of the uploaded file. If the file with the same name already exists, Tenable.io appends an underscore with a number. For example, `scan-targets_1.txt`. Use this attribute value when referencing the file for subsequent requests.
			Fileuploaded *string `json:"fileuploaded,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoFiltersCredentialsListResponse parses an HTTP response from a IoFiltersCredentialsListWithResponse call
func ParseIoFiltersCredentialsListResponse(rsp *http.Response) (*IoFiltersCredentialsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoFiltersCredentialsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A list of filters available for the record type.
			Filters *[]struct {
				Control *struct {
					// Provides a human-readable "hint" which describes what the filter string should look like.
					ReadableRegex *string `json:"readable_regex,omitempty"`

					// A regex which can be used by a user interface to validate input.
					Regex *string `json:"regex,omitempty"`

					// The type of UI control which represents the filter.
					Type *string `json:"type,omitempty"`
				} `json:"control,omitempty"`

				// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
				GroupName *string `json:"group_name,omitempty"`

				// The field name to be used in request query strings when applying the filter.
				Name *string `json:"name,omitempty"`

				// Strings which represent the comparison operations which can be used for the filter.
				Operators *[]string `json:"operators,omitempty"`

				// The filter's display label.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filters,omitempty"`

			// The sorting parameters supported for data returned by the endpoint.
			Sort *struct {
				// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
				MaxSortFields *int `json:"max_sort_fields,omitempty"`

				// Fields by which the returned list of records may be sorted.
				SortableFields *[]string `json:"sortable_fields,omitempty"`
			} `json:"sort,omitempty"`

			// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
			WildcardFields *[]string `json:"wildcard_fields,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoFiltersAgentsListResponse parses an HTTP response from a IoFiltersAgentsListWithResponse call
func ParseIoFiltersAgentsListResponse(rsp *http.Response) (*IoFiltersAgentsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoFiltersAgentsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A list of filters available for the record type.
			Filters *[]struct {
				Control *struct {
					// Provides a human-readable "hint" which describes what the filter string should look like.
					ReadableRegex *string `json:"readable_regex,omitempty"`

					// A regex which can be used by a user interface to validate input.
					Regex *string `json:"regex,omitempty"`

					// The type of UI control which represents the filter.
					Type *string `json:"type,omitempty"`
				} `json:"control,omitempty"`

				// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
				GroupName *string `json:"group_name,omitempty"`

				// The field name to be used in request query strings when applying the filter.
				Name *string `json:"name,omitempty"`

				// Strings which represent the comparison operations which can be used for the filter.
				Operators *[]string `json:"operators,omitempty"`

				// The filter's display label.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filters,omitempty"`

			// The sorting parameters supported for data returned by the endpoint.
			Sort *struct {
				// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
				MaxSortFields *int `json:"max_sort_fields,omitempty"`

				// Fields by which the returned list of records may be sorted.
				SortableFields *[]string `json:"sortable_fields,omitempty"`
			} `json:"sort,omitempty"`

			// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
			WildcardFields *[]string `json:"wildcard_fields,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoFiltersScanListResponse parses an HTTP response from a IoFiltersScanListWithResponse call
func ParseIoFiltersScanListResponse(rsp *http.Response) (*IoFiltersScanListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoFiltersScanListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A list of filters available for the record type.
			Filters *[]struct {
				Control *struct {
					// Provides a human-readable "hint" which describes what the filter string should look like.
					ReadableRegex *string `json:"readable_regex,omitempty"`

					// A regex which can be used by a user interface to validate input.
					Regex *string `json:"regex,omitempty"`

					// The type of UI control which represents the filter.
					Type *string `json:"type,omitempty"`
				} `json:"control,omitempty"`

				// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
				GroupName *string `json:"group_name,omitempty"`

				// The field name to be used in request query strings when applying the filter.
				Name *string `json:"name,omitempty"`

				// Strings which represent the comparison operations which can be used for the filter.
				Operators *[]string `json:"operators,omitempty"`

				// The filter's display label.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filters,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoFiltersScanHistoryListResponse parses an HTTP response from a IoFiltersScanHistoryListWithResponse call
func ParseIoFiltersScanHistoryListResponse(rsp *http.Response) (*IoFiltersScanHistoryListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoFiltersScanHistoryListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A list of filters available for the record type.
			Filters *[]struct {
				Control *struct {
					// Provides a human-readable "hint" which describes what the filter string should look like.
					ReadableRegex *string `json:"readable_regex,omitempty"`

					// A regex which can be used by a user interface to validate input.
					Regex *string `json:"regex,omitempty"`

					// The type of UI control which represents the filter.
					Type *string `json:"type,omitempty"`
				} `json:"control,omitempty"`

				// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
				GroupName *string `json:"group_name,omitempty"`

				// The field name to be used in request query strings when applying the filter.
				Name *string `json:"name,omitempty"`

				// Strings which represent the comparison operations which can be used for the filter.
				Operators *[]string `json:"operators,omitempty"`

				// The filter's display label.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filters,omitempty"`

			// The sorting parameters supported for data returned by the endpoint.
			Sort *struct {
				// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
				MaxSortFields *int `json:"max_sort_fields,omitempty"`

				// Fields by which the returned list of records may be sorted.
				SortableFields *[]string `json:"sortable_fields,omitempty"`
			} `json:"sort,omitempty"`

			// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
			WildcardFields *[]string `json:"wildcard_fields,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoFiltersAssetsListResponse parses an HTTP response from a IoFiltersAssetsListWithResponse call
func ParseIoFiltersAssetsListResponse(rsp *http.Response) (*IoFiltersAssetsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoFiltersAssetsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A list of filters available for the record type.
			Filters *[]struct {
				Control *struct {
					// Provides a human-readable "hint" which describes what the filter string should look like.
					ReadableRegex *string `json:"readable_regex,omitempty"`

					// A regex which can be used by a user interface to validate input.
					Regex *string `json:"regex,omitempty"`

					// The type of UI control which represents the filter.
					Type *string `json:"type,omitempty"`
				} `json:"control,omitempty"`

				// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
				GroupName *string `json:"group_name,omitempty"`

				// The field name to be used in request query strings when applying the filter.
				Name *string `json:"name,omitempty"`

				// Strings which represent the comparison operations which can be used for the filter.
				Operators *[]string `json:"operators,omitempty"`

				// The filter's display label.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filters,omitempty"`

			// The sorting parameters supported for data returned by the endpoint.
			Sort *struct {
				// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
				MaxSortFields *int `json:"max_sort_fields,omitempty"`

				// Fields by which the returned list of records may be sorted.
				SortableFields *[]string `json:"sortable_fields,omitempty"`
			} `json:"sort,omitempty"`

			// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
			WildcardFields *[]string `json:"wildcard_fields,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoFiltersAssetsListV2Response parses an HTTP response from a IoFiltersAssetsListV2WithResponse call
func ParseIoFiltersAssetsListV2Response(rsp *http.Response) (*IoFiltersAssetsListV2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoFiltersAssetsListV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A list of filters available for the record type.
			Filters *[]struct {
				Control *struct {
					// Provides a human-readable "hint" which describes what the filter string should look like.
					ReadableRegex *string `json:"readable_regex,omitempty"`

					// A regex which can be used by a user interface to validate input.
					Regex *string `json:"regex,omitempty"`

					// The type of UI control which represents the filter.
					Type *string `json:"type,omitempty"`
				} `json:"control,omitempty"`

				// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
				GroupName *string `json:"group_name,omitempty"`

				// The field name to be used in request query strings when applying the filter.
				Name *string `json:"name,omitempty"`

				// Strings which represent the comparison operations which can be used for the filter.
				Operators *[]string `json:"operators,omitempty"`

				// The filter's display label.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filters,omitempty"`

			// The sorting parameters supported for data returned by the endpoint.
			Sort *struct {
				// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
				MaxSortFields *int `json:"max_sort_fields,omitempty"`

				// Fields by which the returned list of records may be sorted.
				SortableFields *[]string `json:"sortable_fields,omitempty"`
			} `json:"sort,omitempty"`

			// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
			WildcardFields *[]string `json:"wildcard_fields,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoFiltersVulnerabilitiesWorkbenchListResponse parses an HTTP response from a IoFiltersVulnerabilitiesWorkbenchListWithResponse call
func ParseIoFiltersVulnerabilitiesWorkbenchListResponse(rsp *http.Response) (*IoFiltersVulnerabilitiesWorkbenchListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoFiltersVulnerabilitiesWorkbenchListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A list of filters available for the record type.
			Filters *[]struct {
				Control *struct {
					// Provides a human-readable "hint" which describes what the filter string should look like.
					ReadableRegex *string `json:"readable_regex,omitempty"`

					// A regex which can be used by a user interface to validate input.
					Regex *string `json:"regex,omitempty"`

					// The type of UI control which represents the filter.
					Type *string `json:"type,omitempty"`
				} `json:"control,omitempty"`

				// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
				GroupName *string `json:"group_name,omitempty"`

				// The field name to be used in request query strings when applying the filter.
				Name *string `json:"name,omitempty"`

				// Strings which represent the comparison operations which can be used for the filter.
				Operators *[]string `json:"operators,omitempty"`

				// The filter's display label.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filters,omitempty"`

			// The sorting parameters supported for data returned by the endpoint.
			Sort *struct {
				// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
				MaxSortFields *int `json:"max_sort_fields,omitempty"`

				// Fields by which the returned list of records may be sorted.
				SortableFields *[]string `json:"sortable_fields,omitempty"`
			} `json:"sort,omitempty"`

			// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
			WildcardFields *[]string `json:"wildcard_fields,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoFiltersVulnerabilitiesWorkbenchListV2Response parses an HTTP response from a IoFiltersVulnerabilitiesWorkbenchListV2WithResponse call
func ParseIoFiltersVulnerabilitiesWorkbenchListV2Response(rsp *http.Response) (*IoFiltersVulnerabilitiesWorkbenchListV2Response, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoFiltersVulnerabilitiesWorkbenchListV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A list of filters available for the record type.
			Filters *[]struct {
				Control *struct {
					// Provides a human-readable "hint" which describes what the filter string should look like.
					ReadableRegex *string `json:"readable_regex,omitempty"`

					// A regex which can be used by a user interface to validate input.
					Regex *string `json:"regex,omitempty"`

					// The type of UI control which represents the filter.
					Type *string `json:"type,omitempty"`
				} `json:"control,omitempty"`

				// Always set to `NULL`. Legacy attribute associated with deprecated functionality.
				GroupName *string `json:"group_name,omitempty"`

				// The field name to be used in request query strings when applying the filter.
				Name *string `json:"name,omitempty"`

				// Strings which represent the comparison operations which can be used for the filter.
				Operators *[]string `json:"operators,omitempty"`

				// The filter's display label.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filters,omitempty"`

			// The sorting parameters supported for data returned by the endpoint.
			Sort *struct {
				// Maximum number of fields that may be specified for sorting. If this is parameter is not present, any number of fields may be used.
				MaxSortFields *int `json:"max_sort_fields,omitempty"`

				// Fields by which the returned list of records may be sorted.
				SortableFields *[]string `json:"sortable_fields,omitempty"`
			} `json:"sort,omitempty"`

			// Array of strings which represent each field which supports "wildcard" search. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the supported fields' values matches against the filter string, then the record matches the wildcard filter. Note that for a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters.
			WildcardFields *[]string `json:"wildcard_fields,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFoldersListResponse parses an HTTP response from a FoldersListWithResponse call
func ParseFoldersListResponse(rsp *http.Response) (*FoldersListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FoldersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Folders []struct {
				// Indicates whether or not the folder is a custom folder:
				//  - 1User-created folder. You can rename or delete this folder.
				//  - 0System-created folder. You cannot rename or delete this folder.
				Custom *int `json:"custom,omitempty"`

				// Indicates whether or not the folder is the default:
				//  - 1The folder is the default.
				//  - 0The folder is not the default.
				//
				// The main folder is the default folder. You cannot change the default folder.
				DefaultTag *int `json:"default_tag,omitempty"`

				// The unique ID of the folder.
				Id *int `json:"id,omitempty"`

				// The name of the folder. This value corresponds to the folder type as follows:
				//  - mainMy Scans
				//  - trashTrash
				// -customuser-defined string.
				Name *string `json:"name,omitempty"`

				// The type of the folder:
				// - mainTenable-provided folder. Contains all scans that you create but do not assign to a custom folder, as well as any scans shared with you by other users. If you do not specify a scan folder when creating a scan, Tenable.io stores scans in this folder by default. This folder corresponds to the **My Scans** folder in the Tenable.io user interface.
				//  - trashTenable-provided folder. Contains all scans that the current user has moved to the trash folder. Scans stored in the trash folder are automatically deleted after 30 days. This folder corresponds to the **Trash** folder in the Tenable.io user interface.
				//  - customUser-created folder. Contains scans as assigned by the current user. You can create custom folders to meet your organizational needs.
				Type *string `json:"type,omitempty"`

				// The number of scans in the folder that the current user has not yet viewed in the Tenable.io user interface.
				UnreadCount *int `json:"unread_count,omitempty"`
			} "json:\"folders,omitempty\""
		}

		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFoldersCreateResponse parses an HTTP response from a FoldersCreateWithResponse call
func ParseFoldersCreateResponse(rsp *http.Response) (*FoldersCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FoldersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The ID of the created folder.
			Id *int `json:"id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFoldersDeleteResponse parses an HTTP response from a FoldersDeleteWithResponse call
func ParseFoldersDeleteResponse(rsp *http.Response) (*FoldersDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FoldersDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFoldersEditResponse parses an HTTP response from a FoldersEditWithResponse call
func ParseFoldersEditResponse(rsp *http.Response) (*FoldersEditResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FoldersEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetsListImportJobsResponse parses an HTTP response from a AssetsListImportJobsWithResponse call
func ParseAssetsListImportJobsResponse(rsp *http.Response) (*AssetsListImportJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetsListImportJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// The number of batches in the asset import job.
			Batches *int32 `json:"batches,omitempty"`

			// The UUID of your Tenable.io container.
			ContainerId *string `json:"container_id,omitempty"`

			// The Unix timestamp when Tenable.io completed processing the import job.
			EndTime *int32 `json:"end_time,omitempty"`

			// The number of assets from the import job that Tenable.io failed to import.
			FailedAssets *int `json:"failed_assets,omitempty"`

			// The UUID of the asset import job.
			JobId *string `json:"job_id,omitempty"`

			// The Unix timestamp when Tenable.io performed an action on the import job.
			LastUpdateTime *int32 `json:"last_update_time,omitempty"`

			// A user-defined name for the source of the import containing the asset records. You can specify only one source for each import.
			Source *string `json:"source,omitempty"`

			// The Unix timestamp when Tenable.io started processing the import job.
			StartTime *int32 `json:"start_time,omitempty"`

			// The status of the import job. Possible values include: COMPLETE, IN_PROGRESS, or ERROR.
			Status *string `json:"status,omitempty"`

			// The description of why a job failed.
			StatusMessage *string `json:"status_message,omitempty"`

			// The number of assets from the import job that Tenable.io successfully imported.
			UploadedAssets *int32 `json:"uploaded_assets,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetsImportJobInfoResponse parses an HTTP response from a AssetsImportJobInfoWithResponse call
func ParseAssetsImportJobInfoResponse(rsp *http.Response) (*AssetsImportJobInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetsImportJobInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The number of batches in the asset import job.
			Batches *int32 `json:"batches,omitempty"`

			// The UUID of your Tenable.io container.
			ContainerId *string `json:"container_id,omitempty"`

			// The Unix timestamp when Tenable.io completed processing the import job.
			EndTime *int32 `json:"end_time,omitempty"`

			// The number of assets from the import job that Tenable.io failed to import.
			FailedAssets *int `json:"failed_assets,omitempty"`

			// The UUID of the asset import job.
			JobId *string `json:"job_id,omitempty"`

			// The Unix timestamp when Tenable.io performed an action on the import job.
			LastUpdateTime *int32 `json:"last_update_time,omitempty"`

			// A user-defined name for the source of the import containing the asset records. You can specify only one source for each import.
			Source *string `json:"source,omitempty"`

			// The Unix timestamp when Tenable.io started processing the import job.
			StartTime *int32 `json:"start_time,omitempty"`

			// The status of the import job. Possible values include: COMPLETE, IN_PROGRESS, or ERROR.
			Status *string `json:"status,omitempty"`

			// The description of why a job failed.
			StatusMessage *string `json:"status_message,omitempty"`

			// The number of assets from the import job that Tenable.io successfully imported.
			UploadedAssets *int32 `json:"uploaded_assets,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssetsImportResponse parses an HTTP response from a AssetsImportWithResponse call
func ParseAssetsImportResponse(rsp *http.Response) (*AssetsImportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssetsImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The asset import job UUID.
			AssetImportJobUuid *string `json:"asset_import_job_uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVulnerabilitiesImportResponse parses an HTTP response from a VulnerabilitiesImportWithResponse call
func ParseVulnerabilitiesImportResponse(rsp *http.Response) (*VulnerabilitiesImportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VulnerabilitiesImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworksListResponse parses an HTTP response from a NetworksListWithResponse call
func ParseNetworksListResponse(rsp *http.Response) (*NetworksListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworksListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Networks *[]struct {
				// The number of days before assets age out. Assets are permanently deleted if they are not seen on a scan within the specified number of days.<ul><li>Minimum value: 90</li><li>Maximum value: 365</li></ul> Note: If you enable this option, Tenable.io immediately deletes assets in the specified network that have not been seen for the specified number of days. All asset records and associated vulnerabilities are deleted and cannot be recovered. The deleted assets no longer count towards [your license](https://docs.tenable.com/earlyaccess/tenableio/vulnerabilitymanagement/Content/GettingStarted/Licenses.htm)
				AssetsTtlDays *int `json:"assets_ttl_days,omitempty"`

				// The date (in Unix milliseconds) when the network object was created.
				Created *int `json:"created,omitempty"`

				// The UUID of the user who created the network object.
				CreatedBy *string `json:"created_by,omitempty"`

				// The date (in Unix seconds) when the network object was created.
				CreatedInSeconds *int `json:"created_in_seconds,omitempty"`

				// The date (in Unix time) when the network object was deleted. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
				Deleted *int `json:"deleted,omitempty"`

				// The UUID of the user who deleted the network object. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
				DeletedBy *string `json:"deleted_by,omitempty"`

				// The description of the network object.
				Description *string `json:"description,omitempty"`

				// Indicates whether the network object is the default network object. The default network object is a system-generated object that contains any scanners and scanner groups not yet assigned to a custom network object. You cannot update or delete the default network object.
				IsDefault *bool `json:"is_default,omitempty"`

				// The date (in Unix milliseconds) when the network object was last updated.
				Modified *int `json:"modified,omitempty"`

				// The UUID of the user who last updated the network object.
				ModifiedBy *string `json:"modified_by,omitempty"`

				// The date (in Unix seconds) when the network object was last updated.
				ModifiedInSeconds *int `json:"modified_in_seconds,omitempty"`

				// The name of the network object.
				Name *string `json:"name,omitempty"`

				// The UUID of the owner of the network object. The owner of the network object does not have any additional permissions above administrator permissions.
				OwnerUuid *string `json:"owner_uuid,omitempty"`

				// The UUID of the network object.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"networks,omitempty"`
			Pagination *[]struct {
				// The number of records requested (or the default value if omitted from the request).
				Limit *int32 `json:"limit,omitempty"`

				// The starting record you requested (or zero if omitted).
				Offset *int32 `json:"offset,omitempty"`

				// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
				Sort *[]struct {
					// The field on which Tenable.io sorted the results.
					Name *string `json:"name,omitempty"`

					// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
					Order *string `json:"order,omitempty"`
				} `json:"sort,omitempty"`

				// The total number of records matching your search criteria.
				Total *int32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworksCreateResponse parses an HTTP response from a NetworksCreateWithResponse call
func ParseNetworksCreateResponse(rsp *http.Response) (*NetworksCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The number of days before assets age out. Assets are permanently deleted if they are not seen on a scan within the specified number of days.<ul><li>Minimum value: 90</li><li>Maximum value: 365</li></ul> Note: If you enable this option, Tenable.io immediately deletes assets in the specified network that have not been seen for the specified number of days. All asset records and associated vulnerabilities are deleted and cannot be recovered. The deleted assets no longer count towards [your license](https://docs.tenable.com/earlyaccess/tenableio/vulnerabilitymanagement/Content/GettingStarted/Licenses.htm)
			AssetsTtlDays *int `json:"assets_ttl_days,omitempty"`

			// The date (in Unix milliseconds) when the network object was created.
			Created *int `json:"created,omitempty"`

			// The UUID of the user who created the network object.
			CreatedBy *string `json:"created_by,omitempty"`

			// The date (in Unix seconds) when the network object was created.
			CreatedInSeconds *int `json:"created_in_seconds,omitempty"`

			// The date (in Unix time) when the network object was deleted. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
			Deleted *int `json:"deleted,omitempty"`

			// The UUID of the user who deleted the network object. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
			DeletedBy *string `json:"deleted_by,omitempty"`

			// The description of the network object.
			Description *string `json:"description,omitempty"`

			// Indicates whether the network object is the default network object. The default network object is a system-generated object that contains any scanners and scanner groups not yet assigned to a custom network object. You cannot update or delete the default network object.
			IsDefault *bool `json:"is_default,omitempty"`

			// The date (in Unix milliseconds) when the network object was last updated.
			Modified *int `json:"modified,omitempty"`

			// The UUID of the user who last updated the network object.
			ModifiedBy *string `json:"modified_by,omitempty"`

			// The date (in Unix seconds) when the network object was last updated.
			ModifiedInSeconds *int `json:"modified_in_seconds,omitempty"`

			// The name of the network object.
			Name *string `json:"name,omitempty"`

			// The UUID of the owner of the network object. The owner of the network object does not have any additional permissions above administrator permissions.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The UUID of the network object.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworksDeleteResponse parses an HTTP response from a NetworksDeleteWithResponse call
func ParseNetworksDeleteResponse(rsp *http.Response) (*NetworksDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworksDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworksDetailsResponse parses an HTTP response from a NetworksDetailsWithResponse call
func ParseNetworksDetailsResponse(rsp *http.Response) (*NetworksDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworksDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The number of days before assets age out. Assets are permanently deleted if they are not seen on a scan within the specified number of days.<ul><li>Minimum value: 90</li><li>Maximum value: 365</li></ul> Note: If you enable this option, Tenable.io immediately deletes assets in the specified network that have not been seen for the specified number of days. All asset records and associated vulnerabilities are deleted and cannot be recovered. The deleted assets no longer count towards [your license](https://docs.tenable.com/earlyaccess/tenableio/vulnerabilitymanagement/Content/GettingStarted/Licenses.htm)
			AssetsTtlDays *int `json:"assets_ttl_days,omitempty"`

			// The date (in Unix milliseconds) when the network object was created.
			Created *int `json:"created,omitempty"`

			// The UUID of the user who created the network object.
			CreatedBy *string `json:"created_by,omitempty"`

			// The date (in Unix seconds) when the network object was created.
			CreatedInSeconds *int `json:"created_in_seconds,omitempty"`

			// The date (in Unix time) when the network object was deleted. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
			Deleted *int `json:"deleted,omitempty"`

			// The UUID of the user who deleted the network object. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
			DeletedBy *string `json:"deleted_by,omitempty"`

			// The description of the network object.
			Description *string `json:"description,omitempty"`

			// Indicates whether the network object is the default network object. The default network object is a system-generated object that contains any scanners and scanner groups not yet assigned to a custom network object. You cannot update or delete the default network object.
			IsDefault *bool `json:"is_default,omitempty"`

			// The date (in Unix milliseconds) when the network object was last updated.
			Modified *int `json:"modified,omitempty"`

			// The UUID of the user who last updated the network object.
			ModifiedBy *string `json:"modified_by,omitempty"`

			// The date (in Unix seconds) when the network object was last updated.
			ModifiedInSeconds *int `json:"modified_in_seconds,omitempty"`

			// The name of the network object.
			Name *string `json:"name,omitempty"`

			// The UUID of the owner of the network object. The owner of the network object does not have any additional permissions above administrator permissions.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The UUID of the network object.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworksUpdateResponse parses an HTTP response from a NetworksUpdateWithResponse call
func ParseNetworksUpdateResponse(rsp *http.Response) (*NetworksUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworksUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The number of days before assets age out. Assets are permanently deleted if they are not seen on a scan within the specified number of days.<ul><li>Minimum value: 90</li><li>Maximum value: 365</li></ul> Note: If you enable this option, Tenable.io immediately deletes assets in the specified network that have not been seen for the specified number of days. All asset records and associated vulnerabilities are deleted and cannot be recovered. The deleted assets no longer count towards [your license](https://docs.tenable.com/earlyaccess/tenableio/vulnerabilitymanagement/Content/GettingStarted/Licenses.htm)
			AssetsTtlDays *int `json:"assets_ttl_days,omitempty"`

			// The date (in Unix milliseconds) when the network object was created.
			Created *int `json:"created,omitempty"`

			// The UUID of the user who created the network object.
			CreatedBy *string `json:"created_by,omitempty"`

			// The date (in Unix seconds) when the network object was created.
			CreatedInSeconds *int `json:"created_in_seconds,omitempty"`

			// The date (in Unix time) when the network object was deleted. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
			Deleted *int `json:"deleted,omitempty"`

			// The UUID of the user who deleted the network object. This attribute is present for deleted network objects only. To view deleted network objects, use the `includeDeleted` parameter on the [GET /networks](ref:networks-list) endpoint.
			DeletedBy *string `json:"deleted_by,omitempty"`

			// The description of the network object.
			Description *string `json:"description,omitempty"`

			// Indicates whether the network object is the default network object. The default network object is a system-generated object that contains any scanners and scanner groups not yet assigned to a custom network object. You cannot update or delete the default network object.
			IsDefault *bool `json:"is_default,omitempty"`

			// The date (in Unix milliseconds) when the network object was last updated.
			Modified *int `json:"modified,omitempty"`

			// The UUID of the user who last updated the network object.
			ModifiedBy *string `json:"modified_by,omitempty"`

			// The date (in Unix seconds) when the network object was last updated.
			ModifiedInSeconds *int `json:"modified_in_seconds,omitempty"`

			// The name of the network object.
			Name *string `json:"name,omitempty"`

			// The UUID of the owner of the network object. The owner of the network object does not have any additional permissions above administrator permissions.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The UUID of the network object.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworksListAssignableScannersResponse parses an HTTP response from a NetworksListAssignableScannersWithResponse call
func ParseNetworksListAssignableScannersResponse(rsp *http.Response) (*NetworksListAssignableScannersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworksListAssignableScannersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Scanners *[]struct {
				// The date on which the scanner was linked to the Tenable.io instance.
				CreationDate *int32 `json:"creation_date,omitempty"`

				// The scanner software distribution.
				Distro *string `json:"distro,omitempty"`

				// The build of the engine running on the scanner.
				EngineBuild *string `json:"engine_build,omitempty"`

				// The version of the engine running on the scanner.
				EngineVersion *string `json:"engine_version,omitempty"`

				// Indicates whether the object represents a single scanner (`false`) or a scanner group (`true`).
				Group *bool `json:"group,omitempty"`

				// The unique ID of the scanner.
				Id *int32 `json:"id,omitempty"`

				// An alpha-numeric sequence of characters used when linking a scanner to Tenable.io.
				Key *string `json:"key,omitempty"`

				// The Unix timestamp when the scanner last connected to the Tenable.io instance.
				LastConnect *int32 `json:"last_connect,omitempty"`

				// The Unix timestamp when the scanner was last updated.
				LastModificationDate *int `json:"last_modification_date,omitempty"`

				// Indicates if the scanner is enabled (`1`) or not disabled (`0`).
				Linked *int `json:"linked,omitempty"`

				// The current plugin set on the scanner.
				LoadedPluginSet *string `json:"loaded_plugin_set,omitempty"`

				// The user-defined name of the scanner.
				Name *string `json:"name,omitempty"`

				// The number of hosts that the scanner's analysis have discovered.
				NumHosts *int `json:"num_hosts,omitempty"`

				// The number of scan tasks the scanner is currently executing.
				NumScans *int `json:"num_scans,omitempty"`

				// The number of active sessions between the scanner and hosts.
				NumSessions *int `json:"num_sessions,omitempty"`

				// The number of active TCP sessions between the scanner and hosts.
				NumTcpSessions *int `json:"num_tcp_sessions,omitempty"`

				// The scanner owner.
				Owner *string `json:"owner,omitempty"`

				// The ID of the scanner owner.
				OwnerId *int `json:"owner_id,omitempty"`

				// The name of the scanner owner.
				OwnerName *string `json:"owner_name,omitempty"`

				// The UUID of the scanner owner.
				OwnerUuid *string `json:"owner_uuid,omitempty"`

				// The platform of the scanner.
				Platform *string `json:"platform,omitempty"`

				// Indicates whether the scanner is part of a scanner group.
				Pool *bool `json:"pool,omitempty"`

				// The UUID of the Nessus installation on the scanner.
				RemoteUuid *string `json:"remote_uuid,omitempty"`

				// The frequency (in seconds) at which the scanner polls the Tenable.io instance.
				ReportFrequency *int `json:"report_frequency,omitempty"`

				// The current number of scans currently running on the scanner.
				ScanCount *int                    `json:"scan_count,omitempty"`
				Settings  *map[string]interface{} `json:"settings,omitempty"`

				// Historical attribute. Always `service`.
				Source *string `json:"source,omitempty"`

				// The scanner's current status. Possible values are:
				//  - onThe scanner has connected in the last five minutes.
				//  - offThe scanner has not connected in the last five minutes.
				Status *string `json:"status,omitempty"`

				// Indicates whether the scanner supports remote logging.
				SupportsRemoteLogs *bool `json:"supports_remote_logs,omitempty"`

				// Equivalent to the last_modification_date.
				Timestamp *int `json:"timestamp,omitempty"`

				// The type of scanner (local or remote).
				Type *string `json:"type,omitempty"`

				// The UUID of the scanner.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"scanners,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoNetworksAssetCountDetailsResponse parses an HTTP response from a IoNetworksAssetCountDetailsWithResponse call
func ParseIoNetworksAssetCountDetailsResponse(rsp *http.Response) (*IoNetworksAssetCountDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoNetworksAssetCountDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The number of assets in the network not seen since the specified number of days.
			NumAssetsNotSeen *int `json:"numAssetsNotSeen,omitempty"`

			// The total number of assets in the network.
			NumAssetstotal *int `json:"numAssetstotal,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworksListScannersResponse parses an HTTP response from a NetworksListScannersWithResponse call
func ParseNetworksListScannersResponse(rsp *http.Response) (*NetworksListScannersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworksListScannersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Scanners *[]struct {
				// The date on which the scanner was linked to the Tenable.io instance.
				CreationDate *int32 `json:"creation_date,omitempty"`

				// The scanner software distribution.
				Distro *string `json:"distro,omitempty"`

				// The build of the engine running on the scanner.
				EngineBuild *string `json:"engine_build,omitempty"`

				// The version of the engine running on the scanner.
				EngineVersion *string `json:"engine_version,omitempty"`

				// Indicates whether the object represents a single scanner (`false`) or a scanner group (`true`).
				Group *bool `json:"group,omitempty"`

				// The unique ID of the scanner.
				Id *int32 `json:"id,omitempty"`

				// An alpha-numeric sequence of characters used when linking a scanner to Tenable.io.
				Key *string `json:"key,omitempty"`

				// The Unix timestamp when the scanner last connected to the Tenable.io instance.
				LastConnect *int32 `json:"last_connect,omitempty"`

				// The Unix timestamp when the scanner was last updated.
				LastModificationDate *int `json:"last_modification_date,omitempty"`

				// Indicates if the scanner is enabled (`1`) or not disabled (`0`).
				Linked *int `json:"linked,omitempty"`

				// The current plugin set on the scanner.
				LoadedPluginSet *string `json:"loaded_plugin_set,omitempty"`

				// The user-defined name of the scanner.
				Name *string `json:"name,omitempty"`

				// The number of hosts that the scanner's analysis have discovered.
				NumHosts *int `json:"num_hosts,omitempty"`

				// The number of scan tasks the scanner is currently executing.
				NumScans *int `json:"num_scans,omitempty"`

				// The number of active sessions between the scanner and hosts.
				NumSessions *int `json:"num_sessions,omitempty"`

				// The number of active TCP sessions between the scanner and hosts.
				NumTcpSessions *int `json:"num_tcp_sessions,omitempty"`

				// The scanner owner.
				Owner *string `json:"owner,omitempty"`

				// The ID of the scanner owner.
				OwnerId *int `json:"owner_id,omitempty"`

				// The name of the scanner owner.
				OwnerName *string `json:"owner_name,omitempty"`

				// The UUID of the scanner owner.
				OwnerUuid *string `json:"owner_uuid,omitempty"`

				// The platform of the scanner.
				Platform *string `json:"platform,omitempty"`

				// Indicates whether the scanner is part of a scanner group.
				Pool *bool `json:"pool,omitempty"`

				// The UUID of the Nessus installation on the scanner.
				RemoteUuid *string `json:"remote_uuid,omitempty"`

				// The frequency (in seconds) at which the scanner polls the Tenable.io instance.
				ReportFrequency *int `json:"report_frequency,omitempty"`

				// The current number of scans currently running on the scanner.
				ScanCount *int                    `json:"scan_count,omitempty"`
				Settings  *map[string]interface{} `json:"settings,omitempty"`

				// Historical attribute. Always `service`.
				Source *string `json:"source,omitempty"`

				// The scanner's current status. Possible values are:
				//  - onThe scanner has connected in the last five minutes.
				//  - offThe scanner has not connected in the last five minutes.
				Status *string `json:"status,omitempty"`

				// Indicates whether the scanner supports remote logging.
				SupportsRemoteLogs *bool `json:"supports_remote_logs,omitempty"`

				// Equivalent to the last_modification_date.
				Timestamp *int `json:"timestamp,omitempty"`

				// The type of scanner (local or remote).
				Type *string `json:"type,omitempty"`

				// The UUID of the scanner.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"scanners,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworksAssignScannerBulkResponse parses an HTTP response from a NetworksAssignScannerBulkWithResponse call
func ParseNetworksAssignScannerBulkResponse(rsp *http.Response) (*NetworksAssignScannerBulkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworksAssignScannerBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Conflicts *[]struct {
				// A list of scanner groups involved in the conflict.
				ScannerGroups *[]struct {
					// The name of the scanner group.
					Name *string `json:"name,omitempty"`

					// The UUID of the scanner group.
					Uuid *string `json:"uuid,omitempty"`
				} `json:"scanner_groups,omitempty"`

				// The UUID of the scanner involved in the conflict.
				ScannerUuid *string `json:"scanner_uuid,omitempty"`
			} `json:"conflicts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseNetworksAssignScannerResponse parses an HTTP response from a NetworksAssignScannerWithResponse call
func ParseNetworksAssignScannerResponse(rsp *http.Response) (*NetworksAssignScannerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworksAssignScannerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Conflicts *[]struct {
				// A list of scanner groups involved in the conflict.
				ScannerGroups *[]struct {
					// The name of the scanner group.
					Name *string `json:"name,omitempty"`

					// The UUID of the scanner group.
					Uuid *string `json:"uuid,omitempty"`
				} `json:"scanner_groups,omitempty"`

				// The UUID of the scanner involved in the conflict.
				ScannerUuid *string `json:"scanner_uuid,omitempty"`
			} `json:"conflicts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParsePermissionsListResponse parses an HTTP response from a PermissionsListWithResponse call
func ParsePermissionsListResponse(rsp *http.Response) (*PermissionsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermissionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// The display-friendly name of the user or group.
			DisplayName *string `json:"display_name,omitempty"`

			// The unique ID of the user or group.
			Id *int `json:"id,omitempty"`

			// The name of the user or group.
			Name *string `json:"name,omitempty"`

			// The ID of the owner of the object.
			Owner *int `json:"owner,omitempty"`

			// The permission value to grant access as described in [Permissions](doc:permissions).
			Permissions *int32 `json:"permissions,omitempty"`

			// The type of permission (default, user, group).
			Type *N200Type `json:"type,omitempty"`

			// The UUID of the owner of the object.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePermissionsChangeResponse parses an HTTP response from a PermissionsChangeWithResponse call
func ParsePermissionsChangeResponse(rsp *http.Response) (*PermissionsChangeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermissionsChangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoPluginsFamiliesListResponse parses an HTTP response from a IoPluginsFamiliesListWithResponse call
func ParseIoPluginsFamiliesListResponse(rsp *http.Response) (*IoPluginsFamiliesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoPluginsFamiliesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Families *[]struct {
				// The number of plugins in the family.
				Count *int `json:"count,omitempty"`

				// The unique ID of the family.
				Id *int `json:"id,omitempty"`

				// The name of the family.
				Name *string `json:"name,omitempty"`
			} `json:"families,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoPluginsFamilyDetailsResponse parses an HTTP response from a IoPluginsFamilyDetailsWithResponse call
func ParseIoPluginsFamilyDetailsResponse(rsp *http.Response) (*IoPluginsFamilyDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoPluginsFamilyDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The unique ID of the family.
			Id *int `json:"id,omitempty"`

			// The name of the family.
			Name    *string `json:"name,omitempty"`
			Plugins *[]struct {
				// The ID of the plugin.
				Id *int `json:"id,omitempty"`

				// The name of the plugin.
				Name *string `json:"name,omitempty"`
			} `json:"plugins,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoPluginsListResponse parses an HTTP response from a IoPluginsListWithResponse call
func ParseIoPluginsListResponse(rsp *http.Response) (*IoPluginsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoPluginsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				PluginDetails *[]struct {
					// The plugin attributes. For more information, see [Tenable Plugin Attributes](/docs/tenable-plugin-attributes).
					Attributes *[]struct {
						// A list of plugin target systems identified by Common Platform Enumeration (CPE).
						Cpe *[]string `json:"cpe,omitempty"`

						// A list of Common Vulnerabilities and Exposures (CVE) IDs for the vulnerabilities associated with the plugin.
						Cve *[]string `json:"cve,omitempty"`

						// The CVSSv3 base score (intrinsic and fundamental characteristics of a vulnerability that are constant over time and user environments).
						Cvss3BaseScore *string `json:"cvss3_base_score,omitempty"`

						// The CVSSv3 temporal metrics for the vulnerability.
						Cvss3TemporalScore *float32 `json:"cvss3_temporal_score,omitempty"`

						// The CVSSv2 base score (intrinsic and fundamental characteristics of a vulnerability that are constant over time and user environments).
						CvssBaseScore *string `json:"cvss_base_score,omitempty"`

						// The raw CVSSv2 temporal metrics for the vulnerability.
						CvssTemporalScore *float32 `json:"cvss_temporal_score,omitempty"`

						// The raw CVSSv2 metrics for the vulnerability. For more information, see CVSSv2 documentation.
						CvssVector *struct {
							// The CVSSv2 Access Complexity (AC) metric for the vulnerability the plugin covers. Possible values include:<br /> HHigh<br /> MMedium<br /> LLow
							AccessComplexity *string `json:"AccessComplexity,omitempty"`

							// The CVSSv2 Access Vector (AV) metric for the vulnerability the plugin covers. Possible values include: <br /> LLocal<br /> AAdjacent Network<br /> NNetwork
							AccessVector *string `json:"AccessVector,omitempty"`

							// The CVSSv2 Authentication (Au) metric for the vulnerability the plugin covers. Possible values include: <br /> NNone<br /> SSingle<br /> MMultiple
							Authentication *string `json:"Authentication,omitempty"`

							// The CVSSv2 availability impact metric for the vulnerability the plugin covers. Possible values include: <br /> NNone<br /> PPartial<br /> CComplete
							AvailabilityImpact *string `json:"Availability-Impact,omitempty"`

							// The CVSSv2 confidentiality impact metric for the vulnerability the plugin covers. Possible values include: <br /> NNone<br /> PPartial<br /> CComplete
							ConfidentialityImpact *string `json:"Confidentiality-Impact,omitempty"`

							// The CVSSv2 integrity impact metric for the vulnerability the plugin covers. Possible values include: <br /> NNone<br /> PPartial<br /> CComplete
							IntegrityImpact *string `json:"Integrity-Impact,omitempty"`
						} `json:"cvss_vector,omitempty"`

						// Indicates whether the plugin checks for default accounts requiring the use of credentials other than the credentials provided in the scan policy. For more information, see [What are the plugins that test for default accounts?](https://community.tenable.com/s/article/What-are-the-plugins-that-test-for-default-accounts) in the Tenable Community Portal.
						DefaultAccount *string `json:"default_account,omitempty"`

						// The extended description of the plugin.
						Description *string `json:"description,omitempty"`

						// Indicates whether a known public exploit exists for the vulnerability.
						ExploitAvailable *bool `json:"exploit_available,omitempty"`

						// Indicates whether an exploit exists in the Immunity CANVAS framework.
						ExploitFrameworkCanvas *bool `json:"exploit_framework_canvas,omitempty"`

						// Indicates whether an exploit exists in the CORE Impact framework.
						ExploitFrameworkCore *bool `json:"exploit_framework_core,omitempty"`

						// Indicates an exploit exists in the D2 Elliot Web Exploitation framework.
						ExploitFrameworkD2Elliot *bool `json:"exploit_framework_d2_elliot,omitempty"`

						// Indicates whether an exploit exists in the ExploitHub framework.
						ExploitFrameworkExploithub *bool `json:"exploit_framework_exploithub,omitempty"`

						// Indicates whether an exploit exists in the Metasploit framework.
						ExploitFrameworkMetasploit *bool `json:"exploit_framework_metasploit,omitempty"`

						// Indicates whether the vulnerability discovered by this plugin is known to be exploited by malware.
						ExploitedByMalware *bool `json:"exploited_by_malware,omitempty"`

						// Indicates whether Nessus exploited the vulnerability during the process of identification.
						ExploitedByNessus *bool `json:"exploited_by_nessus,omitempty"`

						// Indicates whether the vendor has published a patch for the vulnerability.
						HasPatch *bool `json:"has_patch,omitempty"`

						// Indicates whether this plugin has received media attention (for example, ShellShock, Meltdown).
						InTheNews *bool `json:"in_the_news,omitempty"`

						// Indicates whether the plugin targets potentially malicious files or processes.
						Malware *bool `json:"malware,omitempty"`

						// The date when the vendor published a patch for the vulnerability.
						PatchPublicationDate *string `json:"patch_publication_date,omitempty"`

						// The date when Tenable last updated the plugin.
						PluginModificationDate *string `json:"plugin_modification_date,omitempty"`

						// The date when Tenable originally published the plugin.
						PluginPublicationDate *string `json:"plugin_publication_date,omitempty"`

						// Plugin type, for example, local, remote, or combined. For more information about plugin type, see [Nessus Plugin Types and Categories](https://community.tenable.com/s/article/Nessus-Plugin-Types-and-Categories) in the Tenable Community Portal.
						PluginType *string `json:"plugin_type,omitempty"`

						// The version of the plugin.
						PluginVersion *string `json:"plugin_version,omitempty"`

						// The risk factor associated with the plugin. Possible values are: Low, Medium, High, or Critical.
						RiskFactor *string `json:"risk_factor,omitempty"`

						// Links to external websites that contain helpful information about the vulnerability.
						SeeAlso *[]string `json:"see_also,omitempty"`

						// Remediation information for the vulnerability.
						Solution *string `json:"solution,omitempty"`

						// A brief summary of the vulnerability or vulnerabilities associated with the plugin.
						Synopsis *string `json:"synopsis,omitempty"`

						// Indicates whether the software found by this plugin is unsupported by the software's vendor (for example, Windows 95 or Firefox 3).
						UnsupportedByVendor *bool `json:"unsupported_by_vendor,omitempty"`

						// Information about the Vulnerability Priority Rating (VPR) for the plugin.
						Vpr *struct {
							// The key drivers Tenable uses to calculate a vulnerability's VPR. For more information, see <a href="/docs/vpr-drivers-tio">Vulnerability Priority Rating Drivers</a>.
							Drivers *map[string]interface{} `json:"drivers,omitempty"`

							// The Vulnerability Priority Rating (VPR) for the vulnerability. If a plugin is designed to detect multiple vulnerabilities, the VPR represents the highest value calculated for a vulnerability associated with the plugin. For more information, see <a href="https://docs.tenable.com/cloud/Content/Analysis/RiskMetrics.htm" target="_blank">Severity vs. VPR</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
							Score *float32 `json:"score,omitempty"`

							// The ISO timestamp when Tenable.io last imported the VPR for this vulnerability. Tenable.io imports updated VPR values every time you run a scan.
							Updated *string `json:"updated,omitempty"`
						} `json:"vpr,omitempty"`

						// References to third-party information about the vulnerability, exploit, or update associated with the plugin. Each reference includes a type, for example, 'FEDORA', and an ID, for example, '2003-047'.
						Xref *[]string `json:"xref,omitempty"`

						// References to third-party information about the vulnerability, exploit, or update associated with the plugin. Each reference includes a type and an ID. For example, 'FEDORA' and '2003-047'.
						Xrefs *[]string `json:"xrefs,omitempty"`
					} `json:"attributes,omitempty"`

					// The ID of the plugin.
					Id *int `json:"id,omitempty"`

					// The name of the plugin.
					Name *string `json:"name,omitempty"`
				} `json:"plugin_details,omitempty"`
			} `json:"data,omitempty"`

			// The URL query parameters for the returned data set. If the request does not specify the parameters, contains default values.
			Params *struct {
				// The 'last_updated' filter value.
				LastUpdated *string `json:"last_updated,omitempty"`

				// The result set page index. For example, if page size is 10, page 2 contains records 10-19. Default value is 1.
				Page *int `json:"page,omitempty"`

				// The result set page size. Default value is 1,000.
				Size *int `json:"size,omitempty"`
			} `json:"params,omitempty"`

			// The number of records in the returned result set.
			Size *int `json:"size,omitempty"`

			// The total number of available plugin records after Tenable.io applies the last_updated filter.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoPluginsDetailsResponse parses an HTTP response from a IoPluginsDetailsWithResponse call
func ParseIoPluginsDetailsResponse(rsp *http.Response) (*IoPluginsDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoPluginsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The plugin attributes.
			Attributes *[]struct {
				// The name of the attribute.
				AttributeName *string `json:"attribute_name,omitempty"`

				// The value of the attribute.
				AttributeValue *string `json:"attribute_value,omitempty"`
			} `json:"attributes,omitempty"`

			// The name of the plugin family.
			FamilyName *string `json:"family_name,omitempty"`

			// The ID of the plugin.
			Id *int `json:"id,omitempty"`

			// The name of the plugin.
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePoliciesListResponse parses an HTTP response from a PoliciesListWithResponse call
func ParsePoliciesListResponse(rsp *http.Response) (*PoliciesListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PoliciesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// The creation date of the policy in Unix time format.
			CreationDate *int `json:"creation_date,omitempty"`

			// The description of the policy.
			Description *string `json:"description,omitempty"`

			// The unique ID of the policy.
			Id *int `json:"id,omitempty"`

			// The last modification date for the policy in Unix time format.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The name of the policy.
			Name *string `json:"name,omitempty"`

			// If `true`, the policy configuration does not include targets.
			NoTarget *bool `json:"no_target,omitempty"`

			// The username for the owner of the policy.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the policy.
			OwnerId *string `json:"owner_id,omitempty"`

			// The shared status of the policy (`1` if shared with users other than owner, `0` if not shared).
			Shared *bool `json:"shared,omitempty"`

			// The UUID for the Tenable-provided template used to create the policy.
			TemplateUuid *string `json:"template_uuid,omitempty"`

			// The sharing permissions for the policy.
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The visibility of the target (`private` or `shared`).
			Visibility *int `json:"visibility,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePoliciesCreateResponse parses an HTTP response from a PoliciesCreateWithResponse call
func ParsePoliciesCreateResponse(rsp *http.Response) (*PoliciesCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PoliciesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			PolicyId   *int    `json:"policy_id,omitempty"`
			PolicyName *string `json:"policy_name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePoliciesImportResponse parses an HTTP response from a PoliciesImportWithResponse call
func ParsePoliciesImportResponse(rsp *http.Response) (*PoliciesImportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PoliciesImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CreationDate         *int    `json:"creation_date,omitempty"`
			Description          *string `json:"description,omitempty"`
			Id                   *int    `json:"id,omitempty"`
			LastModificationDate *int    `json:"last_modification_date,omitempty"`
			Name                 *string `json:"name,omitempty"`
			NoTarget             *string `json:"no_target,omitempty"`
			Owner                *string `json:"owner,omitempty"`
			OwnerId              *int    `json:"owner_id,omitempty"`
			Private              *int    `json:"private,omitempty"`
			Shared               *bool   `json:"shared,omitempty"`
			TemplateUuid         *string `json:"template_uuid,omitempty"`
			UserPermissions      *int    `json:"user_permissions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePoliciesDeleteResponse parses an HTTP response from a PoliciesDeleteWithResponse call
func ParsePoliciesDeleteResponse(rsp *http.Response) (*PoliciesDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PoliciesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePoliciesDetailsResponse parses an HTTP response from a PoliciesDetailsWithResponse call
func ParsePoliciesDetailsResponse(rsp *http.Response) (*PoliciesDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PoliciesDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Audits      *map[string]interface{} `json:"audits,omitempty"`
			Credentials *map[string]interface{} `json:"credentials,omitempty"`
			Plugins     *map[string]interface{} `json:"plugins,omitempty"`
			Scap        *map[string]interface{} `json:"scap,omitempty"`
			Settings    *map[string]interface{} `json:"settings,omitempty"`

			// The UUID of the Tenable-provided template used to create this policy.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePoliciesConfigureResponse parses an HTTP response from a PoliciesConfigureWithResponse call
func ParsePoliciesConfigureResponse(rsp *http.Response) (*PoliciesConfigureResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PoliciesConfigureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePoliciesCopyResponse parses an HTTP response from a PoliciesCopyWithResponse call
func ParsePoliciesCopyResponse(rsp *http.Response) (*PoliciesCopyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PoliciesCopyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePoliciesExportResponse parses an HTTP response from a PoliciesExportWithResponse call
func ParsePoliciesExportResponse(rsp *http.Response) (*PoliciesExportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PoliciesExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannerGroupsListResponse parses an HTTP response from a ScannerGroupsListWithResponse call
func ParseScannerGroupsListResponse(rsp *http.Response) (*ScannerGroupsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannerGroupsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The creation date for the scanner group in Unix time.
			CreationDate *int `json:"creation_date,omitempty"`

			// The access permissions for the Default group.
			DefaultPermissions *int `json:"default_permissions,omitempty"`

			// The flag indicating what type of scanner group.
			Flag *string `json:"flag,omitempty"`

			// The unique ID of the scanner group.
			Id *int `json:"id,omitempty"`

			// The last modification date for the scanner group in Unix time.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The name of the scanner group.
			Name *string `json:"name,omitempty"`

			// The name of the network object associated with the scanner group. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkName *string `json:"network_name,omitempty"`

			// The username of the owner of the scanner group.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the scanner group.
			OwnerId *int `json:"owner_id,omitempty"`

			// The number of scans currently tasked to the scanner group.
			ScanCount *int `json:"scan_count,omitempty"`

			// The number of scanners associated with this scanner group.
			ScannerCount *string `json:"scanner_count,omitempty"`

			// The unique scanner ID of the scanner group.
			ScannerId *int `json:"scanner_id,omitempty"`

			// The shared status of the scanner-group.
			Shared *bool `json:"shared,omitempty"`

			// The unique token for a scanner group.
			Token *string `json:"token,omitempty"`

			// The type of scanner group. This is set to "load_balancing" by default.
			Type *string `json:"type,omitempty"`

			// The sharing permissions for the scanner group.
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the scanner group.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannerGroupsCreateResponse parses an HTTP response from a ScannerGroupsCreateWithResponse call
func ParseScannerGroupsCreateResponse(rsp *http.Response) (*ScannerGroupsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannerGroupsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The creation date for the scanner group in Unix time.
			CreationDate *int `json:"creation_date,omitempty"`

			// The access permissions for the Default group.
			DefaultPermissions *int `json:"default_permissions,omitempty"`

			// The flag indicating what type of scanner group.
			Flag *string `json:"flag,omitempty"`

			// The unique ID of the scanner group.
			Id *int `json:"id,omitempty"`

			// The last modification date for the scanner group in Unix time.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The name of the scanner group.
			Name *string `json:"name,omitempty"`

			// The name of the network object associated with the scanner group. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkName *string `json:"network_name,omitempty"`

			// The username of the owner of the scanner group.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the scanner group.
			OwnerId *int `json:"owner_id,omitempty"`

			// The number of scans currently tasked to the scanner group.
			ScanCount *int `json:"scan_count,omitempty"`

			// The number of scanners associated with this scanner group.
			ScannerCount *string `json:"scanner_count,omitempty"`

			// The unique scanner ID of the scanner group.
			ScannerId *int `json:"scanner_id,omitempty"`

			// The shared status of the scanner-group.
			Shared *bool `json:"shared,omitempty"`

			// The unique token for a scanner group.
			Token *string `json:"token,omitempty"`

			// The type of scanner group. This is set to "load_balancing" by default.
			Type *string `json:"type,omitempty"`

			// The sharing permissions for the scanner group.
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the scanner group.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannerGroupsDeleteResponse parses an HTTP response from a ScannerGroupsDeleteWithResponse call
func ParseScannerGroupsDeleteResponse(rsp *http.Response) (*ScannerGroupsDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannerGroupsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannerGroupsDetailsResponse parses an HTTP response from a ScannerGroupsDetailsWithResponse call
func ParseScannerGroupsDetailsResponse(rsp *http.Response) (*ScannerGroupsDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannerGroupsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The creation date for the scanner group in Unix time.
			CreationDate *int `json:"creation_date,omitempty"`

			// The access permissions for the Default group.
			DefaultPermissions *int `json:"default_permissions,omitempty"`

			// The flag indicating what type of scanner group.
			Flag *string `json:"flag,omitempty"`

			// The unique ID of the scanner group.
			Id *int `json:"id,omitempty"`

			// The last modification date for the scanner group in Unix time.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The name of the scanner group.
			Name *string `json:"name,omitempty"`

			// The name of the network object associated with the scanner group. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkName *string `json:"network_name,omitempty"`

			// The username of the owner of the scanner group.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the scanner group.
			OwnerId *int `json:"owner_id,omitempty"`

			// The number of scans currently tasked to the scanner group.
			ScanCount *int `json:"scan_count,omitempty"`

			// The number of scanners associated with this scanner group.
			ScannerCount *string `json:"scanner_count,omitempty"`

			// The unique scanner ID of the scanner group.
			ScannerId *int `json:"scanner_id,omitempty"`

			// The shared status of the scanner-group.
			Shared *bool `json:"shared,omitempty"`

			// The unique token for a scanner group.
			Token *string `json:"token,omitempty"`

			// The type of scanner group. This is set to "load_balancing" by default.
			Type *string `json:"type,omitempty"`

			// The sharing permissions for the scanner group.
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the scanner group.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannerGroupsEditResponse parses an HTTP response from a ScannerGroupsEditWithResponse call
func ParseScannerGroupsEditResponse(rsp *http.Response) (*ScannerGroupsEditResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannerGroupsEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The creation date for the scanner group in Unix time.
			CreationDate *int `json:"creation_date,omitempty"`

			// The access permissions for the Default group.
			DefaultPermissions *int `json:"default_permissions,omitempty"`

			// The flag indicating what type of scanner group.
			Flag *string `json:"flag,omitempty"`

			// The unique ID of the scanner group.
			Id *int `json:"id,omitempty"`

			// The last modification date for the scanner group in Unix time.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The name of the scanner group.
			Name *string `json:"name,omitempty"`

			// The name of the network object associated with the scanner group. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkName *string `json:"network_name,omitempty"`

			// The username of the owner of the scanner group.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the scanner group.
			OwnerId *int `json:"owner_id,omitempty"`

			// The number of scans currently tasked to the scanner group.
			ScanCount *int `json:"scan_count,omitempty"`

			// The number of scanners associated with this scanner group.
			ScannerCount *string `json:"scanner_count,omitempty"`

			// The unique scanner ID of the scanner group.
			ScannerId *int `json:"scanner_id,omitempty"`

			// The shared status of the scanner-group.
			Shared *bool `json:"shared,omitempty"`

			// The unique token for a scanner group.
			Token *string `json:"token,omitempty"`

			// The type of scanner group. This is set to "load_balancing" by default.
			Type *string `json:"type,omitempty"`

			// The sharing permissions for the scanner group.
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the scanner group.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoScannerGroupsListRoutesResponse parses an HTTP response from a IoScannerGroupsListRoutesWithResponse call
func ParseIoScannerGroupsListRoutesResponse(rsp *http.Response) (*IoScannerGroupsListRoutesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoScannerGroupsListRoutesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// A hostname, hostname wildcard, IP address, CIDR address, or IP range. For more information about supported route formats, see [Supported Scan Routing Target Formats](doc:manage-scan-routing-tio#section-supported-scan-routing-target-formats).
			Route string `json:"route"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoScannerGroupsUpdateRoutesResponse parses an HTTP response from a IoScannerGroupsUpdateRoutesWithResponse call
func ParseIoScannerGroupsUpdateRoutesResponse(rsp *http.Response) (*IoScannerGroupsUpdateRoutesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoScannerGroupsUpdateRoutesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// A brief description of the cause of the error.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// A brief description of the cause of the error.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseScannerGroupsListScannersResponse parses an HTTP response from a ScannerGroupsListScannersWithResponse call
func ParseScannerGroupsListScannersResponse(rsp *http.Response) (*ScannerGroupsListScannersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannerGroupsListScannersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Specifies how often, in minutes, the scanner checks in with Tenable.io (Amazon Web Services scanners only).
			AwsUpdateInterval *int `json:"aws_update_interval,omitempty"`

			// The Unix timestamp when the scanner was created. This attribute specifies the original creation date if the scanner was migrated.
			CreationDate *int `json:"creation_date,omitempty"`

			// The scanner operating system distribution.
			Distro *string `json:"distro,omitempty"`

			// The version of the scanner.
			EngineVersion *string `json:"engine_version,omitempty"`

			// Indicates whether the scanner belongs to a scanner group ('true') or not ('false').
			Group *bool `json:"group,omitempty"`

			// The hostname of the scanner.
			Hostname *string `json:"hostname,omitempty"`

			// The unique ID of the scanner.
			Id *int `json:"id,omitempty"`

			// A list of IP addresses associated with the scanner.
			IpAddresses *[]string `json:"ip_addresses,omitempty"`

			// The linking key, that is, the alpha-numeric sequence of characters you use to link a scanner to Tenable.io. For more information about linking a scanner to Tenable.io, see the [Tenable.io Vulnerability Management Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/LinkaSensor.htm).
			Key *string `json:"key,omitempty"`

			// The Unix timestamp when any of the scanner's tasks have provided its last update.
			LastConnect *string `json:"last_connect,omitempty"`

			// The Unix timestamp when the scanner was last modified.
			LastModificationDate *int `json:"last_modification_date,omitempty"`
			License              *struct {
				// The number of agents the scanner is licensed to use.
				Agents *int `json:"agents,omitempty"`
				Apps   *struct {
					Consec *struct {
						// The activation code you used to enable the license. This value is present for standard licenses only.
						ActivationCode *int `json:"activation_code,omitempty"`

						// The Unix timestamp when the license expires.
						ExpirationDate *int `json:"expiration_date,omitempty"`

						// The maximum memory (in GB) on the scanner allotted for the Tenable licensed application.
						MaxGb *int `json:"max_gb,omitempty"`

						// Indicates whether the product license is an evaluation license (`eval`) or standard license (`standard`).
						Mode *string `json:"mode,omitempty"`

						// Indicates that the scanner is licensed to perform Tenable.io Container Security scans.
						Type *string `json:"type,omitempty"`
					} `json:"consec,omitempty"`

					// The Tenable products licensed on the scanner.
					Type *string `json:"type,omitempty"`
					Was  *struct {
						// The activation code you used to enable the license. This value is present for standard licenses only.
						ActivationCode *int `json:"activation_code,omitempty"`

						// The Unix timestamp when the license expires.
						ExpirationDate *int `json:"expiration_date,omitempty"`

						// Indicates whether the product license is an evaluation license (`eval`) or standard license (`standard`).
						Mode *string `json:"mode,omitempty"`

						// Indicates that the scanner is licensed to perform Tenable.io Web Application Scanning scans.
						Type *string `json:"type,omitempty"`

						// The number of web assets which your license authorizes you to scan.
						WebAssets *int `json:"web_assets,omitempty"`
					} `json:"was,omitempty"`
				} `json:"apps,omitempty"`

				// The number of hosts the scanner is licensed to use.
				Ips *int `json:"ips,omitempty"`

				// The number of scanners the scanner is licensed to use.
				Scanners *int `json:"scanners,omitempty"`

				// The license type.
				Type *string `json:"type,omitempty"`
			} `json:"license,omitempty"`

			// Specifies whether you disabled (`0`) or enabled (`1`) the scanner. For more information, see the [PUT /scanners/{scanner_id}/link](ref:scanners-toggle-link-state) endpoint.
			Linked *int `json:"linked,omitempty"`

			// The current plugin set on the scanner.
			LoadedPluginSet *string `json:"loaded_plugin_set,omitempty"`

			// The user-defined name of the scanner.
			Name *string `json:"name,omitempty"`

			// The name of the network object associated with the scanner. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkName *string `json:"network_name,omitempty"`

			// The number of hosts that the scanner's analysis has discovered.
			NumHosts *int `json:"num_hosts,omitempty"`

			// The number of scans (tasks) the scanner is currently executing.
			NumScans *int `json:"num_scans,omitempty"`

			// The number of active sessions between the scanner and hosts.
			NumSessions *int `json:"num_sessions,omitempty"`

			// The number of active TCP sessions between the scanner and hosts.
			NumTcpSessions *int `json:"num_tcp_sessions,omitempty"`

			// The owner of the scanner.
			Owner *string `json:"owner,omitempty"`

			// The ID of the owner of the scanner.
			OwnerId *int `json:"owner_id,omitempty"`

			// The username of the owner of the scanner.
			OwnerName *string `json:"owner_name,omitempty"`

			// The UUID of the owner of the scanner.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The platform of the scanner.
			Platform *string `json:"platform,omitempty"`

			// Indicates whether the scanner is part of a scanner group ('true') or not ('false'). For more information about scanner groups, see the [Scanner Groups](ref:scanner-groups) endpoints.
			Pool *bool `json:"pool,omitempty"`

			// The registration code of the scanner.
			RegistrationCode *string `json:"registration_code,omitempty"`

			// The number of scans that the scanner is currently running.
			ScanCount *int `json:"scan_count,omitempty"`

			// Indicates whether anyone other than the scanner owner has explicit access to the scanner (`1`).
			Shared *bool `json:"shared,omitempty"`

			// Always set to `service`.
			Source *string `json:"source,omitempty"`

			// The status of the scanner (`on` or `off`).
			Status *string `json:"status,omitempty"`

			// Indicates if the scanner supports remote logging.
			SupportsRemoteLogs *bool `json:"supports_remote_logs,omitempty"`

			// Indicates if the scanner supports web application scanning.
			SupportsWebapp *bool `json:"supports_webapp,omitempty"`

			// Equivalent to the `last_modification_date` attribute.
			Timestamp *int `json:"timestamp,omitempty"`

			// The type of scanner (`local`, `managed`, `managed_pvs`, `pool`, `remote`, or `webapp`).
			Type *string `json:"type,omitempty"`

			// The backend build of Nessus that is running on the scanner.
			UiBuild *string `json:"ui_build,omitempty"`

			// The backend version of Nessus that is running on the scanner.
			UiVersion *string `json:"ui_version,omitempty"`

			// The permissions you (the current user) have been assigned for the scanner. See [Permissions](doc:permissions).
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the scanner.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannerGroupsDeleteScannerResponse parses an HTTP response from a ScannerGroupsDeleteScannerWithResponse call
func ParseScannerGroupsDeleteScannerResponse(rsp *http.Response) (*ScannerGroupsDeleteScannerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannerGroupsDeleteScannerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannerGroupsAddScannerResponse parses an HTTP response from a ScannerGroupsAddScannerWithResponse call
func ParseScannerGroupsAddScannerResponse(rsp *http.Response) (*ScannerGroupsAddScannerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannerGroupsAddScannerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannersListResponse parses an HTTP response from a ScannersListWithResponse call
func ParseScannersListResponse(rsp *http.Response) (*ScannersListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Scanners []struct {
				Challenge *string `json:"challenge,omitempty"`

				// Specifies how often, in minutes, the scanner checks in with Tenable.io (Amazon Web Services scanners only).
				AwsUpdateInterval *int `json:"aws_update_interval,omitempty"`

				// The Unix timestamp when the scanner was created. This attribute specifies the original creation date if the scanner was migrated.
				CreationDate *int `json:"creation_date,omitempty"`

				// The scanner operating system distribution.
				Distro *string `json:"distro,omitempty"`

				// The version of the scanner.
				EngineVersion *string `json:"engine_version,omitempty"`

				// Indicates whether the scanner belongs to a scanner group ('true') or not ('false').
				Group *bool `json:"group,omitempty"`

				// The hostname of the scanner.
				Hostname *string `json:"hostname,omitempty"`

				// The unique ID of the scanner.
				Id *int `json:"id,omitempty"`

				// A list of IP addresses associated with the scanner.
				IpAddresses *[]string `json:"ip_addresses,omitempty"`

				// The linking key, that is, the alpha-numeric sequence of characters you use to link a scanner to Tenable.io. For more information about linking a scanner to Tenable.io, see the [Tenable.io Vulnerability Management Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/LinkaSensor.htm).
				Key *string `json:"key,omitempty"`

				// The Unix timestamp when any of the scanner's tasks have provided its last update.
				LastConnect *string `json:"last_connect,omitempty"`

				// The Unix timestamp when the scanner was last modified.
				LastModificationDate *int `json:"last_modification_date,omitempty"`
				License              *struct {
					// The number of agents the scanner is licensed to use.
					Agents *int `json:"agents,omitempty"`
					Apps   *struct {
						Consec *struct {
							// The activation code you used to enable the license. This value is present for standard licenses only.
							ActivationCode *int `json:"activation_code,omitempty"`

							// The Unix timestamp when the license expires.
							ExpirationDate *int `json:"expiration_date,omitempty"`

							// The maximum memory (in GB) on the scanner allotted for the Tenable licensed application.
							MaxGb *int `json:"max_gb,omitempty"`

							// Indicates whether the product license is an evaluation license (`eval`) or standard license (`standard`).
							Mode *string `json:"mode,omitempty"`

							// Indicates that the scanner is licensed to perform Tenable.io Container Security scans.
							Type *string `json:"type,omitempty"`
						} `json:"consec,omitempty"`

						// The Tenable products licensed on the scanner.
						Type *string `json:"type,omitempty"`
						Was  *struct {
							// The activation code you used to enable the license. This value is present for standard licenses only.
							ActivationCode *int `json:"activation_code,omitempty"`

							// The Unix timestamp when the license expires.
							ExpirationDate *int `json:"expiration_date,omitempty"`

							// Indicates whether the product license is an evaluation license (`eval`) or standard license (`standard`).
							Mode *string `json:"mode,omitempty"`

							// Indicates that the scanner is licensed to perform Tenable.io Web Application Scanning scans.
							Type *string `json:"type,omitempty"`

							// The number of web assets which your license authorizes you to scan.
							WebAssets *int `json:"web_assets,omitempty"`
						} `json:"was,omitempty"`
					} `json:"apps,omitempty"`

					// The number of hosts the scanner is licensed to use.
					Ips *int `json:"ips,omitempty"`

					// The number of scanners the scanner is licensed to use.
					Scanners *int `json:"scanners,omitempty"`

					// The license type.
					Type *string `json:"type,omitempty"`
				} `json:"license,omitempty"`

				// Specifies whether you disabled (`0`) or enabled (`1`) the scanner. For more information, see the [PUT /scanners/{scanner_id}/link](ref:scanners-toggle-link-state) endpoint.
				Linked *int `json:"linked,omitempty"`

				// The current plugin set on the scanner.
				LoadedPluginSet *string `json:"loaded_plugin_set,omitempty"`

				// The user-defined name of the scanner.
				Name *string `json:"name,omitempty"`

				// The name of the network object associated with the scanner. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
				NetworkName *string `json:"network_name,omitempty"`

				// The number of hosts that the scanner's analysis has discovered.
				NumHosts *int `json:"num_hosts,omitempty"`

				// The number of scans (tasks) the scanner is currently executing.
				NumScans *int `json:"num_scans,omitempty"`

				// The number of active sessions between the scanner and hosts.
				NumSessions *int `json:"num_sessions,omitempty"`

				// The number of active TCP sessions between the scanner and hosts.
				NumTcpSessions *int `json:"num_tcp_sessions,omitempty"`

				// The owner of the scanner.
				Owner *string `json:"owner,omitempty"`

				// The ID of the owner of the scanner.
				OwnerId *int `json:"owner_id,omitempty"`

				// The username of the owner of the scanner.
				OwnerName *string `json:"owner_name,omitempty"`

				// The UUID of the owner of the scanner.
				OwnerUuid *string `json:"owner_uuid,omitempty"`

				// The platform of the scanner.
				Platform *string `json:"platform,omitempty"`

				// Indicates whether the scanner is part of a scanner group ('true') or not ('false'). For more information about scanner groups, see the [Scanner Groups](ref:scanner-groups) endpoints.
				Pool *bool `json:"pool,omitempty"`

				// The registration code of the scanner.
				RegistrationCode *string `json:"registration_code,omitempty"`

				// The number of scans that the scanner is currently running.
				ScanCount *int `json:"scan_count,omitempty"`

				// Indicates whether anyone other than the scanner owner has explicit access to the scanner (`1`).
				Shared *int `json:"shared,omitempty"`

				// Always set to `service`.
				Source *string `json:"source,omitempty"`

				// The status of the scanner (`on` or `off`).
				Status *string `json:"status,omitempty"`

				// Indicates if the scanner supports remote logging.
				SupportsRemoteLogs *bool `json:"supports_remote_logs,omitempty"`

				// Indicates if the scanner supports web application scanning.
				SupportsWebapp *bool `json:"supports_webapp,omitempty"`

				// Equivalent to the `last_modification_date` attribute.
				Timestamp *int `json:"timestamp,omitempty"`

				// The type of scanner (`local`, `managed`, `managed_pvs`, `pool`, `remote`, or `webapp`).
				Type *string `json:"type,omitempty"`

				// The backend build of Nessus that is running on the scanner.
				UiBuild *string `json:"ui_build,omitempty"`

				// The backend version of Nessus that is running on the scanner.
				UiVersion *string `json:"ui_version,omitempty"`

				// The permissions you (the current user) have been assigned for the scanner. See [Permissions](doc:permissions).
				UserPermissions *int `json:"user_permissions,omitempty"`

				// The UUID of the scanner.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"scanners,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBulkAddAgentsResponse parses an HTTP response from a BulkAddAgentsWithResponse call
func ParseBulkAddAgentsResponse(rsp *http.Response) (*BulkAddAgentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkAddAgentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// `total_work_units_completed` divided by `total_work_units`.
			CompletionPercentage *int `json:"completion_percentage,omitempty"`

			// The UUID of the container where the task is operating.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// End time of the task in unix time milliseconds, if the task is finished.
			EndTime *int `json:"end_time,omitempty"`

			// Last time progress was made on executing the task in unix time milliseconds.
			LastUpdateTime *int `json:"last_update_time,omitempty"`

			// An informative, human-readable message about the state of the task.
			Message *string `json:"message,omitempty"`

			// Start time of the task in unix time milliseconds.
			StartTime *int `json:"start_time,omitempty"`

			// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
			Status *N200Status `json:"status,omitempty"`

			// The UUID of the task.
			TaskId *string `json:"task_id,omitempty"`

			// Total amount of work which the task will attempt to complete.
			TotalWorkUnits *int `json:"total_work_units,omitempty"`

			// Total amount of work that the task has completed.
			TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoAgentBulkOperationsGroupDirectiveResponse parses an HTTP response from a IoAgentBulkOperationsGroupDirectiveWithResponse call
func ParseIoAgentBulkOperationsGroupDirectiveResponse(rsp *http.Response) (*IoAgentBulkOperationsGroupDirectiveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoAgentBulkOperationsGroupDirectiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// `total_work_units_completed` divided by `total_work_units`.
			CompletionPercentage *int `json:"completion_percentage,omitempty"`

			// The UUID of the container where the task is operating.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// End time of the task in unix time milliseconds, if the task is finished.
			EndTime *int `json:"end_time,omitempty"`

			// Last time progress was made on executing the task in unix time milliseconds.
			LastUpdateTime *int `json:"last_update_time,omitempty"`

			// An informative, human-readable message about the state of the task.
			Message *string `json:"message,omitempty"`

			// Start time of the task in unix time milliseconds.
			StartTime *int `json:"start_time,omitempty"`

			// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
			Status *N200Status `json:"status,omitempty"`

			// The UUID of the task.
			TaskId *string `json:"task_id,omitempty"`

			// Total amount of work which the task will attempt to complete.
			TotalWorkUnits *int `json:"total_work_units,omitempty"`

			// Total amount of work that the task has completed.
			TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBulkRemoveAgentsResponse parses an HTTP response from a BulkRemoveAgentsWithResponse call
func ParseBulkRemoveAgentsResponse(rsp *http.Response) (*BulkRemoveAgentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkRemoveAgentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// `total_work_units_completed` divided by `total_work_units`.
			CompletionPercentage *int `json:"completion_percentage,omitempty"`

			// The UUID of the container where the task is operating.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// End time of the task in unix time milliseconds, if the task is finished.
			EndTime *int `json:"end_time,omitempty"`

			// Last time progress was made on executing the task in unix time milliseconds.
			LastUpdateTime *int `json:"last_update_time,omitempty"`

			// An informative, human-readable message about the state of the task.
			Message *string `json:"message,omitempty"`

			// Start time of the task in unix time milliseconds.
			StartTime *int `json:"start_time,omitempty"`

			// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
			Status *N200Status `json:"status,omitempty"`

			// The UUID of the task.
			TaskId *string `json:"task_id,omitempty"`

			// Total amount of work which the task will attempt to complete.
			TotalWorkUnits *int `json:"total_work_units,omitempty"`

			// Total amount of work that the task has completed.
			TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBulkTaskAgentGroupStatusResponse parses an HTTP response from a BulkTaskAgentGroupStatusWithResponse call
func ParseBulkTaskAgentGroupStatusResponse(rsp *http.Response) (*BulkTaskAgentGroupStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkTaskAgentGroupStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// `total_work_units_completed` divided by `total_work_units`.
			CompletionPercentage *int `json:"completion_percentage,omitempty"`

			// The UUID of the container where the task is operating.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// End time of the task in unix time milliseconds, if the task is finished.
			EndTime *int `json:"end_time,omitempty"`

			// Last time progress was made on executing the task in unix time milliseconds.
			LastUpdateTime *int `json:"last_update_time,omitempty"`

			// An informative, human-readable message about the state of the task.
			Message *string `json:"message,omitempty"`

			// Start time of the task in unix time milliseconds.
			StartTime *int `json:"start_time,omitempty"`

			// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
			Status *N200Status `json:"status,omitempty"`

			// The UUID of the task.
			TaskId *string `json:"task_id,omitempty"`

			// Total amount of work which the task will attempt to complete.
			TotalWorkUnits *int `json:"total_work_units,omitempty"`

			// Total amount of work that the task has completed.
			TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoAgentBulkOperationsAddToNetworkResponse parses an HTTP response from a IoAgentBulkOperationsAddToNetworkWithResponse call
func ParseIoAgentBulkOperationsAddToNetworkResponse(rsp *http.Response) (*IoAgentBulkOperationsAddToNetworkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoAgentBulkOperationsAddToNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// `total_work_units_completed` divided by `total_work_units`.
			CompletionPercentage *int `json:"completion_percentage,omitempty"`

			// The UUID of the container where the task is operating.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// End time of the task in unix time milliseconds, if the task is finished.
			EndTime *int `json:"end_time,omitempty"`

			// Last time progress was made on executing the task in unix time milliseconds.
			LastUpdateTime *int `json:"last_update_time,omitempty"`

			// An informative, human-readable message about the state of the task.
			Message *string `json:"message,omitempty"`

			// Start time of the task in unix time milliseconds.
			StartTime *int `json:"start_time,omitempty"`

			// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
			Status *N200Status `json:"status,omitempty"`

			// The UUID of the task.
			TaskId *string `json:"task_id,omitempty"`

			// Total amount of work which the task will attempt to complete.
			TotalWorkUnits *int `json:"total_work_units,omitempty"`

			// Total amount of work that the task has completed.
			TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoAgentBulkOperationsDirectiveResponse parses an HTTP response from a IoAgentBulkOperationsDirectiveWithResponse call
func ParseIoAgentBulkOperationsDirectiveResponse(rsp *http.Response) (*IoAgentBulkOperationsDirectiveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoAgentBulkOperationsDirectiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// `total_work_units_completed` divided by `total_work_units`.
			CompletionPercentage *int `json:"completion_percentage,omitempty"`

			// The UUID of the container where the task is operating.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// End time of the task in unix time milliseconds, if the task is finished.
			EndTime *int `json:"end_time,omitempty"`

			// Last time progress was made on executing the task in unix time milliseconds.
			LastUpdateTime *int `json:"last_update_time,omitempty"`

			// An informative, human-readable message about the state of the task.
			Message *string `json:"message,omitempty"`

			// Start time of the task in unix time milliseconds.
			StartTime *int `json:"start_time,omitempty"`

			// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
			Status *N200Status `json:"status,omitempty"`

			// The UUID of the task.
			TaskId *string `json:"task_id,omitempty"`

			// Total amount of work which the task will attempt to complete.
			TotalWorkUnits *int `json:"total_work_units,omitempty"`

			// Total amount of work that the task has completed.
			TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoAgentBulkOperationsRemoveFromNetworkResponse parses an HTTP response from a IoAgentBulkOperationsRemoveFromNetworkWithResponse call
func ParseIoAgentBulkOperationsRemoveFromNetworkResponse(rsp *http.Response) (*IoAgentBulkOperationsRemoveFromNetworkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoAgentBulkOperationsRemoveFromNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// `total_work_units_completed` divided by `total_work_units`.
			CompletionPercentage *int `json:"completion_percentage,omitempty"`

			// The UUID of the container where the task is operating.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// End time of the task in unix time milliseconds, if the task is finished.
			EndTime *int `json:"end_time,omitempty"`

			// Last time progress was made on executing the task in unix time milliseconds.
			LastUpdateTime *int `json:"last_update_time,omitempty"`

			// An informative, human-readable message about the state of the task.
			Message *string `json:"message,omitempty"`

			// Start time of the task in unix time milliseconds.
			StartTime *int `json:"start_time,omitempty"`

			// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
			Status *N200Status `json:"status,omitempty"`

			// The UUID of the task.
			TaskId *string `json:"task_id,omitempty"`

			// Total amount of work which the task will attempt to complete.
			TotalWorkUnits *int `json:"total_work_units,omitempty"`

			// Total amount of work that the task has completed.
			TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBulkUnlinkAgentsResponse parses an HTTP response from a BulkUnlinkAgentsWithResponse call
func ParseBulkUnlinkAgentsResponse(rsp *http.Response) (*BulkUnlinkAgentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUnlinkAgentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// `total_work_units_completed` divided by `total_work_units`.
			CompletionPercentage *int `json:"completion_percentage,omitempty"`

			// The UUID of the container where the task is operating.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// End time of the task in unix time milliseconds, if the task is finished.
			EndTime *int `json:"end_time,omitempty"`

			// Last time progress was made on executing the task in unix time milliseconds.
			LastUpdateTime *int `json:"last_update_time,omitempty"`

			// An informative, human-readable message about the state of the task.
			Message *string `json:"message,omitempty"`

			// Start time of the task in unix time milliseconds.
			StartTime *int `json:"start_time,omitempty"`

			// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
			Status *N200Status `json:"status,omitempty"`

			// The UUID of the task.
			TaskId *string `json:"task_id,omitempty"`

			// Total amount of work which the task will attempt to complete.
			TotalWorkUnits *int `json:"total_work_units,omitempty"`

			// Total amount of work that the task has completed.
			TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBulkTaskAgentStatusResponse parses an HTTP response from a BulkTaskAgentStatusWithResponse call
func ParseBulkTaskAgentStatusResponse(rsp *http.Response) (*BulkTaskAgentStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkTaskAgentStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// `total_work_units_completed` divided by `total_work_units`.
			CompletionPercentage *int `json:"completion_percentage,omitempty"`

			// The UUID of the container where the task is operating.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// End time of the task in unix time milliseconds, if the task is finished.
			EndTime *int `json:"end_time,omitempty"`

			// Last time progress was made on executing the task in unix time milliseconds.
			LastUpdateTime *int `json:"last_update_time,omitempty"`

			// An informative, human-readable message about the state of the task.
			Message *string `json:"message,omitempty"`

			// Start time of the task in unix time milliseconds.
			StartTime *int `json:"start_time,omitempty"`

			// State of the task. `NEW` means that the task was created, but has not yet started running. `RUNNING` means that the task is in progress. `COMPLETED` means that the task is done. `FAILED` means that there was an error completing the task. `STALE` means that the task has not been updated in a long time.
			Status *N200Status `json:"status,omitempty"`

			// The UUID of the task.
			TaskId *string `json:"task_id,omitempty"`

			// Total amount of work which the task will attempt to complete.
			TotalWorkUnits *int `json:"total_work_units,omitempty"`

			// Total amount of work that the task has completed.
			TotalWorkUnitsCompleted *int `json:"total_work_units_completed,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannersDeleteResponse parses an HTTP response from a ScannersDeleteWithResponse call
func ParseScannersDeleteResponse(rsp *http.Response) (*ScannersDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannersDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannersDetailsResponse parses an HTTP response from a ScannersDetailsWithResponse call
func ParseScannersDetailsResponse(rsp *http.Response) (*ScannersDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannersDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Specifies how often, in minutes, the scanner checks in with Tenable.io (Amazon Web Services scanners only).
			AwsUpdateInterval *int `json:"aws_update_interval,omitempty"`

			// The Unix timestamp when the scanner was created. This attribute specifies the original creation date if the scanner was migrated.
			CreationDate *int `json:"creation_date,omitempty"`

			// The scanner operating system distribution.
			Distro *string `json:"distro,omitempty"`

			// The version of the scanner.
			EngineVersion *string `json:"engine_version,omitempty"`

			// Indicates whether the scanner belongs to a scanner group ('true') or not ('false').
			Group *bool `json:"group,omitempty"`

			// The hostname of the scanner.
			Hostname *string `json:"hostname,omitempty"`

			// The unique ID of the scanner.
			Id *int `json:"id,omitempty"`

			// A list of IP addresses associated with the scanner.
			IpAddresses *[]string `json:"ip_addresses,omitempty"`

			// The linking key, that is, the alpha-numeric sequence of characters you use to link a scanner to Tenable.io. For more information about linking a scanner to Tenable.io, see the [Tenable.io Vulnerability Management Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/LinkaSensor.htm).
			Key *string `json:"key,omitempty"`

			// The Unix timestamp when any of the scanner's tasks have provided its last update.
			LastConnect *string `json:"last_connect,omitempty"`

			// The Unix timestamp when the scanner was last modified.
			LastModificationDate *int `json:"last_modification_date,omitempty"`
			License              *struct {
				// The number of agents the scanner is licensed to use.
				Agents *int `json:"agents,omitempty"`
				Apps   *struct {
					Consec *struct {
						// The activation code you used to enable the license. This value is present for standard licenses only.
						ActivationCode *int `json:"activation_code,omitempty"`

						// The Unix timestamp when the license expires.
						ExpirationDate *int `json:"expiration_date,omitempty"`

						// The maximum memory (in GB) on the scanner allotted for the Tenable licensed application.
						MaxGb *int `json:"max_gb,omitempty"`

						// Indicates whether the product license is an evaluation license (`eval`) or standard license (`standard`).
						Mode *string `json:"mode,omitempty"`

						// Indicates that the scanner is licensed to perform Tenable.io Container Security scans.
						Type *string `json:"type,omitempty"`
					} `json:"consec,omitempty"`

					// The Tenable products licensed on the scanner.
					Type *string `json:"type,omitempty"`
					Was  *struct {
						// The activation code you used to enable the license. This value is present for standard licenses only.
						ActivationCode *int `json:"activation_code,omitempty"`

						// The Unix timestamp when the license expires.
						ExpirationDate *int `json:"expiration_date,omitempty"`

						// Indicates whether the product license is an evaluation license (`eval`) or standard license (`standard`).
						Mode *string `json:"mode,omitempty"`

						// Indicates that the scanner is licensed to perform Tenable.io Web Application Scanning scans.
						Type *string `json:"type,omitempty"`

						// The number of web assets which your license authorizes you to scan.
						WebAssets *int `json:"web_assets,omitempty"`
					} `json:"was,omitempty"`
				} `json:"apps,omitempty"`

				// The number of hosts the scanner is licensed to use.
				Ips *int `json:"ips,omitempty"`

				// The number of scanners the scanner is licensed to use.
				Scanners *int `json:"scanners,omitempty"`

				// The license type.
				Type *string `json:"type,omitempty"`
			} `json:"license,omitempty"`

			// Specifies whether you disabled (`0`) or enabled (`1`) the scanner. For more information, see the [PUT /scanners/{scanner_id}/link](ref:scanners-toggle-link-state) endpoint.
			Linked *int `json:"linked,omitempty"`

			// The current plugin set on the scanner.
			LoadedPluginSet *string `json:"loaded_plugin_set,omitempty"`

			// The user-defined name of the scanner.
			Name *string `json:"name,omitempty"`

			// The name of the network object associated with the scanner. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkName *string `json:"network_name,omitempty"`

			// The number of hosts that the scanner's analysis has discovered.
			NumHosts *int `json:"num_hosts,omitempty"`

			// The number of scans (tasks) the scanner is currently executing.
			NumScans *int `json:"num_scans,omitempty"`

			// The number of active sessions between the scanner and hosts.
			NumSessions *int `json:"num_sessions,omitempty"`

			// The number of active TCP sessions between the scanner and hosts.
			NumTcpSessions *int `json:"num_tcp_sessions,omitempty"`

			// The owner of the scanner.
			Owner *string `json:"owner,omitempty"`

			// The ID of the owner of the scanner.
			OwnerId *int `json:"owner_id,omitempty"`

			// The username of the owner of the scanner.
			OwnerName *string `json:"owner_name,omitempty"`

			// The UUID of the owner of the scanner.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The platform of the scanner.
			Platform *string `json:"platform,omitempty"`

			// Indicates whether the scanner is part of a scanner group ('true') or not ('false'). For more information about scanner groups, see the [Scanner Groups](ref:scanner-groups) endpoints.
			Pool *bool `json:"pool,omitempty"`

			// The registration code of the scanner.
			RegistrationCode *string `json:"registration_code,omitempty"`

			// The number of scans that the scanner is currently running.
			ScanCount *int `json:"scan_count,omitempty"`

			// Indicates whether anyone other than the scanner owner has explicit access to the scanner (`1`).
			Shared *bool `json:"shared,omitempty"`

			// Always set to `service`.
			Source *string `json:"source,omitempty"`

			// The status of the scanner (`on` or `off`).
			Status *string `json:"status,omitempty"`

			// Indicates if the scanner supports remote logging.
			SupportsRemoteLogs *bool `json:"supports_remote_logs,omitempty"`

			// Indicates if the scanner supports web application scanning.
			SupportsWebapp *bool `json:"supports_webapp,omitempty"`

			// Equivalent to the `last_modification_date` attribute.
			Timestamp *int `json:"timestamp,omitempty"`

			// The type of scanner (`local`, `managed`, `managed_pvs`, `pool`, `remote`, or `webapp`).
			Type *string `json:"type,omitempty"`

			// The backend build of Nessus that is running on the scanner.
			UiBuild *string `json:"ui_build,omitempty"`

			// The backend version of Nessus that is running on the scanner.
			UiVersion *string `json:"ui_version,omitempty"`

			// The permissions you (the current user) have been assigned for the scanner. See [Permissions](doc:permissions).
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the scanner.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannersEditResponse parses an HTTP response from a ScannersEditWithResponse call
func ParseScannersEditResponse(rsp *http.Response) (*ScannersEditResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannersEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The UUID of the Tenable.io instance to which the scanner is linked.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// The Unix timestamp when you linked the scanner to the Tenable.io instance.
			Created *int `json:"created,omitempty"`

			// The default permissions value set for the scanner. (Possible values are: 16, 24, 32, 40, and 64)
			DefaultPermissions *int `json:"default_permissions,omitempty"`

			// The unique ID of the scanner.
			Id *int `json:"id,omitempty"`

			// The linking key, that is, the alpha-numeric sequence of characters you use to link a scanner to Tenable.io. For more information about linking a scanner to Tenable.io, see the [Tenable.io Vulnerability Management Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/LinkaSensor.htm).
			Key *string `json:"key,omitempty"`

			// The Unix timestamp when the scanner configuration was last modified.
			Modified *int `json:"modified,omitempty"`

			// The user-defined name of the scanner.
			Name *string `json:"name,omitempty"`

			// The name of the network object associated with the scanner. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkName *string `json:"network_name,omitempty"`

			// The UUID of the owner of the scanner.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// Indicates whether anyone other than the scanner owner has explicit access to the scanner (`1`).
			Shared *bool `json:"shared,omitempty"`

			// The status of the scanner (`on` or `off`).
			Status *string `json:"status,omitempty"`

			// The permissions you (the current user) have been assigned for the scanner. See [Permissions](doc:permissions).
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the scanner.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentGroupsListResponse parses an HTTP response from a AgentGroupsListWithResponse call
func ParseAgentGroupsListResponse(rsp *http.Response) (*AgentGroupsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentGroupsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// The agents in the group. The agent records can be filtered, sorted, and paginated.
			Agents *[]string `json:"agents,omitempty"`

			// The creation date of the agent group in unixtime.
			CreationDate *int `json:"creation_date,omitempty"`

			// The unique ID of the agent group.
			Id *int `json:"id,omitempty"`

			// The last modification date for the agent group in unixtime.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The name of the agent group.
			Name *string `json:"name,omitempty"`

			// The username for the owner of the agent group.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the agent group.
			OwnerId *string `json:"owner_id,omitempty"`

			// The name for the owner of the agent group.
			OwnerName *string `json:"owner_name,omitempty"`

			// The UUID of the owner of the agent group.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The shared status of the agent group.
			Shared *bool `json:"shared,omitempty"`

			// The sharing permissions for the agent group.
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the agent group.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentGroupsCreateResponse parses an HTTP response from a AgentGroupsCreateWithResponse call
func ParseAgentGroupsCreateResponse(rsp *http.Response) (*AgentGroupsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentGroupsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The agents in the group. The agent records can be filtered, sorted, and paginated.
			Agents *[]string `json:"agents,omitempty"`

			// The creation date of the agent group in unixtime.
			CreationDate *int `json:"creation_date,omitempty"`

			// The unique ID of the agent group.
			Id *int `json:"id,omitempty"`

			// The last modification date for the agent group in unixtime.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The name of the agent group.
			Name *string `json:"name,omitempty"`

			// The username for the owner of the agent group.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the agent group.
			OwnerId *string `json:"owner_id,omitempty"`

			// The name for the owner of the agent group.
			OwnerName *string `json:"owner_name,omitempty"`

			// The UUID of the owner of the agent group.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The shared status of the agent group.
			Shared *bool `json:"shared,omitempty"`

			// The sharing permissions for the agent group.
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the agent group.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentGroupListAgentsResponse parses an HTTP response from a AgentGroupListAgentsWithResponse call
func ParseAgentGroupListAgentsResponse(rsp *http.Response) (*AgentGroupListAgentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentGroupListAgentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Agents *[]struct {
				// Build number for the agent.
				CoreBuild *string `json:"core_build,omitempty"`

				// Build version for the agent.
				CoreVersion *string `json:"core_version,omitempty"`

				// The agent software distribution.
				Distro *string `json:"distro,omitempty"`

				// Array of groups to which the agent belongs. Groups are returned in the form {"name": "group name", "id": "group id"}.
				Groups *[]struct {
					// The unique ID of the agent group to which the agent belongs.
					Id *int `json:"id,omitempty"`

					// The name of the agent group to which the agent belongs.
					Name *string `json:"name,omitempty"`
				} `json:"groups,omitempty"`

				// The unique ID of the agent.
				Id *int `json:"id,omitempty"`

				// The IP address of the agent.
				Ip *string `json:"ip,omitempty"`

				// The Unix timestamp when the agent last communicated with Tenable.io.
				LastConnect *int `json:"last_connect,omitempty"`

				// The Unix timestamp when the agent last scanned the asset.
				LastScanned *int `json:"last_scanned,omitempty"`

				// The Unix timestamp when the link from Tenable.io to the agent was established.
				LinkedOn *int `json:"linked_on,omitempty"`

				// The name of the agent.
				Name *string `json:"name,omitempty"`

				// The name of the network that the agent belongs to.
				NetworkName *string `json:"network_name,omitempty"`

				// The UUID of the network that the agent belongs to.
				NetworkUuid *string `json:"network_uuid,omitempty"`

				// The platform of the agent.
				Platform *string `json:"platform,omitempty"`

				// The currently loaded plugin set of the agent (null if the agent has no plugin set loaded).
				PluginFeedId *string `json:"plugin_feed_id,omitempty"`

				// "on", "off", or "init".  "on" means that the agent has connected recently, and is therefore likely ready to scan.  "off" means that the agent has not been seen recently and should be considered offline.  "init" means that the agent is online, but it is still processing plugin updates and is not ready to scan.
				Status *N200AgentsStatus `json:"status,omitempty"`

				// The UUID of the agent. Note: This value corresponds to the ID of the asset where the agent is installed. You can use this attribute to match agent data to asset data.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"agents,omitempty"`
			Pagination *struct {
				// The number of records requested (or the default value if omitted from the request).
				Limit *int32 `json:"limit,omitempty"`

				// The starting record you requested (or zero if omitted).
				Offset *int32 `json:"offset,omitempty"`

				// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
				Sort *[]struct {
					// The field on which Tenable.io sorted the results.
					Name *string `json:"name,omitempty"`

					// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
					Order *string `json:"order,omitempty"`
				} `json:"sort,omitempty"`

				// The total number of records matching your search criteria.
				Total *int32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// A brief description of the cause of the error.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAgentGroupsDeleteResponse parses an HTTP response from a AgentGroupsDeleteWithResponse call
func ParseAgentGroupsDeleteResponse(rsp *http.Response) (*AgentGroupsDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentGroupsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentGroupsDetailsResponse parses an HTTP response from a AgentGroupsDetailsWithResponse call
func ParseAgentGroupsDetailsResponse(rsp *http.Response) (*AgentGroupsDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentGroupsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The agents in the group. The agent records can be filtered, sorted, and paginated.
			Agents *[]string `json:"agents,omitempty"`

			// The creation date of the agent group in unixtime.
			CreationDate *int `json:"creation_date,omitempty"`

			// The unique ID of the agent group.
			Id *int `json:"id,omitempty"`

			// The last modification date for the agent group in unixtime.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The name of the agent group.
			Name *string `json:"name,omitempty"`

			// The username for the owner of the agent group.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the agent group.
			OwnerId *string `json:"owner_id,omitempty"`

			// The name for the owner of the agent group.
			OwnerName *string `json:"owner_name,omitempty"`

			// The UUID of the owner of the agent group.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The shared status of the agent group.
			Shared *bool `json:"shared,omitempty"`

			// The sharing permissions for the agent group.
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the agent group.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentGroupsConfigureResponse parses an HTTP response from a AgentGroupsConfigureWithResponse call
func ParseAgentGroupsConfigureResponse(rsp *http.Response) (*AgentGroupsConfigureResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentGroupsConfigureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentGroupsDeleteAgentResponse parses an HTTP response from a AgentGroupsDeleteAgentWithResponse call
func ParseAgentGroupsDeleteAgentResponse(rsp *http.Response) (*AgentGroupsDeleteAgentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentGroupsDeleteAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentGroupsAddAgentResponse parses an HTTP response from a AgentGroupsAddAgentWithResponse call
func ParseAgentGroupsAddAgentResponse(rsp *http.Response) (*AgentGroupsAddAgentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentGroupsAddAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentsListResponse parses an HTTP response from a AgentsListWithResponse call
func ParseAgentsListResponse(rsp *http.Response) (*AgentsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Agents *[]struct {
				// Build number for the agent.
				CoreBuild *string `json:"core_build,omitempty"`

				// Build version for the agent.
				CoreVersion *string `json:"core_version,omitempty"`

				// The agent software distribution.
				Distro *string `json:"distro,omitempty"`

				// Array of groups to which the agent belongs. Groups are returned in the form {"name": "group name", "id": "group id"}.
				Groups *[]struct {
					// The unique ID of the agent group to which the agent belongs.
					Id *int `json:"id,omitempty"`

					// The name of the agent group to which the agent belongs.
					Name *string `json:"name,omitempty"`
				} `json:"groups,omitempty"`

				// The unique ID of the agent.
				Id *int `json:"id,omitempty"`

				// The IP address of the agent.
				Ip *string `json:"ip,omitempty"`

				// The Unix timestamp when the agent last communicated with Tenable.io.
				LastConnect *int `json:"last_connect,omitempty"`

				// The Unix timestamp when the agent last scanned the asset.
				LastScanned *int `json:"last_scanned,omitempty"`

				// The Unix timestamp when the link from Tenable.io to the agent was established.
				LinkedOn *int `json:"linked_on,omitempty"`

				// The name of the agent.
				Name *string `json:"name,omitempty"`

				// The name of the network that the agent belongs to.
				NetworkName *string `json:"network_name,omitempty"`

				// The UUID of the network that the agent belongs to.
				NetworkUuid *string `json:"network_uuid,omitempty"`

				// The platform of the agent.
				Platform *string `json:"platform,omitempty"`

				// The currently loaded plugin set of the agent (null if the agent has no plugin set loaded).
				PluginFeedId *string `json:"plugin_feed_id,omitempty"`

				// "on", "off", or "init".  "on" means that the agent has connected recently, and is therefore likely ready to scan.  "off" means that the agent has not been seen recently and should be considered offline.  "init" means that the agent is online, but it is still processing plugin updates and is not ready to scan.
				Status *N200AgentsStatus `json:"status,omitempty"`

				// The UUID of the agent. Note: This value corresponds to the ID of the asset where the agent is installed. You can use this attribute to match agent data to asset data.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"agents,omitempty"`
			Pagination *struct {
				// The number of records requested (or the default value if omitted from the request).
				Limit *int32 `json:"limit,omitempty"`

				// The starting record you requested (or zero if omitted).
				Offset *int32 `json:"offset,omitempty"`

				// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
				Sort *[]struct {
					// The field on which Tenable.io sorted the results.
					Name *string `json:"name,omitempty"`

					// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
					Order *string `json:"order,omitempty"`
				} `json:"sort,omitempty"`

				// The total number of records matching your search criteria.
				Total *int32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentConfigDetailsResponse parses an HTTP response from a AgentConfigDetailsWithResponse call
func ParseAgentConfigDetailsResponse(rsp *http.Response) (*AgentConfigDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentConfigDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AutoUnlink *struct {
				// If true, agent auto-unlink is enabled. Enabling auto-unlink causes it to take effect against all agents retroactively.
				Enabled *bool `json:"enabled,omitempty"`

				// The expiration time for agents, in days. If an agent has not communicated in the specified number of days, Tenable.io classifies the agent as expired and auto-unlinks the agent if auto_unlink.enabled is `true`. Valid values are 1-365.
				Expiration *int32 `json:"expiration,omitempty"`
			} `json:"auto_unlink,omitempty"`

			// If true, software updates are enabled for agents pursuant to any agent exclusions that are in effect. If false, software updates are disabled for all agents, even if no agent exclusions are in effect.
			SoftwareUpdate *bool `json:"software_update,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentConfigEditResponse parses an HTTP response from a AgentConfigEditWithResponse call
func ParseAgentConfigEditResponse(rsp *http.Response) (*AgentConfigEditResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentConfigEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AutoUnlink *struct {
				// If true, agent auto-unlink is enabled. Enabling auto-unlink causes it to take effect against all agents retroactively.
				Enabled *bool `json:"enabled,omitempty"`

				// The expiration time for agents, in days. If an agent has not communicated in the specified number of days, Tenable.io classifies the agent as expired and auto-unlinks the agent if auto_unlink.enabled is `true`. Valid values are 1-365.
				Expiration *int32 `json:"expiration,omitempty"`
			} `json:"auto_unlink,omitempty"`

			// If true, software updates are enabled for agents pursuant to any agent exclusions that are in effect. If false, software updates are disabled for all agents, even if no agent exclusions are in effect.
			SoftwareUpdate *bool `json:"software_update,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentExclusionsListResponse parses an HTTP response from a AgentExclusionsListWithResponse call
func ParseAgentExclusionsListResponse(rsp *http.Response) (*AgentExclusionsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentExclusionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// The creation date of the exclusion in unixtime.
			CreationDate *int `json:"creation_date,omitempty"`

			// The description of the exclusion.
			Description *string `json:"description,omitempty"`

			// The unique ID of the exclusion.
			Id *int `json:"id,omitempty"`

			// The last modification date for the exclusion in unixtime.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The name of the exclusion.
			Name     *string `json:"name,omitempty"`
			Schedule *struct {
				// If true, the exclusion is scheduled.
				Enabled *bool `json:"enabled,omitempty"`

				// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
				Endtime *string `json:"endtime,omitempty"`
				Rrules  struct {
					// The day of the month to repeat a MONTHLY freq rule on.
					Bymonthday *int `json:"bymonthday,omitempty"`

					// A comma separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
					Byweekday *string `json:"byweekday,omitempty"`

					// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
					Freq N200ScheduleRrulesFreq `json:"freq"`

					// The interval of the rule.
					Interval *int `json:"interval,omitempty"`
				} `json:"rrules"`

				// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
				Starttime string `json:"starttime"`

				// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
				Timezone string `json:"timezone"`
			} `json:"schedule,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentExclusionsCreateResponse parses an HTTP response from a AgentExclusionsCreateWithResponse call
func ParseAgentExclusionsCreateResponse(rsp *http.Response) (*AgentExclusionsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentExclusionsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The creation date of the exclusion in unixtime.
			CreationDate *int `json:"creation_date,omitempty"`

			// The description of the exclusion.
			Description *string `json:"description,omitempty"`

			// The unique ID of the exclusion.
			Id *int `json:"id,omitempty"`

			// The last modification date for the exclusion in unixtime.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The name of the exclusion.
			Name     *string `json:"name,omitempty"`
			Schedule *struct {
				// If true, the exclusion is scheduled.
				Enabled *bool `json:"enabled,omitempty"`

				// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
				Endtime *string `json:"endtime,omitempty"`
				Rrules  struct {
					// The day of the month to repeat a MONTHLY freq rule on.
					Bymonthday *int `json:"bymonthday,omitempty"`

					// A comma separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
					Byweekday *string `json:"byweekday,omitempty"`

					// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
					Freq N200ScheduleRrulesFreq `json:"freq"`

					// The interval of the rule.
					Interval *int `json:"interval,omitempty"`
				} `json:"rrules"`

				// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
				Starttime string `json:"starttime"`

				// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
				Timezone string `json:"timezone"`
			} `json:"schedule,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentExclusionsDeleteResponse parses an HTTP response from a AgentExclusionsDeleteWithResponse call
func ParseAgentExclusionsDeleteResponse(rsp *http.Response) (*AgentExclusionsDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentExclusionsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentExclusionsDetailsResponse parses an HTTP response from a AgentExclusionsDetailsWithResponse call
func ParseAgentExclusionsDetailsResponse(rsp *http.Response) (*AgentExclusionsDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentExclusionsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The creation date of the exclusion in unixtime.
			CreationDate *int `json:"creation_date,omitempty"`

			// The description of the exclusion.
			Description *string `json:"description,omitempty"`

			// The unique ID of the exclusion.
			Id *int `json:"id,omitempty"`

			// The last modification date for the exclusion in unixtime.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The name of the exclusion.
			Name     *string `json:"name,omitempty"`
			Schedule *struct {
				// If true, the exclusion is scheduled.
				Enabled *bool `json:"enabled,omitempty"`

				// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
				Endtime *string `json:"endtime,omitempty"`
				Rrules  struct {
					// The day of the month to repeat a MONTHLY freq rule on.
					Bymonthday *int `json:"bymonthday,omitempty"`

					// A comma separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
					Byweekday *string `json:"byweekday,omitempty"`

					// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
					Freq N200ScheduleRrulesFreq `json:"freq"`

					// The interval of the rule.
					Interval *int `json:"interval,omitempty"`
				} `json:"rrules"`

				// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
				Starttime string `json:"starttime"`

				// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
				Timezone string `json:"timezone"`
			} `json:"schedule,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentExclusionsEditResponse parses an HTTP response from a AgentExclusionsEditWithResponse call
func ParseAgentExclusionsEditResponse(rsp *http.Response) (*AgentExclusionsEditResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentExclusionsEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentsDeleteResponse parses an HTTP response from a AgentsDeleteWithResponse call
func ParseAgentsDeleteResponse(rsp *http.Response) (*AgentsDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAgentsGetResponse parses an HTTP response from a AgentsGetWithResponse call
func ParseAgentsGetResponse(rsp *http.Response) (*AgentsGetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AgentsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Build number for the agent.
			CoreBuild *string `json:"core_build,omitempty"`

			// Build version for the agent.
			CoreVersion *string `json:"core_version,omitempty"`

			// The agent software distribution.
			Distro *string `json:"distro,omitempty"`

			// Array of groups to which the agent belongs. Groups are returned in the form {"name": "group name", "id": "group id"}.
			Groups *[]struct {
				// The unique ID of the agent group to which the agent belongs.
				Id *int `json:"id,omitempty"`

				// The name of the agent group to which the agent belongs.
				Name *string `json:"name,omitempty"`
			} `json:"groups,omitempty"`

			// The unique ID of the agent.
			Id *int `json:"id,omitempty"`

			// The IP address of the agent.
			Ip *string `json:"ip,omitempty"`

			// The Unix timestamp when the agent last communicated with Tenable.io.
			LastConnect *int `json:"last_connect,omitempty"`

			// The Unix timestamp when the agent last scanned the asset.
			LastScanned *int `json:"last_scanned,omitempty"`

			// The Unix timestamp when the link from Tenable.io to the agent was established.
			LinkedOn *int `json:"linked_on,omitempty"`

			// The name of the agent.
			Name *string `json:"name,omitempty"`

			// The name of the network that the agent belongs to.
			NetworkName *string `json:"network_name,omitempty"`

			// The UUID of the network that the agent belongs to.
			NetworkUuid *string `json:"network_uuid,omitempty"`

			// The platform of the agent.
			Platform *string `json:"platform,omitempty"`

			// The currently loaded plugin set of the agent (null if the agent has no plugin set loaded).
			PluginFeedId *string `json:"plugin_feed_id,omitempty"`

			// "on", "off", or "init".  "on" means that the agent has connected recently, and is therefore likely ready to scan.  "off" means that the agent has not been seen recently and should be considered offline.  "init" means that the agent is online, but it is still processing plugin updates and is not ready to scan.
			Status *N200Status `json:"status,omitempty"`

			// The UUID of the agent. Note: This value corresponds to the ID of the asset where the agent is installed. You can use this attribute to match agent data to asset data.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannersGetAwsTargetsResponse parses an HTTP response from a ScannersGetAwsTargetsWithResponse call
func ParseScannersGetAwsTargetsResponse(rsp *http.Response) (*ScannersGetAwsTargetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannersGetAwsTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Unique instance identifier from Amazon.
			InstanceId *string `json:"instance_id,omitempty"`

			// The user-defined name of the instance.
			Name *string `json:"name,omitempty"`

			// Private IP address of the AWS instance.
			PrivateIp *string `json:"private_ip,omitempty"`

			// Public IP address of the AWS instance.
			PublicIp *string `json:"public_ip,omitempty"`

			// The ID of the scanner.
			ScannerId *int `json:"scanner_id,omitempty"`

			// The state of the instance. Can be one of the following values: `running`, `stopped`, or `terminated`.
			State *string `json:"state,omitempty"`

			// The size of the instance. Example: `t2.small`, `t2.medium`, etc.
			Type *string `json:"type,omitempty"`

			// The availability zone for the instance. Example: `us-east-1a`, `us-east-1b`, etc.
			Zone *string `json:"zone,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannersGetScannerKeyResponse parses an HTTP response from a ScannersGetScannerKeyWithResponse call
func ParseScannersGetScannerKeyResponse(rsp *http.Response) (*ScannersGetScannerKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannersGetScannerKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The linking key, that is, the alpha-numeric sequence of characters you use to link a scanner to Tenable.io. For more information about linking a scanner to Tenable.io, see the [Tenable.io Vulnerability Management Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/LinkaSensor.htm).
			ScannerId *string `json:"scanner_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannersToggleLinkStateResponse parses an HTTP response from a ScannersToggleLinkStateWithResponse call
func ParseScannersToggleLinkStateResponse(rsp *http.Response) (*ScannersToggleLinkStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannersToggleLinkStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannersGetScansResponse parses an HTTP response from a ScannersGetScansWithResponse call
func ParseScannersGetScansResponse(rsp *http.Response) (*ScannersGetScansResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannersGetScansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The scan UUID.
			Id *string `json:"id,omitempty"`

			// The last time the scan was modified.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The name of the scan.
			Name *string `json:"name,omitempty"`

			// The ID of the network object associated with the scanner currently running the scan. The default network ID is `00000000-0000-0000-0000-000000000000`. To determine the ID of a custom network, use the [GET /networks](ref:networks-list) endpoint. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
			NetworkId *string `json:"network_id,omitempty"`

			// Indicates whether the scan is running remotely ('true') or not ('false').
			Remote *bool `json:"remote,omitempty"`

			// The ID of the scan.
			ScanId *int `json:"scan_id,omitempty"`

			// The UUID of the scanner the scan belongs to.
			ScannerUuid *string `json:"scanner_uuid,omitempty"`

			// When the scan was started.
			StartTime *int `json:"start_time,omitempty"`

			// Scan status. Can be one of the following values: pending, processing, stopping, pausing, paused, resuming, or running.
			Status *string `json:"status,omitempty"`

			// The username of the owner of the scan.
			User *string `json:"user,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScannersControlScansResponse parses an HTTP response from a ScannersControlScansWithResponse call
func ParseScannersControlScansResponse(rsp *http.Response) (*ScannersControlScansResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannersControlScansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansListResponse parses an HTTP response from a ScansListWithResponse call
func ParseScansListResponse(rsp *http.Response) (*ScansListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Folders *[]struct {
				// Indicates whether or not the folder is a custom folder:
				//  - 1User-created folder. You can rename or delete this folder.
				//  - 0System-created folder. You cannot rename or delete this folder.
				Custom *int `json:"custom,omitempty"`

				// Indicates whether or not the folder is the default:
				//  - 1The folder is the default.
				//  - 0The folder is not the default.
				//
				// The main folder is the default folder. You cannot change the default folder.
				DefaultTag *int `json:"default_tag,omitempty"`

				// The unique ID of the folder.
				Id *int `json:"id,omitempty"`

				// The name of the folder. This value corresponds to the folder type as follows:
				//  - mainMy Scans
				//  - trashTrash
				// -customuser-defined string.
				Name *string `json:"name,omitempty"`

				// The type of the folder:
				// - mainTenable-provided folder. Contains all scans that you create but do not assign to a custom folder, as well as any scans shared with you by other users. If you do not specify a scan folder when creating a scan, Tenable.io stores scans in this folder by default. This folder corresponds to the **My Scans** folder in the Tenable.io user interface.
				//  - trashTenable-provided folder. Contains all scans that the current user has moved to the trash folder. Scans stored in the trash folder are automatically deleted after 30 days. This folder corresponds to the **Trash** folder in the Tenable.io user interface.
				//  - customUser-created folder. Contains scans as assigned by the current user. You can create custom folders to meet your organizational needs.
				Type *string `json:"type,omitempty"`

				// The number of scans in the folder that the current user has not yet viewed in the Tenable.io user interface.
				UnreadCount *int `json:"unread_count,omitempty"`
			} `json:"folders,omitempty"`
			Scans *[]struct {
				// If `true`, the scan has a schedule and can be launched.
				Control *bool `json:"control,omitempty"`

				// For newly-created scans, the date on which the scan configuration was originally created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was originally created. Instead, it represents the date on which the scan was first launched, in Unix time format.
				CreationDate *int32 `json:"creation_date,omitempty"`

				// Indicates whether the scan schedule is active (`true`) or inactive (`false`).
				Enabled *bool `json:"enabled,omitempty"`

				// The unique ID of the scan.
				Id *int32 `json:"id,omitempty"`

				// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
				LastModificationDate *int32 `json:"last_modification_date,omitempty"`

				// A value indicating whether the scan results were created before a change in storage method. If `true`, Tenable.io stores the results in the old storage method. If `false`, Tenable.io stores the results in the new storage method.
				Legacy *bool `json:"legacy,omitempty"`

				// The name of the scan.
				Name *string `json:"name,omitempty"`

				// The owner of the scan.
				Owner *string `json:"owner,omitempty"`

				// The requesting user's permissions for the scan.
				Permissions *int32 `json:"permissions,omitempty"`

				// The unique ID of the user-defined template (policy) on which the scan configuration is based.
				PolicyId *int `json:"policy_id,omitempty"`

				// A value indicating whether the user account associated with the request message has viewed the scan in the Tenable.io user interface. If `1`, the user account has viewed the scan results.
				Read *bool `json:"read,omitempty"`

				// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
				//
				// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
				Rrules *string `json:"rrules,omitempty"`

				// The UUID for a specific instance in the scan schedule.
				ScheduleUuid *string `json:"schedule_uuid,omitempty"`

				// If `true`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
				Shared *bool `json:"shared,omitempty"`

				// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` attribute.
				//
				// This attribute has the following format: `YYYYMMDDTHHMMSS`.
				Starttime *string `json:"starttime,omitempty"`

				// The status of the scan. For a list of possible values, see [Scan Status](doc:scan-status-tio).
				Status *string `json:"status,omitempty"`

				// The timezone of the scheduled start time for the scan.
				Timezone *string `json:"timezone,omitempty"`

				// The type of scan.
				Type *string `json:"type,omitempty"`

				// The sharing permissions for the scan.
				UserPermissions *int32 `json:"user_permissions,omitempty"`

				// The UUID of the scan.
				Uuid *string `json:"uuid,omitempty"`

				// The UUID of the Tenable-provided template used to create either the scan or the user-defined template (policy) on which the scan configuration is based.
				WizardUuid *string `json:"wizard_uuid,omitempty"`
			} `json:"scans,omitempty"`

			// The Unix timestamp when Tenable.io received the list request.
			Timestamp *int32 `json:"timestamp,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansCreateResponse parses an HTTP response from a ScansCreateWithResponse call
func ParseScansCreateResponse(rsp *http.Response) (*ScansCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The unique ID of your Tenable.io instance.
			ContainerId *string `json:"container_id,omitempty"`

			// For newly-created scans, the date on which the scan configuration was originally created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was originally created. Instead, it represents the date on which the scan was first launched, in Unix time format.
			CreationDate *int32 `json:"creation_date,omitempty"`

			// Targets specified in the `alt_targets` parameter of the [POST /scans/{scan_id}/launch](/reference#scans-launch) request body used to run the scan.
			CustomTargets *string `json:"custom_targets,omitempty"`

			// The name of the dashboard file associated with the scan.
			DashboardFile *string `json:"dashboard_file,omitempty"`

			// The default permissions for the scan.
			DefaultPermissions *int32 `json:"default_permissions,omitempty"`

			// A brief user-defined description of the scan.
			Description *string `json:"description,omitempty"`

			// A comma-separated list of accounts that receive the email summary report.
			Emails *string `json:"emails,omitempty"`

			// A value indicating whether the scan schedule is active (`true`) or inactive (`false`).
			Enabled *bool `json:"enabled,omitempty"`

			// The unique ID of the scan.
			Id *int32 `json:"id,omitempty"`

			// A value indicating whether the scan results appear in dashboards.
			IncludeAggregate *bool `json:"include_aggregate,omitempty"`

			// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
			LastModificationDate *int32 `json:"last_modification_date,omitempty"`

			// The user-defined scan name.
			Name *string `json:"name,omitempty"`

			// A list of filters that Tenable.io applies to determine whether it sends a notification email on scan completion to the recipients specified in the `emails` attribute.
			NotificationFilters *[]struct {
				// The attribute name. For example, use the `risk_factor` attribute if you want to filter on vulnerability severity.
				Filter *string `json:"filter,omitempty"`

				// The operator Tenable.io applies to the filter value, for example, `eq`.
				Quality *string `json:"quality,omitempty"`

				// The attribute value Tenable.io filters on. For example, when filtering on severity, this attribute might specify `Critical`.
				Value *string `json:"value,omitempty"`
			} `json:"notification_filters,omitempty"`

			// The owner of the scan.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the scan.
			OwnerId *int `json:"owner_id,omitempty"`

			// The unique ID of the scan owner.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The unique ID of the policy associated with the scan.
			PolicyId *int `json:"policy_id,omitempty"`

			// If `1`, your vulnerability remediation actions on scan targets have been successful.
			Remediation *int `json:"remediation,omitempty"`

			// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
			//
			// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
			Rrules *string `json:"rrules,omitempty"`

			// The time frame, in minutes, during which agents must transmit scan results to Tenable.io in order to be included in dashboards and reports. If your request omits this parameter, the default value is 180 minutes. For non-agent scans, this attribute is null.
			ScanTimeWindow *string `json:"scan_time_window,omitempty"`

			// The UUID of the scanner that the scan is configured to use, if the scan is *not* configured for [scan routing](doc:manage-scan-routing-tio).
			ScannerUuid *string `json:"scanner_uuid,omitempty"`

			// If `1`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
			Shared *bool `json:"shared,omitempty"`

			// A comma-separated list of mobile phone numbers that receive notification of the scan.
			Sms *string `json:"sms,omitempty"`

			// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` parameter.
			//
			// This attribute has the following format: `YYYYMMDDTHHMMSS`.
			Starttime *string `json:"starttime,omitempty"`

			// The list of asset tag identifiers the scan uses to determine which assets it evaluates. For more information about tag-based scans, see [Manage Tag-Based Scans](doc:manage-tag-based-scans-tio).
			TagTargets *[]string `json:"tag_targets,omitempty"`

			// The type of tag.
			TagType *string `json:"tag_type,omitempty"`

			// The UUID of the network object that Tenable.io associates with the scan results if the scan is configured for [scan routing](doc:manage-scan-routing-tio).
			TargetNetworkUuid *string `json:"target_network_uuid,omitempty"`

			// The timezone of the scheduled start time for the scan.
			Timezone *string `json:"timezone,omitempty"`

			// The type of scan.
			Type *string `json:"type,omitempty"`

			// The sharing permissions for the scan.
			UserPermissions *int32 `json:"user_permissions,omitempty"`

			// The UUID of the schedule for the scan.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// The HTTP status text.
			Error *int `json:"error,omitempty"`

			// A brief message describing the error Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP status code.
			StatusCode *string `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIoScansCheckAutoTargetsResponse parses an HTTP response from a IoScansCheckAutoTargetsWithResponse call
func ParseIoScansCheckAutoTargetsResponse(rsp *http.Response) (*IoScansCheckAutoTargetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoScansCheckAutoTargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A list of UUIDs for scanner groups where configured scan routes matched at least one of the specified targets.
			MatchedResourceUuids *[]string `json:"matched_resource_uuids,omitempty"`

			// The list of targets that did not match a route in any scanner group.
			MissedTargets *[]string `json:"missed_targets,omitempty"`

			// The count of matched resource UUIDs, before being truncated by the optional `matched_resource_limit` parameter.
			TotalMatchedResourceUuids *int `json:"total_matched_resource_uuids,omitempty"`

			// The total count of missed targets, before being truncated by the optional `limit` parameter.
			TotalMissedTargets *int `json:"total_missed_targets,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansImportResponse parses an HTTP response from a ScansImportWithResponse call
func ParseScansImportResponse(rsp *http.Response) (*ScansImportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// If `true`, the scan has a schedule and can be launched.
			Control *bool `json:"control,omitempty"`

			// The creation date for the scan in Unix time.
			CreationDate *int `json:"creation_date,omitempty"`

			// If `true`, the schedule for the scan is enabled.
			Enabled *bool `json:"enabled,omitempty"`

			// The unique ID of the scan.
			Id *int `json:"id,omitempty"`

			// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
			LastModificationDate *int32 `json:"last_modification_date,omitempty"`

			// The name of the scan.
			Name *string `json:"name,omitempty"`

			// The owner of the scan.
			Owner *string `json:"owner,omitempty"`

			// If `true`, the scan has been read.
			Read *bool `json:"read,omitempty"`

			// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
			//
			// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
			Rrules *string `json:"rrules,omitempty"`

			// The UUID for a specific instance in the scan schedule.
			ScheduleUuid *string `json:"schedule_uuid,omitempty"`

			// If `1`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
			Shared *bool `json:"shared,omitempty"`

			// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` attribute.
			//
			// This attribute has the following format: `YYYYMMDDTHHMMSS`.
			Starttime *string `json:"starttime,omitempty"`

			// The status of the scan. For a list of possible values, see [Scan Status](doc:scan-status-tio).
			Status *string `json:"status,omitempty"`

			// The timezone of the scheduled start time for the scan.
			Timezone *string `json:"timezone,omitempty"`

			// The type of scan (local, remote, or agent).
			Type *string `json:"type,omitempty"`

			// The sharing permissions for the scan.
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the scan.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// The HTTP status text.
			Error *int `json:"error,omitempty"`

			// A brief message describing the error Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP status code.
			StatusCode *string `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIoScansRemediationListResponse parses an HTTP response from a IoScansRemediationListWithResponse call
func ParseIoScansRemediationListResponse(rsp *http.Response) (*IoScansRemediationListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoScansRemediationListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Pagination *struct {
				// The number of records requested (or the default value if omitted from the request).
				Limit *int32 `json:"limit,omitempty"`

				// The starting record you requested (or zero if omitted).
				Offset *int32 `json:"offset,omitempty"`

				// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
				Sort *[]struct {
					// The field on which Tenable.io sorted the results.
					Name *string `json:"name,omitempty"`

					// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
					Order *string `json:"order,omitempty"`
				} `json:"sort,omitempty"`

				// The total number of records matching your search criteria.
				Total *int32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
			Scans *[]struct {
				// If `true`, the scan has a schedule and can be launched.
				Control *bool `json:"control,omitempty"`

				// For newly-created scans, the date on which the scan configuration was originally created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was originally created. Instead, it represents the date on which the scan was first launched, in Unix time format.
				CreationDate *int32 `json:"creation_date,omitempty"`

				// Indicates whether the scan schedule is active (`true`) or inactive (`false`).
				Enabled *bool `json:"enabled,omitempty"`

				// The unique ID of the scan.
				Id *int32 `json:"id,omitempty"`

				// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
				LastModificationDate *int32 `json:"last_modification_date,omitempty"`

				// The name of the scan.
				Name *string `json:"name,omitempty"`

				// The owner of the scan.
				Owner *string `json:"owner,omitempty"`

				// The requesting user's permissions for the scan.
				Permissions *int32 `json:"permissions,omitempty"`

				// The unique ID of the user-defined template (policy) on which the scan configuration is based.
				PolicyId *int `json:"policy_id,omitempty"`

				// A value indicating whether the user account associated with the request message has viewed the scan in the Tenable.io user interface. If `1`, the user account has viewed the scan results.
				Read *bool `json:"read,omitempty"`

				// If `1`, your vulnerability remediation actions on scan targets have been successful.
				Remediation *int `json:"remediation,omitempty"`

				// The Unix timestamp when the remediation scan run was created.
				ScanCreationDate *int32 `json:"scan_creation_date,omitempty"`

				// The UUID for a specific instance in the scan schedule.
				ScheduleUuid *string `json:"schedule_uuid,omitempty"`

				// If `true`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
				Shared *bool `json:"shared,omitempty"`

				// The status of the scan. For a list of possible values, see [Scan Status](doc:scan-status-tio).
				Status *string `json:"status,omitempty"`

				// The UUID of the template.
				TemplateUuid *string `json:"template_uuid,omitempty"`

				// The type of scan.
				Type *string `json:"type,omitempty"`

				// The sharing permissions for the scan.
				UserPermissions *int32 `json:"user_permissions,omitempty"`

				// The UUID of the remediation scan.
				Uuid *string `json:"uuid,omitempty"`

				// The UUID of the Tenable-provided template used to create either the scan or the user-defined template (policy) on which the scan configuration is based.
				WizardUuid *string `json:"wizard_uuid,omitempty"`
			} `json:"scans,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoScansRemediationCreateResponse parses an HTTP response from a IoScansRemediationCreateWithResponse call
func ParseIoScansRemediationCreateResponse(rsp *http.Response) (*IoScansRemediationCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoScansRemediationCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The unique ID of your Tenable.io instance.
			ContainerId *string `json:"container_id,omitempty"`

			// For newly-created scans, the date on which the scan configuration was originally created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was originally created. Instead, it represents the date on which the scan was first launched, in Unix time format.
			CreationDate *int32 `json:"creation_date,omitempty"`

			// Targets specified in the `alt_targets` parameter of the [POST /scans/{scan_id}/launch](/reference#scans-launch) request body used to run the scan.
			CustomTargets *string `json:"custom_targets,omitempty"`

			// The name of the dashboard file associated with the scan.
			DashboardFile *string `json:"dashboard_file,omitempty"`

			// The default permissions for the scan.
			DefaultPermissions *int32 `json:"default_permissions,omitempty"`

			// A brief user-defined description of the scan.
			Description *string `json:"description,omitempty"`

			// A comma-separated list of accounts that receive the email summary report.
			Emails *string `json:"emails,omitempty"`

			// A value indicating whether the scan schedule is active (`true`) or inactive (`false`).
			Enabled *bool `json:"enabled,omitempty"`

			// The unique ID of the scan.
			Id *int32 `json:"id,omitempty"`

			// A value indicating whether the scan results appear in dashboards.
			IncludeAggregate *bool `json:"include_aggregate,omitempty"`

			// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
			LastModificationDate *int32 `json:"last_modification_date,omitempty"`

			// The user-defined scan name.
			Name *string `json:"name,omitempty"`

			// A list of filters that Tenable.io applies to determine whether it sends a notification email on scan completion to the recipients specified in the `emails` attribute.
			NotificationFilters *[]struct {
				// The attribute name. For example, use the `risk_factor` attribute if you want to filter on vulnerability severity.
				Filter *string `json:"filter,omitempty"`

				// The operator Tenable.io applies to the filter value, for example, `eq`.
				Quality *string `json:"quality,omitempty"`

				// The attribute value Tenable.io filters on. For example, when filtering on severity, this attribute might specify `Critical`.
				Value *string `json:"value,omitempty"`
			} `json:"notification_filters,omitempty"`

			// The owner of the scan.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the scan.
			OwnerId *int `json:"owner_id,omitempty"`

			// The unique ID of the scan owner.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The unique ID of the policy associated with the scan.
			PolicyId *int `json:"policy_id,omitempty"`

			// If `1`, your vulnerability remediation actions on scan targets have been successful.
			Remediation *int `json:"remediation,omitempty"`

			// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
			//
			// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
			Rrules *string `json:"rrules,omitempty"`

			// The time frame, in minutes, during which agents must transmit scan results to Tenable.io in order to be included in dashboards and reports. If your request omits this parameter, the default value is 180 minutes. For non-agent scans, this attribute is null.
			ScanTimeWindow *string `json:"scan_time_window,omitempty"`

			// The UUID of the scanner that the scan is configured to use, if the scan is *not* configured for [scan routing](doc:manage-scan-routing-tio).
			ScannerUuid *string `json:"scanner_uuid,omitempty"`

			// If `1`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
			Shared *bool `json:"shared,omitempty"`

			// A comma-separated list of mobile phone numbers that receive notification of the scan.
			Sms *string `json:"sms,omitempty"`

			// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` parameter.
			//
			// This attribute has the following format: `YYYYMMDDTHHMMSS`.
			Starttime *string `json:"starttime,omitempty"`

			// The list of asset tag identifiers the scan uses to determine which assets it evaluates. For more information about tag-based scans, see [Manage Tag-Based Scans](doc:manage-tag-based-scans-tio).
			TagTargets *[]string `json:"tag_targets,omitempty"`

			// The type of tag.
			TagType *string `json:"tag_type,omitempty"`

			// The UUID of the network object that Tenable.io associates with the scan results if the scan is configured for [scan routing](doc:manage-scan-routing-tio).
			TargetNetworkUuid *string `json:"target_network_uuid,omitempty"`

			// The timezone of the scheduled start time for the scan.
			Timezone *string `json:"timezone,omitempty"`

			// The type of scan.
			Type *string `json:"type,omitempty"`

			// The sharing permissions for the scan.
			UserPermissions *int32 `json:"user_permissions,omitempty"`

			// The UUID of the schedule for the scan.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// The HTTP status text.
			Error *int `json:"error,omitempty"`

			// A brief message describing the error Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP status code.
			StatusCode *string `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseScansTimezonesResponse parses an HTTP response from a ScansTimezonesWithResponse call
func ParseScansTimezonesResponse(rsp *http.Response) (*ScansTimezonesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansTimezonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// The readable name of the timezone.
			Name *string `json:"name,omitempty"`

			// The system value for the timezone.
			Value *string `json:"value,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansDeleteResponse parses an HTTP response from a ScansDeleteWithResponse call
func ParseScansDeleteResponse(rsp *http.Response) (*ScansDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// The HTTP status text.
			Error *int `json:"error,omitempty"`

			// A brief message describing the error Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP status code.
			StatusCode *string `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseScansDetailsResponse parses an HTTP response from a ScansDetailsWithResponse call
func ParseScansDetailsResponse(rsp *http.Response) (*ScansDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A list of the hosts targeted by the scan for the specified run. If the scan results are older than 35 days (that is, if the `info.archived` attribute for the scan is `true`), this array does not appear in the response message.
			Comphosts *[]struct {
				// The percentage of critical findings on the host.
				Critical *int `json:"critical,omitempty"`

				// The percentage of high findings on the host.
				High *int `json:"high,omitempty"`

				// The unique ID of the host.
				HostId *int `json:"host_id,omitempty"`

				// The index for the host.
				HostIndex *int `json:"host_index,omitempty"`

				// The name of the host.
				Hostname *string `json:"hostname,omitempty"`

				// The percentage of info findings on the host.
				Info *int `json:"info,omitempty"`

				// The percentage of low findings on the host.
				Low *int `json:"low,omitempty"`

				// The percentage of medium findings on the host.
				Medium *int `json:"medium,omitempty"`

				// The number of checks considered on the host.
				Numchecksconsidered *int `json:"numchecksconsidered,omitempty"`

				// The scan progress of the host.
				Progress *string `json:"progress,omitempty"`

				// The current scan progress for the host.
				Scanprogresscurrent *int `json:"scanprogresscurrent,omitempty"`

				// The total scan progress for the host.
				Scanprogresstotal *int `json:"scanprogresstotal,omitempty"`

				// The overall score for the host.
				Score         *int                    `json:"score,omitempty"`
				Severitycount *map[string]interface{} `json:"severitycount,omitempty"`

				// The total number of checks considered on the host.
				Totalchecksconsidered *int `json:"totalchecksconsidered,omitempty"`
			} `json:"comphosts,omitempty"`

			// A list of compliance checks performed during the run of the scan. If the scan results are older than 35 days (that is, if the `info.archived` attribute for the scan is `true`), this array does not appear in the response message.
			Compliance *[]struct {
				// The number of vulnerabilities found.
				Count *int `json:"count,omitempty"`

				// The parent family of the vulnerability plugin.
				PluginFamily *string `json:"plugin_family,omitempty"`

				// The unique ID of the vulnerability plugin.
				PluginId *int `json:"plugin_id,omitempty"`

				// The name of the vulnerability plugin.
				PluginName *string `json:"plugin_name,omitempty"`

				// The severity rating of the plugin.
				Severity *int `json:"severity,omitempty"`

				// The severity index order of the plugin.
				SeverityIndex *int `json:"severity_index,omitempty"`

				// The index of the vulnerability plugin.
				VulnIndex *int `json:"vuln_index,omitempty"`
			} `json:"compliance,omitempty"`

			// A list of filters. If the scan results are older than 35 days (that is, if the `info.archived` attribute for the scan is `true`), this array does not appear in the response message.
			Filters *[]struct {
				Control *struct {
					// A list of options if the input is a dropdown.
					Options *[]string `json:"options,omitempty"`

					// The placeholder for the input.
					ReadableRegest *string `json:"readable_regest,omitempty"`

					// A regex for checking the value of the input.
					Regex *string `json:"regex,omitempty"`

					// The input type (entry or dropdown).
					Type *string `json:"type,omitempty"`
				} `json:"control,omitempty"`

				// The short name of the filter.
				Name *string `json:"name,omitempty"`

				// The comparison options for the filter.
				Operators *[]string `json:"operators,omitempty"`

				// The long name of the filter.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filters,omitempty"`

			// A list of details about each time the scan has run.
			History *[]struct {
				// If `true`, Tenable.io did not not launched with a target list. This parameter is `true` for agent scans.
				AltTargetsUsed *bool `json:"alt_targets_used,omitempty"`

				// The creation date for the historical data in Unix time.
				CreationDate *int `json:"creation_date,omitempty"`

				// The unique ID of the historical data.
				HistoryId *int `json:"history_id,omitempty"`

				// Indicates whether the scan results are older than 35 days (`true`). If this parameter is `true`, Tenable.io returns limited data for the scan run. For complete scan results that are older than 35 days, use the [POST /scans/{scan_id}/export](ref:scans-export-request) endpoint instead.
				IsArchived *bool `json:"is_archived,omitempty"`

				// The last modification date for the historical data in Unix time.
				LastModificationDate *int `json:"last_modification_date,omitempty"`

				// The unique ID of the owner of the scan.
				OwnerId *int `json:"owner_id,omitempty"`

				// If `true`, Tenable.io launched the scan automatically from a schedule.
				Scheduler *int `json:"scheduler,omitempty"`

				// The terminal status of the scan run. For a list of possible values, see [Scan Status](doc:scan-status-tio).
				Status *string `json:"status,omitempty"`

				// The type of scan: `local` (a credentialed scan performed over the network), `remote` (an uncredentialed scan performed over the network, `agent` (a scan on a local host that a Nessus agent performs directly), or `null` (the scan has never been launched, or the scan is imported).
				Type *string `json:"type,omitempty"`

				// The UUID of the historical data.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"history,omitempty"`

			// A list of the hosts targeted by the scan for the specified run. If the scan results are older than 35 days (that is, if the `info.archived` attribute for the scan is `true`), this array does not appear in the response message.
			Hosts *[]struct {
				// The percentage of critical findings on the host.
				Critical *int `json:"critical,omitempty"`

				// The percentage of high findings on the host.
				High *int `json:"high,omitempty"`

				// The unique ID of the host.
				HostId *int `json:"host_id,omitempty"`

				// The index for the host.
				HostIndex *int `json:"host_index,omitempty"`

				// The name of the host.
				Hostname *string `json:"hostname,omitempty"`

				// The percentage of info findings on the host.
				Info *int `json:"info,omitempty"`

				// The percentage of low findings on the host.
				Low *int `json:"low,omitempty"`

				// The percentage of medium findings on the host.
				Medium *int `json:"medium,omitempty"`

				// The number of checks considered on the host.
				Numchecksconsidered *int `json:"numchecksconsidered,omitempty"`

				// The scan progress of the host.
				Progress *string `json:"progress,omitempty"`

				// The current scan progress for the host.
				Scanprogresscurrent *int `json:"scanprogresscurrent,omitempty"`

				// The total scan progress for the host.
				Scanprogresstotal *int `json:"scanprogresstotal,omitempty"`

				// The overall score for the host.
				Score         *int                    `json:"score,omitempty"`
				Severitycount *map[string]interface{} `json:"severitycount,omitempty"`

				// The total number of checks considered on the host.
				Totalchecksconsidered *int `json:"totalchecksconsidered,omitempty"`
			} `json:"hosts,omitempty"`
			Info *struct {
				// An array of objects that control sharing permissions for the scan.
				Acls *[]struct {
					// The name of the user or group granted the specified permissions, as it appears in the Tenable.io user interface.
					DisplayName *string `json:"display_name,omitempty"`

					// A number representing the order in which the user or user groups display in the Permissions tab in the Tenable.io user interface.
					Id *int `json:"id,omitempty"`

					// The name of the user or group granted the specified permissions.
					Name *string `json:"name,omitempty"`

					// A value that indicates whether the user or user group specified in the object owns the scan. Possible values include: `null` (system-owned permissions), `0` (the user is not the owner of the scan), `1` (the user is the owner of the scan).
					Owner *int `json:"owner,omitempty"`

					// The scan permission. For more information, see [Permissions](doc:permissions).
					Permissions *int `json:"permissions,omitempty"`

					// The type of scan permissions: `default` (default permissions for the scan), `user` (permissions for an individual user), or `group` (permissions for a user group).
					Type *string `json:"type,omitempty"`
				} `json:"acls,omitempty"`

				// If `true`, Tenable.io did not not launched with a target list. This parameter is `true` for agent scans.
				AltTargetsUsed *bool `json:"alt_targets_used,omitempty"`

				// If `true`, the scan has a schedule and can be launched.
				Control *bool `json:"control,omitempty"`

				// If `true`, the requesting user can edit this scan configuration.
				EditAllowed *bool `json:"edit_allowed,omitempty"`

				// The unique ID of the destination folder for the scan.
				FolderId *int32 `json:"folder_id,omitempty"`

				// Indicates whether the scan is configured to create an audit trail.
				Hasaudittrail *bool `json:"hasaudittrail,omitempty"`

				// Indicates whether a scan has a Knowledge Base (KB) associated with it. A KB is an ASCII text file containing a log of information relevant to the scan performed and results found.
				Haskb *bool `json:"haskb,omitempty"`

				// The total number of assets scanned for vulnerabilities.
				Hostcount *int32 `json:"hostcount,omitempty"`

				// Indicates whether the scan results are older than 35 days (`true`). If this attribute is `true`, the response message for this endpoint excludes the `hosts`, `vulnerabilities`, `comphosts`, `compliance`, and `filters` objects. For complete scan results older than 35 days, use the [POST /scans/{scan_id}/export](ref:scans-export-request) endpoint instead.
				IsArchived *bool `json:"is_archived,omitempty"`

				// The name of the scan.
				Name *string `json:"name,omitempty"`

				// Indicates whether the scan based on this policy can specify targets.
				NoTarget *bool `json:"no_target,omitempty"`

				// The unique ID of the scan result object.
				ObjectId *int32 `json:"object_id,omitempty"`

				// The owner of the scan.
				Owner *string `json:"owner,omitempty"`

				// If `true`, you can submit the results of the scan for PCI ASV review. For more information, see [PCI ASV](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/PCI_ASV/Welcome.htm) in the Tenable.io Vulnerability Management User Guide.
				PciCanUpload *bool `json:"pci-can-upload,omitempty"`

				// The name of the scan template associated with the scan.
				Policy *string `json:"policy,omitempty"`

				// The Unix timestamp when the scan run finished.
				ScanEnd *int `json:"scan_end,omitempty"`

				// The Unix timestamp when the scan run started.
				ScanStart *int32 `json:"scan_start,omitempty"`

				// The type of scan: `ps` (a scan performed over the network by a cloud scanner), `remote` (a  scan performed over the network by a local scanner), `agent` (a scan on a local host that a Nessus agent performs directly), or `null` (the scan has never been launched, or the scan is imported).
				ScanType *string `json:"scan_type,omitempty"`

				// The scan's end time, if the scan is imported.
				ScannerEnd *int `json:"scanner_end,omitempty"`

				// The name of the scanner configured to run the scan.
				ScannerName *string `json:"scanner_name,omitempty"`

				// The scan's start time, if the scan is imported.
				ScannerStart *int `json:"scanner_start,omitempty"`

				// The UUID for a specific instance in the scan schedule.
				ScheduleUuid *string `json:"schedule_uuid,omitempty"`

				// If `true`, the scan is shared with users other than the owner. The level of sharing is specified in the `acls` attribute of the scan details.
				Shared *bool `json:"shared,omitempty"`

				// The status of the scan. For a list of possible values, see [Scan Status](doc:scan-status-tio).
				Status *string `json:"status,omitempty"`

				// The list of asset tag identifiers the scan uses to determine which assets it evaluates. For more information about tag-based scans, see [Manage Tag-Based Scans](doc:manage-tag-based-scans-tio).
				TagTargets *[]string `json:"tag_targets,omitempty"`

				// A comma-delimited list of IPv4 addresses that are configured as targets for the scan.
				Targets *string `json:"targets,omitempty"`

				// The Unix timestamp when the scan run finished.
				Timestamp *int `json:"timestamp,omitempty"`

				// The sharing permissions for the scan.
				UserPermissions *int32 `json:"user_permissions,omitempty"`

				// The UUID of the scan.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"info,omitempty"`
			Notes *[]struct {
				// The specific message of the note.
				Message *string `json:"message,omitempty"`

				// The severity of the note.
				Severity *int `json:"severity,omitempty"`

				// The title of the note.
				Title *string `json:"title,omitempty"`
			} `json:"notes,omitempty"`
			Remediations *map[string]interface{} `json:"remediations,omitempty"`

			// A list of vulnerabilities that the scan identified on the target hosts. If the scan results are older than 35 days (that is, if the `info.archived` attribute for the scan is `true`), this array does not appear in the response message.
			Vulnerabilities *[]struct {
				// The number of vulnerabilities found.
				Count *int `json:"count,omitempty"`

				// The parent family of the vulnerability plugin.
				PluginFamily *string `json:"plugin_family,omitempty"`

				// The unique ID of the vulnerability plugin.
				PluginId *int `json:"plugin_id,omitempty"`

				// The name of the vulnerability plugin.
				PluginName *string `json:"plugin_name,omitempty"`

				// The severity rating of the plugin.
				Severity *int `json:"severity,omitempty"`

				// The severity index order of the plugin.
				SeverityIndex *int `json:"severity_index,omitempty"`

				// The index of the vulnerability plugin.
				VulnIndex *int `json:"vuln_index,omitempty"`
			} `json:"vulnerabilities,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// A brief description of the cause of the error.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseScansConfigureResponse parses an HTTP response from a ScansConfigureWithResponse call
func ParseScansConfigureResponse(rsp *http.Response) (*ScansConfigureResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansConfigureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The unique ID of your Tenable.io instance.
			ContainerId *string `json:"container_id,omitempty"`

			// For newly-created scans, the date on which the scan configuration was originally created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was originally created. Instead, it represents the date on which the scan was first launched, in Unix time format.
			CreationDate *int32 `json:"creation_date,omitempty"`

			// Targets specified in the `alt_targets` parameter of the [POST /scans/{scan_id}/launch](/reference#scans-launch) request body used to run the scan.
			CustomTargets *string `json:"custom_targets,omitempty"`

			// The name of the dashboard file associated with the scan.
			DashboardFile *string `json:"dashboard_file,omitempty"`

			// The default permissions for the scan.
			DefaultPermissions *int32 `json:"default_permissions,omitempty"`

			// A brief user-defined description of the scan.
			Description *string `json:"description,omitempty"`

			// A comma-separated list of accounts that receive the email summary report.
			Emails *string `json:"emails,omitempty"`

			// A value indicating whether the scan schedule is active (`true`) or inactive (`false`).
			Enabled *bool `json:"enabled,omitempty"`

			// The unique ID of the scan.
			Id *int32 `json:"id,omitempty"`

			// A value indicating whether the scan results appear in dashboards.
			IncludeAggregate *bool `json:"include_aggregate,omitempty"`

			// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
			LastModificationDate *int32 `json:"last_modification_date,omitempty"`

			// The user-defined scan name.
			Name *string `json:"name,omitempty"`

			// A list of filters that Tenable.io applies to determine whether it sends a notification email on scan completion to the recipients specified in the `emails` attribute.
			NotificationFilters *[]struct {
				// The attribute name. For example, use the `risk_factor` attribute if you want to filter on vulnerability severity.
				Filter *string `json:"filter,omitempty"`

				// The operator Tenable.io applies to the filter value, for example, `eq`.
				Quality *string `json:"quality,omitempty"`

				// The attribute value Tenable.io filters on. For example, when filtering on severity, this attribute might specify `Critical`.
				Value *string `json:"value,omitempty"`
			} `json:"notification_filters,omitempty"`

			// The owner of the scan.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the scan.
			OwnerId *int `json:"owner_id,omitempty"`

			// The unique ID of the scan owner.
			OwnerUuid *string `json:"owner_uuid,omitempty"`

			// The unique ID of the policy associated with the scan.
			PolicyId *int `json:"policy_id,omitempty"`

			// If `1`, your vulnerability remediation actions on scan targets have been successful.
			Remediation *int `json:"remediation,omitempty"`

			// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
			//
			// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
			Rrules *string `json:"rrules,omitempty"`

			// The time frame, in minutes, during which agents must transmit scan results to Tenable.io in order to be included in dashboards and reports. If your request omits this parameter, the default value is 180 minutes. For non-agent scans, this attribute is null.
			ScanTimeWindow *string `json:"scan_time_window,omitempty"`

			// The UUID of the scanner that the scan is configured to use, if the scan is *not* configured for [scan routing](doc:manage-scan-routing-tio).
			ScannerUuid *string `json:"scanner_uuid,omitempty"`

			// If `1`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
			Shared *bool `json:"shared,omitempty"`

			// A comma-separated list of mobile phone numbers that receive notification of the scan.
			Sms *string `json:"sms,omitempty"`

			// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` parameter.
			//
			// This attribute has the following format: `YYYYMMDDTHHMMSS`.
			Starttime *string `json:"starttime,omitempty"`

			// The list of asset tag identifiers the scan uses to determine which assets it evaluates. For more information about tag-based scans, see [Manage Tag-Based Scans](doc:manage-tag-based-scans-tio).
			TagTargets *[]string `json:"tag_targets,omitempty"`

			// The type of tag.
			TagType *string `json:"tag_type,omitempty"`

			// The UUID of the network object that Tenable.io associates with the scan results if the scan is configured for [scan routing](doc:manage-scan-routing-tio).
			TargetNetworkUuid *string `json:"target_network_uuid,omitempty"`

			// The timezone of the scheduled start time for the scan.
			Timezone *string `json:"timezone,omitempty"`

			// The type of scan.
			Type *string `json:"type,omitempty"`

			// The sharing permissions for the scan.
			UserPermissions *int32 `json:"user_permissions,omitempty"`

			// The UUID of the schedule for the scan.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// The HTTP status text.
			Error *int `json:"error,omitempty"`

			// A brief message describing the error Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP status code.
			StatusCode *string `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseScansAttachmentsResponse parses an HTTP response from a ScansAttachmentsWithResponse call
func ParseScansAttachmentsResponse(rsp *http.Response) (*ScansAttachmentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseScansCopyResponse parses an HTTP response from a ScansCopyWithResponse call
func ParseScansCopyResponse(rsp *http.Response) (*ScansCopyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansCopyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// If `true`, the scan has a schedule and can be launched.
			Control *bool `json:"control,omitempty"`

			// The creation date for the scan in Unix time.
			CreationDate *int `json:"creation_date,omitempty"`

			// If `true`, the schedule for the scan is enabled.
			Enabled *bool `json:"enabled,omitempty"`

			// The unique ID of the scan.
			Id *int `json:"id,omitempty"`

			// For newly-created scans, the date on which the scan configuration was created. For scans that have been launched at least once, this attribute does not represent the date on which the scan configuration was last modified. Instead, it represents the date on which the scan was last launched, in Unix time format. Tenable.io updates this attribute each time the scan launches.
			LastModificationDate *int32 `json:"last_modification_date,omitempty"`

			// The name of the scan.
			Name *string `json:"name,omitempty"`

			// The owner of the scan.
			Owner *string `json:"owner,omitempty"`

			// If `true`, the scan has been read.
			Read *bool `json:"read,omitempty"`

			// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
			//
			// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
			Rrules *string `json:"rrules,omitempty"`

			// The UUID for a specific instance in the scan schedule.
			ScheduleUuid *string `json:"schedule_uuid,omitempty"`

			// If `1`, the scan is shared with users other than the scan owner. The level of sharing is specified in the `acls` attribute of the scan details.
			Shared *bool `json:"shared,omitempty"`

			// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` attribute.
			//
			// This attribute has the following format: `YYYYMMDDTHHMMSS`.
			Starttime *string `json:"starttime,omitempty"`

			// The status of the scan. For a list of possible values, see [Scan Status](doc:scan-status-tio).
			Status *string `json:"status,omitempty"`

			// The timezone of the scheduled start time for the scan.
			Timezone *string `json:"timezone,omitempty"`

			// The type of scan (local, remote, or agent).
			Type *string `json:"type,omitempty"`

			// The sharing permissions for the scan.
			UserPermissions *int `json:"user_permissions,omitempty"`

			// The UUID of the scan.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// The HTTP status text.
			Error *int `json:"error,omitempty"`

			// A brief message describing the error Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP status code.
			StatusCode *string `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseIoScansCredentialsConvertResponse parses an HTTP response from a IoScansCredentialsConvertWithResponse call
func ParseIoScansCredentialsConvertResponse(rsp *http.Response) (*IoScansCredentialsConvertResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoScansCredentialsConvertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The UUID of the new managed credentials.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// The HTTP status text.
			Error *int `json:"error,omitempty"`

			// A brief message describing the error Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP status code.
			StatusCode *string `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// A message describing the error condition Tenable.io encountered.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// The HTTP status text.
			Error *int `json:"error,omitempty"`

			// A brief message describing the error Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP status code.
			StatusCode *string `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			// The HTTP status text.
			Error *int `json:"error,omitempty"`

			// A brief message describing the error Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP status code.
			StatusCode *string `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseScansExportRequestResponse parses an HTTP response from a ScansExportRequestWithResponse call
func ParseScansExportRequestResponse(rsp *http.Response) (*ScansExportRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansExportRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			File      *string `json:"file,omitempty"`
			TempToken *string `json:"temp_token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansExportDownloadResponse parses an HTTP response from a ScansExportDownloadWithResponse call
func ParseScansExportDownloadResponse(rsp *http.Response) (*ScansExportDownloadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansExportDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseScansExportStatusResponse parses an HTTP response from a ScansExportStatusWithResponse call
func ParseScansExportStatusResponse(rsp *http.Response) (*ScansExportStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansExportStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The export status.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansHistoryResponse parses an HTTP response from a ScansHistoryWithResponse call
func ParseScansHistoryResponse(rsp *http.Response) (*ScansHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			History *[]struct {
				// The unique identifier for the specific scan run.
				Id *int `json:"id,omitempty"`

				// Indicates whether the scan results are older than 35 days (`true`). If this parameter is `true`, Tenable.io returns limited data for the scan run. For complete scan results that are older than 35 days, use the [POST /scans/{scan_id}/export](ref:scans-export-request) endpoint instead.
				IsArchived *bool `json:"is_archived,omitempty"`

				// The UUID for the specific scan run.
				ScanUuid *string `json:"scan_uuid,omitempty"`

				// The status of the scan. For a list of possible values, see [Scan Status](doc:scan-status-tio).
				Status *string `json:"status,omitempty"`

				// The target parameters used to launch the scan.
				Targets *struct {
					// If `true`, custom parameters were used to launch the scan.
					Custom *bool `json:"custom,omitempty"`

					// If `true`, default parameters were used to launch the scan..
					Default *bool `json:"default,omitempty"`
				} `json:"targets,omitempty"`

				// The Unix timestamp when the scan finished running.
				TimeEnd *int `json:"time_end,omitempty"`

				// The Unix timestamp when the scan started running.
				TimeStart *int `json:"time_start,omitempty"`

				// The visibility of the scan results in workbenches (`public` or `private`).
				Visibility *string `json:"visibility,omitempty"`
			} `json:"history,omitempty"`
			Pagination *struct {
				// The number of records requested (or the default value if omitted from the request).
				Limit *int32 `json:"limit,omitempty"`

				// The starting record you requested (or zero if omitted).
				Offset *int32 `json:"offset,omitempty"`

				// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
				Sort *[]struct {
					// The field on which Tenable.io sorted the results.
					Name *string `json:"name,omitempty"`

					// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
					Order *string `json:"order,omitempty"`
				} `json:"sort,omitempty"`

				// The total number of records matching your search criteria.
				Total *int32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansDeleteHistoryResponse parses an HTTP response from a ScansDeleteHistoryWithResponse call
func ParseScansDeleteHistoryResponse(rsp *http.Response) (*ScansDeleteHistoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansDeleteHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// The HTTP status text.
			Error *int `json:"error,omitempty"`

			// A brief message describing the error Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP status code.
			StatusCode *string `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseScansHistoryDetailsResponse parses an HTTP response from a ScansHistoryDetailsWithResponse call
func ParseScansHistoryDetailsResponse(rsp *http.Response) (*ScansHistoryDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansHistoryDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Indicates whether the scan results are older than 35 days (`true`). If this parameter is `true`, Tenable.io returns limited data for the scan run. For complete scan results that are older than 35 days, use the [POST /scans/{scan_id}/export](ref:scans-export-request) endpoint instead.
			IsArchived *bool `json:"is_archived,omitempty"`

			// The name of the scan.
			Name *string `json:"name,omitempty"`

			// The unique ID of the scan result object.
			ObjectId *int32 `json:"object_id,omitempty"`

			// The username of the owner of the scan when the scan run occurred.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the scan.
			OwnerId *int `json:"owner_id,omitempty"`

			// The UUID of the owner of the scan when the scan run occurred.
			OwnerUuid *int `json:"owner_uuid,omitempty"`

			// The Unix timestamp when the scan run finished.
			ScanEnd *int `json:"scan_end,omitempty"`

			// The Unix timestamp when the scan run started.
			ScanStart *int32 `json:"scan_start,omitempty"`

			// The type of scan: `ps` (a scan performed over the network by a cloud scanner), `remote` (a  scan performed over the network by a local scanner), `agent` (a scan on a local host that a Nessus agent performs directly), or `null` (the scan has never been launched, or the scan is imported).
			ScanType *string `json:"scan_type,omitempty"`

			// The UUID for a specific instance in the scan schedule.
			ScheduleUuid *string `json:"schedule_uuid,omitempty"`

			// The terminal status of the scan run. For possible values, see [Scan Status](doc:scan-status-tio).
			Status *string `json:"status,omitempty"`

			// The hosts that the scan targeted.
			Targets *string `json:"targets,omitempty"`

			// The UUID of the historical data.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansGetLatestStatusResponse parses an HTTP response from a ScansGetLatestStatusWithResponse call
func ParseScansGetLatestStatusResponse(rsp *http.Response) (*ScansGetLatestStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansGetLatestStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The latest status of the scan. For a list of possible status values, see [Scan Status](doc:scan-status-tio).
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// A brief description of the cause of the error.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// The HTTP status text.
			Error *int `json:"error,omitempty"`

			// A brief message describing the error Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP status code.
			StatusCode *string `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseScansLaunchResponse parses an HTTP response from a ScansLaunchWithResponse call
func ParseScansLaunchResponse(rsp *http.Response) (*ScansLaunchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansLaunchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The UUID of the scan launched.
			ScanUuid *string `json:"scan_uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// A brief description of the cause of the error.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseScansPauseResponse parses an HTTP response from a ScansPauseWithResponse call
func ParseScansPauseResponse(rsp *http.Response) (*ScansPauseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansPauseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansResumeResponse parses an HTTP response from a ScansResumeWithResponse call
func ParseScansResumeResponse(rsp *http.Response) (*ScansResumeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansResumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansScheduleResponse parses an HTTP response from a ScansScheduleWithResponse call
func ParseScansScheduleResponse(rsp *http.Response) (*ScansScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// If `true`, the scan has a schedule and can be launched.
			Control *bool `json:"control,omitempty"`

			// If `true`, the schedule for the scan is enabled.
			Enabled *bool `json:"enabled,omitempty"`

			// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
			//
			// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
			Rrules *string `json:"rrules,omitempty"`

			// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` parameter.
			//
			// This attribute has the following format: `YYYYMMDDTHHMMSS`.
			Starttime *string `json:"starttime,omitempty"`

			// The timezone of the scheduled start time for the scan.
			Timezone *string `json:"timezone,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// A brief description of the cause of the error.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// The HTTP status text.
			Error *int `json:"error,omitempty"`

			// A brief message describing the error Tenable.io encountered.
			Message *string `json:"message,omitempty"`

			// The HTTP status code.
			StatusCode *string `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseScansReadStatusResponse parses an HTTP response from a ScansReadStatusWithResponse call
func ParseScansReadStatusResponse(rsp *http.Response) (*ScansReadStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansReadStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansStopResponse parses an HTTP response from a ScansStopWithResponse call
func ParseScansStopResponse(rsp *http.Response) (*ScansStopResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansStopResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansHostDetailsResponse parses an HTTP response from a ScansHostDetailsWithResponse call
func ParseScansHostDetailsResponse(rsp *http.Response) (*ScansHostDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansHostDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Compliance *[]struct {
				// The number of vulnerabilities found.
				Count *int `json:"count,omitempty"`

				// The unique ID of the host.
				HostId *int `json:"host_id,omitempty"`

				// The name of the host.
				Hostname *string `json:"hostname,omitempty"`

				// The parent family of the vulnerability plugin.
				PluginFamily *string `json:"plugin_family,omitempty"`

				// The unique ID of the vulnerability plugin.
				PluginId *int `json:"plugin_id,omitempty"`

				// The name of the vulnerability plugin.
				PluginName *string `json:"plugin_name,omitempty"`

				// The severity of plugin.
				Severity *int `json:"severity,omitempty"`

				// The severity index order of the plugin.
				SeverityIndex *int `json:"severity_index,omitempty"`
			} `json:"compliance,omitempty"`
			Info            *map[string]interface{} `json:"info,omitempty"`
			Vulnerabilities *[]struct {
				// The number of vulnerabilities found.
				Count *int `json:"count,omitempty"`

				// The unique ID of the host.
				HostId *int `json:"host_id,omitempty"`

				// The name of the host.
				Hostname *string `json:"hostname,omitempty"`

				// The parent family of the vulnerability plugin.
				PluginFamily *string `json:"plugin_family,omitempty"`

				// The unique ID of the vulnerability plugin.
				PluginId *int `json:"plugin_id,omitempty"`

				// The name of the vulnerability plugin.
				PluginName *string `json:"plugin_name,omitempty"`

				// The severity of plugin.
				Severity *int `json:"severity,omitempty"`

				// The severity index order of the plugin.
				SeverityIndex *int `json:"severity_index,omitempty"`

				// The index of the vulnerability plugin.
				VulnIndex *int `json:"vuln_index,omitempty"`
			} `json:"vulnerabilities,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScansPluginOutputResponse parses an HTTP response from a ScansPluginOutputWithResponse call
func ParseScansPluginOutputResponse(rsp *http.Response) (*ScansPluginOutputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScansPluginOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Info *struct {
				// The host's fully qualified domain name; optional.
				HostFqdn *string `json:"host-fqdn,omitempty"`

				// The host's IPv4 address; optional.
				HostIp *string `json:"host-ip,omitempty"`

				// The host's UUID generated by Tenable.io for identification purposes; always present.
				HostUuid *string `json:"host-uuid,omitempty"`

				// The last time a scan was completed for this host as an ISO 8601 timestamp; always present.
				HostEnd *string `json:"host_end,omitempty"`

				// The FQDN of the host. Normally, this is populated with the value used to scan the host in the target list of the last scan that was ran where it was seen; always present.
				HostFqdn2 *string `json:"host_fqdn,omitempty"`

				// The last time a scan was started for this host as an ISO 8601 timestamp; always present.
				HostStart *string `json:"host_start,omitempty"`

				// The host's mac addresses in a newline-separated list; optional.
				MacAddress *string `json:"mac-address,omitempty"`
			} `json:"info,omitempty"`
			Output *[]struct {
				// A custom description of the plugin.
				CustomDescription *string `json:"custom_description,omitempty"`

				// If the value is 1, the plugin output contains files that may be exported.
				HasAttachment *int `json:"has_attachment,omitempty"`

				// Other hosts with the same output.
				Hosts *string `json:"hosts,omitempty"`

				// The text of the plugin output.
				PluginOutput *string                 `json:"plugin_output,omitempty"`
				Ports        *map[string]interface{} `json:"ports,omitempty"`

				// The severity the output.
				Severity *int `json:"severity,omitempty"`
			} `json:"output,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseServerPropertiesResponse parses an HTTP response from a ServerPropertiesWithResponse call
func ParseServerPropertiesResponse(rsp *http.Response) (*ServerPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServerPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Analytics          *map[string]interface{} `json:"analytics,omitempty"`
			Capabilities       *map[string]interface{} `json:"capabilities,omitempty"`
			ContainerDbVersion *string                 `json:"container_db_version,omitempty"`
			Enterprise         *bool                   `json:"enterprise,omitempty"`
			Expiration         *int                    `json:"expiration,omitempty"`
			ExpirationTime     *int                    `json:"expiration_time,omitempty"`
			ForceUiReload      *bool                   `json:"force_ui_reload,omitempty"`
			IdleTimeout        *int                    `json:"idle_timeout,omitempty"`
			License            *map[string]interface{} `json:"license,omitempty"`
			LimitEnabled       *bool                   `json:"limitEnabled,omitempty"`
			LoadedPluginSet    *string                 `json:"loaded_plugin_set,omitempty"`
			LoginBanner        *bool                   `json:"login_banner,omitempty"`
			Msp                *bool                   `json:"msp,omitempty"`
			NessusType         *string                 `json:"nessus_type,omitempty"`
			NessusUiBuild      *string                 `json:"nessus_ui_build,omitempty"`
			NessusUiVersion    *string                 `json:"nessus_ui_version,omitempty"`
			Notifications      *[]string               `json:"notifications,omitempty"`
			PluginSet          *string                 `json:"plugin_set,omitempty"`
			ScannerBoottime    *int                    `json:"scanner_boottime,omitempty"`
			ServerBuild        *string                 `json:"server_build,omitempty"`
			ServerUuid         *string                 `json:"server_uuid,omitempty"`
			ServerVersion      *string                 `json:"server_version,omitempty"`
			Update             *struct {
				Href       *string `json:"href,omitempty"`
				NewVersion *int    `json:"new_version,omitempty"`
				Restart    *int    `json:"restart,omitempty"`
			} `json:"update,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseServerStatusResponse parses an HTTP response from a ServerStatusWithResponse call
func ParseServerStatusResponse(rsp *http.Response) (*ServerStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServerStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Code   *int    `json:"code,omitempty"`
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTagsAssignAssetTagsResponse parses an HTTP response from a TagsAssignAssetTagsWithResponse call
func ParseTagsAssignAssetTagsResponse(rsp *http.Response) (*TagsAssignAssetTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsAssignAssetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// The UUID of the asynchronous asset update job.
			JobUuid *string `json:"job_uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseTagsListAssetFiltersResponse parses an HTTP response from a TagsListAssetFiltersWithResponse call
func ParseTagsListAssetFiltersResponse(rsp *http.Response) (*TagsListAssetFiltersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsListAssetFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Control *struct {
				// Provides a human-readable "hint" to guide users creating tag rules in the Tenable.io user interface.
				ReadableRegex *string `json:"readable_regex,omitempty"`

				// A regular expression that Tenable.io UI uses to validate input.
				Regex *string `json:"regex,omitempty"`

				// The type of UI control that represents the filter in the Tenable.io user interface.
				Type *string `json:"type,omitempty"`
			} `json:"control,omitempty"`

			// The name of the asset attribute or tag.
			Name *string `json:"name,omitempty"`

			// The comparison operators that can be used for the filter. To find supported operators, use the [GET /tags/assets/filters](ref:tags-list-asset-filters) endpoint.
			Operators *[]string `json:"operators,omitempty"`

			// The asset attribute name displayed in the Tenable.io user interface.
			ReadableName *string `json:"readable_name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTagsListAssetTagsResponse parses an HTTP response from a TagsListAssetTagsWithResponse call
func ParseTagsListAssetTagsResponse(rsp *http.Response) (*TagsListAssetTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsListAssetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// An array of asset assignment objects.
			Tags *[]struct {
				// The UUID of the asset where the tag is assigned.
				AssetUuid *string `json:"asset_uuid,omitempty"`

				// The tag category name (the first half of the category:value pair).
				CategoryName *string `json:"category_name,omitempty"`

				// The UUID of the tag category. Use this value to create future tags in the same category.
				CategoryUuid *string `json:"category_uuid,omitempty"`

				// An ISO timestamp indicating the date and time on which the was assigned to an asset, for example, `2018-12-31T13:51:17.243Z`.
				CreatedAt *string `json:"created_at,omitempty"`

				// The name of the user who assigned the tag to the asset.
				CreatedBy *string `json:"created_by,omitempty"`

				// The tag type:
				//  - staticA user must manually apply the tag to assets.
				//  - dynamicTenable.io automatically applies the tag based on asset attribute rules.
				Source *string `json:"source,omitempty"`

				// The tag value (the second half of the category:value pair).
				Value *string `json:"value,omitempty"`

				// The UUID of the tag value.
				//
				// **Note:** A tag UUID is technically assigned to the tag value only (the second half of the category:value pair), but the API commands use this value to represent the whole `category:value` pair.
				ValueUuid *string `json:"value_uuid,omitempty"`
			} `json:"tags,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTagsListTagCategoriesResponse parses an HTTP response from a TagsListTagCategoriesWithResponse call
func ParseTagsListTagCategoriesResponse(rsp *http.Response) (*TagsListTagCategoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsListTagCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A collection of category objects.
			Categories *[]struct {
				// An ISO timestamp indicating the date and time on which the category was created, for example, `2018-12-31T13:51:17.243Z`.
				CreatedAt *string `json:"created_at,omitempty"`

				// The name of the user who created the category.
				CreatedBy *string `json:"created_by,omitempty"`

				// The description of the category.
				Description *string `json:"description,omitempty"`

				// The name of the category. The name must be unique within a Tenable.io instance.
				Name *string `json:"name,omitempty"`

				// Indicates whether the tags in this category are reserved (cannot be updated). This is a read-only field set by the system.
				Reserved *bool `json:"reserved,omitempty"`

				// An ISO timestamp indicating the date and time on which the category was last updated, for example, `2018-12-31T13:51:17.243Z`.
				UpdatedAt *string `json:"updated_at,omitempty"`

				// The name of the user who last updated the category.
				UpdatedBy *string `json:"updated_by,omitempty"`

				// The UUID of the category.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"categories,omitempty"`
			Pagination *struct {
				// The number of records requested (or the default value if omitted from the request).
				Limit *int32 `json:"limit,omitempty"`

				// The starting record you requested (or zero if omitted).
				Offset *int32 `json:"offset,omitempty"`

				// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
				Sort *[]struct {
					// The field on which Tenable.io sorted the results.
					Name *string `json:"name,omitempty"`

					// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
					Order *string `json:"order,omitempty"`
				} `json:"sort,omitempty"`

				// The total number of records matching your search criteria.
				Total *int32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTagsCreateTagCategoryResponse parses an HTTP response from a TagsCreateTagCategoryWithResponse call
func ParseTagsCreateTagCategoryResponse(rsp *http.Response) (*TagsCreateTagCategoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsCreateTagCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// An ISO timestamp indicating the date and time on which the category was created, for example, `2018-12-31T13:51:17.243Z`.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the category.
			CreatedBy *string `json:"created_by,omitempty"`

			// The description of the category.
			Description *string `json:"description,omitempty"`

			// The name of the category. The name must be unique within a Tenable.io instance.
			Name *string `json:"name,omitempty"`

			// Indicates whether the tags in this category are reserved (cannot be updated). This is a read-only field set by the system.
			Reserved *bool `json:"reserved,omitempty"`

			// An ISO timestamp indicating the date and time on which the category was last updated, for example, `2018-12-31T13:51:17.243Z`.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last updated the category.
			UpdatedBy *string `json:"updated_by,omitempty"`

			// The UUID of the category.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTagsDeleteTagCategoryResponse parses an HTTP response from a TagsDeleteTagCategoryWithResponse call
func ParseTagsDeleteTagCategoryResponse(rsp *http.Response) (*TagsDeleteTagCategoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsDeleteTagCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	}

	return response, nil
}

// ParseTagsTagCategoryDetailsResponse parses an HTTP response from a TagsTagCategoryDetailsWithResponse call
func ParseTagsTagCategoryDetailsResponse(rsp *http.Response) (*TagsTagCategoryDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsTagCategoryDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// An ISO timestamp indicating the date and time on which the category was created, for example, `2018-12-31T13:51:17.243Z`.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the category.
			CreatedBy *string `json:"created_by,omitempty"`

			// The description of the category.
			Description *string `json:"description,omitempty"`

			// The name of the category. The name must be unique within a Tenable.io instance.
			Name *string `json:"name,omitempty"`

			// Indicates whether the tags in this category are reserved (cannot be updated). This is a read-only field set by the system.
			Reserved *bool `json:"reserved,omitempty"`

			// An ISO timestamp indicating the date and time on which the category was last updated, for example, `2018-12-31T13:51:17.243Z`.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last updated the category.
			UpdatedBy *string `json:"updated_by,omitempty"`

			// The UUID of the category.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTagsEditTagCategoryResponse parses an HTTP response from a TagsEditTagCategoryWithResponse call
func ParseTagsEditTagCategoryResponse(rsp *http.Response) (*TagsEditTagCategoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsEditTagCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// An ISO timestamp indicating the date and time on which the category was created, for example, `2018-12-31T13:51:17.243Z`.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the category.
			CreatedBy *string `json:"created_by,omitempty"`

			// The description of the category.
			Description *string `json:"description,omitempty"`

			// The name of the category. The name must be unique within a Tenable.io instance.
			Name *string `json:"name,omitempty"`

			// Indicates whether the tags in this category are reserved (cannot be updated). This is a read-only field set by the system.
			Reserved *bool `json:"reserved,omitempty"`

			// An ISO timestamp indicating the date and time on which the category was last updated, for example, `2018-12-31T13:51:17.243Z`.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last updated the category.
			UpdatedBy *string `json:"updated_by,omitempty"`

			// The UUID of the category.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTagsListTagValuesResponse parses an HTTP response from a TagsListTagValuesWithResponse call
func ParseTagsListTagValuesResponse(rsp *http.Response) (*TagsListTagValuesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsListTagValuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Pagination *struct {
				// The number of records requested (or the default value if omitted from the request).
				Limit *int32 `json:"limit,omitempty"`

				// The starting record you requested (or zero if omitted).
				Offset *int32 `json:"offset,omitempty"`

				// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
				Sort *[]struct {
					// The field on which Tenable.io sorted the results.
					Name *string `json:"name,omitempty"`

					// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
					Order *string `json:"order,omitempty"`
				} `json:"sort,omitempty"`

				// The total number of records matching your search criteria.
				Total *int32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`

			// An array of tag value objects.
			Values *[]struct {
				// Determines what the user can do with the tag value.
				AccessControl *struct {
					// List of the minimum set of permissions all users have on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
					AllUsersPermissions *N200ValuesAccessControlAllUsersPermissions `json:"all_users_permissions,omitempty"`

					// List of user and group-specific permissions for the current tag.
					CurrentDomainPermissions *[]struct {
						// The UUID of a user or group.
						Id *string `json:"id,omitempty"`

						// The name of the user or group.
						Name *string `json:"name,omitempty"`

						// The permissions associated with the user or group.
						Permissions *[]string `json:"permissions,omitempty"`

						// The type of permission.
						Type *N200ValuesAccessControlCurrentDomainPermissionsType `json:"type,omitempty"`
					} `json:"current_domain_permissions,omitempty"`

					// List of all permissions for the current user on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`.
					CurrentUserPermissions *N200ValuesAccessControlCurrentUserPermissions `json:"current_user_permissions,omitempty"`

					// List of all defined permissions for objects of type tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
					DefinedDomainPermissions *N200ValuesAccessControlDefinedDomainPermissions `json:"defined_domain_permissions,omitempty"`

					// Optional, user-defined value. This value must be incremented each time the permissions are updated. Set to `1` by default.
					Version *int64 `json:"version,omitempty"`
				} `json:"access_control,omitempty"`

				// The description of the category associated with the tag value.
				CategoryDescription *string `json:"category_description,omitempty"`

				// The name of the category associated with the tag value.
				CategoryName *string `json:"category_name,omitempty"`

				// The UUID of the category associated with the tag value. Use this value to create future tags in the same category.
				CategoryUuid *string `json:"category_uuid,omitempty"`

				// An ISO timestamp indicating the date and time on which the tag value was created, for example, `2018-12-31T13:51:17.243Z`.
				CreatedAt *string `json:"created_at,omitempty"`

				// The name of the user who created the tag value.
				CreatedBy *string `json:"created_by,omitempty"`

				// The description of the tag value.
				Description *string `json:"description,omitempty"`

				// The tag type:
				//  - staticA user must manually apply the tag to assets.
				//  - dynamicTenable.io automatically applies the tag based on asset attribute rules.
				Type *string `json:"type,omitempty"`

				// An ISO timestamp indicating the date and time on which the tag value was last updated, for example, `2018-12-31T13:51:17.243Z`. When you create a tag value, this date matches the `created_at` date.
				UpdatedAt *string `json:"updated_at,omitempty"`

				// The name of the user who last updated the tag value. When you create a tag value, this name matches the `created_by` name.
				UpdatedBy *string `json:"updated_by,omitempty"`

				// The UUID of the tag value. Use this value to assign the tag to assets.
				Uuid *string `json:"uuid,omitempty"`

				// The tag value. Must be unique within the category.
				Value *string `json:"value,omitempty"`
			} `json:"values,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTagsCreateTagValueResponse parses an HTTP response from a TagsCreateTagValueWithResponse call
func ParseTagsCreateTagValueResponse(rsp *http.Response) (*TagsCreateTagValueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsCreateTagValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Determines what the user can do with the tag value.
			AccessControl *struct {
				// List of the minimum set of permissions all users have on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
				AllUsersPermissions *N200AccessControlAllUsersPermissions `json:"all_users_permissions,omitempty"`

				// List of user and group-specific permissions for the current tag.
				CurrentDomainPermissions *[]struct {
					// The UUID of a user or group.
					Id *string `json:"id,omitempty"`

					// The name of the user or group.
					Name *string `json:"name,omitempty"`

					// The permissions associated with the user or group.
					Permissions *[]string `json:"permissions,omitempty"`

					// The type of permission.
					Type *N200AccessControlCurrentDomainPermissionsType `json:"type,omitempty"`
				} `json:"current_domain_permissions,omitempty"`

				// List of all permissions for the current user on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`.
				CurrentUserPermissions *N200AccessControlCurrentUserPermissions `json:"current_user_permissions,omitempty"`

				// List of all defined permissions for objects of type tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
				DefinedDomainPermissions *N200AccessControlDefinedDomainPermissions `json:"defined_domain_permissions,omitempty"`

				// Optional, user-defined value. This value must be incremented each time the permissions are updated. Set to `1` by default.
				Version *int64 `json:"version,omitempty"`
			} `json:"access_control,omitempty"`

			// The description of the category associated with the tag value.
			CategoryDescription *string `json:"category_description,omitempty"`

			// The name of the category associated with the tag value.
			CategoryName *string `json:"category_name,omitempty"`

			// The UUID of the category associated with the tag value. Use this value to create future tags in the same category.
			CategoryUuid *string `json:"category_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the tag value was created, for example, `2018-12-31T13:51:17.243Z`.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the tag value.
			CreatedBy *string `json:"created_by,omitempty"`

			// The description of the tag value.
			Description *string `json:"description,omitempty"`

			// For dynamic tags, asset selection rules.
			Filters *struct {
				// Tag rule definitions represented as a JSON-formatted string.
				Asset *string `json:"asset,omitempty"`
			} `json:"filters,omitempty"`

			// The tag type:
			//  - staticA user must manually apply the tag to assets.
			//  - dynamicTenable.io automatically applies the tag based on asset attribute rules.
			Type *string `json:"type,omitempty"`

			// An ISO timestamp indicating the date and time on which the tag value was last updated, for example, `2018-12-31T13:51:17.243Z`. When you create a tag value, this date matches the `created_at` date.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last updated the tag value. When you create a tag value, this name matches the `created_by` name.
			UpdatedBy *string `json:"updated_by,omitempty"`

			// The UUID of the tag value. Use this value to assign the tag to assets.
			Uuid *string `json:"uuid,omitempty"`

			// The tag value. Must be unique within the category.
			Value *string `json:"value,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTagsDeleteTagValuesBulkResponse parses an HTTP response from a TagsDeleteTagValuesBulkWithResponse call
func ParseTagsDeleteTagValuesBulkResponse(rsp *http.Response) (*TagsDeleteTagValuesBulkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsDeleteTagValuesBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTagsDeleteTagValueResponse parses an HTTP response from a TagsDeleteTagValueWithResponse call
func ParseTagsDeleteTagValueResponse(rsp *http.Response) (*TagsDeleteTagValueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsDeleteTagValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 204:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON204 = &dest

	}

	return response, nil
}

// ParseTagsTagValueDetailsResponse parses an HTTP response from a TagsTagValueDetailsWithResponse call
func ParseTagsTagValueDetailsResponse(rsp *http.Response) (*TagsTagValueDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsTagValueDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Determines what the user can do with the tag value.
			AccessControl *struct {
				// List of the minimum set of permissions all users have on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
				AllUsersPermissions *N200AccessControlAllUsersPermissions `json:"all_users_permissions,omitempty"`

				// List of user and group-specific permissions for the current tag.
				CurrentDomainPermissions *[]struct {
					// The UUID of a user or group.
					Id *string `json:"id,omitempty"`

					// The name of the user or group.
					Name *string `json:"name,omitempty"`

					// The permissions associated with the user or group.
					Permissions *[]string `json:"permissions,omitempty"`

					// The type of permission.
					Type *N200AccessControlCurrentDomainPermissionsType `json:"type,omitempty"`
				} `json:"current_domain_permissions,omitempty"`

				// List of all permissions for the current user on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`.
				CurrentUserPermissions *N200AccessControlCurrentUserPermissions `json:"current_user_permissions,omitempty"`

				// List of all defined permissions for objects of type tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
				DefinedDomainPermissions *N200AccessControlDefinedDomainPermissions `json:"defined_domain_permissions,omitempty"`

				// Optional, user-defined value. This value must be incremented each time the permissions are updated. Set to `1` by default.
				Version *int64 `json:"version,omitempty"`
			} `json:"access_control,omitempty"`

			// The description of the category associated with the tag value.
			CategoryDescription *string `json:"category_description,omitempty"`

			// The name of the category associated with the tag value.
			CategoryName *string `json:"category_name,omitempty"`

			// The UUID of the category associated with the tag value. Use this value to create future tags in the same category.
			CategoryUuid *string `json:"category_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the tag value was created, for example, `2018-12-31T13:51:17.243Z`.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the tag value.
			CreatedBy *string `json:"created_by,omitempty"`

			// The description of the tag value.
			Description *string `json:"description,omitempty"`

			// For dynamic tags, asset selection rules.
			Filters *struct {
				// Tag rule definitions represented as a JSON-formatted string.
				Asset *string `json:"asset,omitempty"`
			} `json:"filters,omitempty"`

			// The tag type:
			//  - staticA user must manually apply the tag to assets.
			//  - dynamicTenable.io automatically applies the tag based on asset attribute rules.
			Type *string `json:"type,omitempty"`

			// An ISO timestamp indicating the date and time on which the tag value was last updated, for example, `2018-12-31T13:51:17.243Z`. When you create a tag value, this date matches the `created_at` date.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last updated the tag value. When you create a tag value, this name matches the `created_by` name.
			UpdatedBy *string `json:"updated_by,omitempty"`

			// The UUID of the tag value. Use this value to assign the tag to assets.
			Uuid *string `json:"uuid,omitempty"`

			// The tag value. Must be unique within the category.
			Value *string `json:"value,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTagsUpdateTagValueResponse parses an HTTP response from a TagsUpdateTagValueWithResponse call
func ParseTagsUpdateTagValueResponse(rsp *http.Response) (*TagsUpdateTagValueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TagsUpdateTagValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Determines what the user can do with the tag value.
			AccessControl *struct {
				// List of the minimum set of permissions all users have on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
				AllUsersPermissions *N200AccessControlAllUsersPermissions `json:"all_users_permissions,omitempty"`

				// List of user and group-specific permissions for the current tag.
				CurrentDomainPermissions *[]struct {
					// The UUID of a user or group.
					Id *string `json:"id,omitempty"`

					// The name of the user or group.
					Name *string `json:"name,omitempty"`

					// The permissions associated with the user or group.
					Permissions *[]string `json:"permissions,omitempty"`

					// The type of permission.
					Type *N200AccessControlCurrentDomainPermissionsType `json:"type,omitempty"`
				} `json:"current_domain_permissions,omitempty"`

				// List of all permissions for the current user on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`.
				CurrentUserPermissions *N200AccessControlCurrentUserPermissions `json:"current_user_permissions,omitempty"`

				// List of all defined permissions for objects of type tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
				DefinedDomainPermissions *N200AccessControlDefinedDomainPermissions `json:"defined_domain_permissions,omitempty"`

				// Optional, user-defined value. This value must be incremented each time the permissions are updated. Set to `1` by default.
				Version *int64 `json:"version,omitempty"`
			} `json:"access_control,omitempty"`

			// The description of the category associated with the tag value.
			CategoryDescription *string `json:"category_description,omitempty"`

			// The name of the category associated with the tag value.
			CategoryName *string `json:"category_name,omitempty"`

			// The UUID of the category associated with the tag value. Use this value to create future tags in the same category.
			CategoryUuid *string `json:"category_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the tag value was created, for example, `2018-12-31T13:51:17.243Z`.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the tag value.
			CreatedBy *string `json:"created_by,omitempty"`

			// The description of the tag value.
			Description *string `json:"description,omitempty"`

			// For dynamic tags, asset selection rules.
			Filters *struct {
				// Tag rule definitions represented as a JSON-formatted string.
				Asset *string `json:"asset,omitempty"`
			} `json:"filters,omitempty"`

			// The tag type:
			//  - staticA user must manually apply the tag to assets.
			//  - dynamicTenable.io automatically applies the tag based on asset attribute rules.
			Type *string `json:"type,omitempty"`

			// An ISO timestamp indicating the date and time on which the tag value was last updated, for example, `2018-12-31T13:51:17.243Z`. When you create a tag value, this date matches the `created_at` date.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last updated the tag value. When you create a tag value, this name matches the `created_by` name.
			UpdatedBy *string `json:"updated_by,omitempty"`

			// The UUID of the tag value. Use this value to assign the tag to assets.
			Uuid *string `json:"uuid,omitempty"`

			// The tag value. Must be unique within the category.
			Value *string `json:"value,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTargetGroupsListResponse parses an HTTP response from a TargetGroupsListWithResponse call
func ParseTargetGroupsListResponse(rsp *http.Response) (*TargetGroupsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TargetGroupsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// The Access Control Lists applicable to the group.
			Acls *[]struct {
				// The display-friendly name of the user or group.
				DisplayName *string `json:"display_name,omitempty"`

				// The unique ID of the user or group.
				Id *int `json:"id,omitempty"`

				// The name of the user or group.
				Name *string `json:"name,omitempty"`

				// The ID of the owner of the object.
				Owner *int `json:"owner,omitempty"`

				// The permission value to grant access as described in [Permissions](doc:permissions).
				Permissions *int32 `json:"permissions,omitempty"`

				// The type of permission (default, user, group).
				Type *N200AclsType `json:"type,omitempty"`

				// The UUID of the owner of the object.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"acls,omitempty"`

			// If true, this group is the default.
			DefaultGroup *bool `json:"default_group,omitempty"`

			// The unique ID of the group.
			Id *int `json:"id,omitempty"`

			// The last modification date for the group in unixtime.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The members of the group.
			Members *string `json:"members,omitempty"`

			// The name of the group.
			Name *string `json:"name,omitempty"`

			// The name of the owner of the group. A user of `nessus_ms_agent` indicates it is a system target group.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the group.
			OwnerId *int `json:"owner_id,omitempty"`

			// The shared status of the group.
			Shared *bool `json:"shared,omitempty"`

			// The group type (user or system). Note that the system group type is deprecated. Tenable recommends that you create only user target groups.
			Type *string `json:"type,omitempty"`

			// The current user permissions for the group.
			UserPermissions *int `json:"user_permissions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTargetGroupsCreateResponse parses an HTTP response from a TargetGroupsCreateWithResponse call
func ParseTargetGroupsCreateResponse(rsp *http.Response) (*TargetGroupsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TargetGroupsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The Access Control Lists applicable to the group.
			Acls *[]struct {
				// The display-friendly name of the user or group.
				DisplayName *string `json:"display_name,omitempty"`

				// The unique ID of the user or group.
				Id *int `json:"id,omitempty"`

				// The name of the user or group.
				Name *string `json:"name,omitempty"`

				// The ID of the owner of the object.
				Owner *int `json:"owner,omitempty"`

				// The permission value to grant access as described in [Permissions](doc:permissions).
				Permissions *int32 `json:"permissions,omitempty"`

				// The type of permission (default, user, group).
				Type *N200AclsType `json:"type,omitempty"`

				// The UUID of the owner of the object.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"acls,omitempty"`

			// If true, this group is the default.
			DefaultGroup *bool `json:"default_group,omitempty"`

			// The unique ID of the group.
			Id *int `json:"id,omitempty"`

			// The last modification date for the group in unixtime.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The members of the group.
			Members *string `json:"members,omitempty"`

			// The name of the group.
			Name *string `json:"name,omitempty"`

			// The name of the owner of the group. A user of `nessus_ms_agent` indicates it is a system target group.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the group.
			OwnerId *int `json:"owner_id,omitempty"`

			// The shared status of the group.
			Shared *bool `json:"shared,omitempty"`

			// The group type (user or system). Note that the system group type is deprecated. Tenable recommends that you create only user target groups.
			Type *string `json:"type,omitempty"`

			// The current user permissions for the group.
			UserPermissions *int `json:"user_permissions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTargetGroupsDeleteResponse parses an HTTP response from a TargetGroupsDeleteWithResponse call
func ParseTargetGroupsDeleteResponse(rsp *http.Response) (*TargetGroupsDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TargetGroupsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTargetGroupsDetailsResponse parses an HTTP response from a TargetGroupsDetailsWithResponse call
func ParseTargetGroupsDetailsResponse(rsp *http.Response) (*TargetGroupsDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TargetGroupsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The Access Control Lists applicable to the group.
			Acls *[]struct {
				// The display-friendly name of the user or group.
				DisplayName *string `json:"display_name,omitempty"`

				// The unique ID of the user or group.
				Id *int `json:"id,omitempty"`

				// The name of the user or group.
				Name *string `json:"name,omitempty"`

				// The ID of the owner of the object.
				Owner *int `json:"owner,omitempty"`

				// The permission value to grant access as described in [Permissions](doc:permissions).
				Permissions *int32 `json:"permissions,omitempty"`

				// The type of permission (default, user, group).
				Type *N200AclsType `json:"type,omitempty"`

				// The UUID of the owner of the object.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"acls,omitempty"`

			// If true, this group is the default.
			DefaultGroup *bool `json:"default_group,omitempty"`

			// The unique ID of the group.
			Id *int `json:"id,omitempty"`

			// The last modification date for the group in unixtime.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The members of the group.
			Members *string `json:"members,omitempty"`

			// The name of the group.
			Name *string `json:"name,omitempty"`

			// The name of the owner of the group. A user of `nessus_ms_agent` indicates it is a system target group.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the group.
			OwnerId *int `json:"owner_id,omitempty"`

			// The shared status of the group.
			Shared *bool `json:"shared,omitempty"`

			// The group type (user or system). Note that the system group type is deprecated. Tenable recommends that you create only user target groups.
			Type *string `json:"type,omitempty"`

			// The current user permissions for the group.
			UserPermissions *int `json:"user_permissions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTargetGroupsEditResponse parses an HTTP response from a TargetGroupsEditWithResponse call
func ParseTargetGroupsEditResponse(rsp *http.Response) (*TargetGroupsEditResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TargetGroupsEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The Access Control Lists applicable to the group.
			Acls *[]struct {
				// The display-friendly name of the user or group.
				DisplayName *string `json:"display_name,omitempty"`

				// The unique ID of the user or group.
				Id *int `json:"id,omitempty"`

				// The name of the user or group.
				Name *string `json:"name,omitempty"`

				// The ID of the owner of the object.
				Owner *int `json:"owner,omitempty"`

				// The permission value to grant access as described in [Permissions](doc:permissions).
				Permissions *int32 `json:"permissions,omitempty"`

				// The type of permission (default, user, group).
				Type *N200AclsType `json:"type,omitempty"`

				// The UUID of the owner of the object.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"acls,omitempty"`

			// If true, this group is the default.
			DefaultGroup *bool `json:"default_group,omitempty"`

			// The unique ID of the group.
			Id *int `json:"id,omitempty"`

			// The last modification date for the group in unixtime.
			LastModificationDate *int `json:"last_modification_date,omitempty"`

			// The members of the group.
			Members *string `json:"members,omitempty"`

			// The name of the group.
			Name *string `json:"name,omitempty"`

			// The name of the owner of the group. A user of `nessus_ms_agent` indicates it is a system target group.
			Owner *string `json:"owner,omitempty"`

			// The unique ID of the owner of the group.
			OwnerId *int `json:"owner_id,omitempty"`

			// The shared status of the group.
			Shared *bool `json:"shared,omitempty"`

			// The group type (user or system). Note that the system group type is deprecated. Tenable recommends that you create only user target groups.
			Type *string `json:"type,omitempty"`

			// The current user permissions for the group.
			UserPermissions *int `json:"user_permissions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoV2AccessGroupsListResponse parses an HTTP response from a IoV2AccessGroupsListWithResponse call
func ParseIoV2AccessGroupsListResponse(rsp *http.Response) (*IoV2AccessGroupsListResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV2AccessGroupsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccessGroups *struct {
				// The type of access group. It can be one of three possible types:
				//  * MANAGE_ASSETSUsers in this access group can view the asset records created during previous scans and scan the associated targets for those assets.
				//  * SCAN_TARGETSUsers in this access group can scan targets associated with the access group and view the results of those scans. Targets may be associated with existing assets.
				//  * ALLThis access group type is only applicable to the default system-generated "All Assets" access group that contains all assets in your organization. This group is referred to as the "All Assets" group in the user interface. By default, Tenable.io grants all users in this access group both CAN VIEW and CAN SCAN permissions.
				AccessGroupType *N200AccessGroupsAccessGroupType `json:"access_group_type,omitempty"`

				// Specifies whether the access group is the system-provided All Assets access group:
				//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /v2/access-groups/{id}](ref:io-v2-access-groups-edit) endpoint.
				//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
				AllAssets *bool `json:"all_assets,omitempty"`

				// The UUID of your Tenable.io instance.
				ContainerUuid *string `json:"container_uuid,omitempty"`

				// An ISO timestamp indicating the date and time on which the access group was created.
				CreatedAt *string `json:"created_at,omitempty"`

				// The name of the user who created the access group.
				CreatedByName *string `json:"created_by_name,omitempty"`

				// The UUID of the user who created the access group.
				CreatedByUuid *string `json:"created_by_uuid,omitempty"`

				// The UUID of the access group.
				Id *string `json:"id,omitempty"`

				// The name of the access group. This name must be:
				// * Unique within your Tenable.io instance.
				// * A maximum of 255 characters.
				// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
				Name *string `json:"name,omitempty"`

				// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
				Principals *[]struct {
					// (Required) The permissions associated with the principal of the access group as described in <a href="/docs/permissions">Permissions</a>.
					Permissions *N200AccessGroupsPrincipalsPermissions `json:"permissions,omitempty"`

					// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
					PrincipalId *string `json:"principal_id,omitempty"`

					// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
					PrincipalName *string `json:"principal_name,omitempty"`

					// (Required) The type of principal. Valid values include:
					//  - all_usersGrants access to all users in your organization. That access includes `Can View` access to the assets defined in the rules parameter.
					//  - userGrants access to the user you specify.
					//  - groupGrants access to all users assigned to the user group you specify.
					Type *N200AccessGroupsPrincipalsType `json:"type,omitempty"`
				} `json:"principals,omitempty"`

				// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
				ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

				// The status of the process evaluating and assigning assets to the access group. Possible values are:
				//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
				//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
				//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
				Status *string `json:"status,omitempty"`

				// An ISO timestamp indicating the time and date on which the access group was last modified.
				UpdatedAt *string `json:"updated_at,omitempty"`

				// The name of the user who last modified the access group.
				UpdatedByName *string `json:"updated_by_name,omitempty"`

				// The UUID of the user who last modified the access group.
				UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`

				// Optional, user-defined value. This value must be incremented each time an access group is updated. Set to `1` by default.
				Version *int `json:"version,omitempty"`
			} `json:"access_groups,omitempty"`
			Pagination *struct {
				// The number of records requested (or the default value if omitted from the request).
				Limit *int32 `json:"limit,omitempty"`

				// The starting record you requested (or zero if omitted).
				Offset *int32 `json:"offset,omitempty"`

				// An array of objects representing the fields and sort order you specified in the request, which Tenable.io used to sort the returned data.
				Sort *[]struct {
					// The field on which Tenable.io sorted the results.
					Name *string `json:"name,omitempty"`

					// The direction of the sort order. Supported values are `asc` (ascending) and `desc` (descending).
					Order *string `json:"order,omitempty"`
				} `json:"sort,omitempty"`

				// The total number of records matching your search criteria.
				Total *int32 `json:"total,omitempty"`
			} `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoV2AccessGroupsCreateResponse parses an HTTP response from a IoV2AccessGroupsCreateWithResponse call
func ParseIoV2AccessGroupsCreateResponse(rsp *http.Response) (*IoV2AccessGroupsCreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV2AccessGroupsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The type of access group. It can be one of three possible types:
			//  * MANAGE_ASSETSUsers in this access group can view the asset records created during previous scans and scan the associated targets for those assets.
			//  * SCAN_TARGETSUsers in this access group can scan targets associated with the access group and view the results of those scans. Targets may be associated with existing assets.
			//  * ALLThis access group type is only applicable to the default system-generated "All Assets" access group that contains all assets in your organization. This group is referred to as the "All Assets" group in the user interface. By default, Tenable.io grants all users in this access group both CAN VIEW and CAN SCAN permissions.
			AccessGroupType *N200AccessGroupType `json:"access_group_type,omitempty"`

			// Specifies whether the access group is the system-provided All Assets access group:
			//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /v2/access-groups/{id}](ref:io-v2-access-groups-edit) endpoint.
			//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
			AllAssets *bool `json:"all_assets,omitempty"`

			// The UUID of your Tenable.io instance.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the access group was created.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the access group.
			CreatedByName *string `json:"created_by_name,omitempty"`

			// The UUID of the user who created the access group.
			CreatedByUuid *string `json:"created_by_uuid,omitempty"`

			// The UUID of the access group.
			Id *string `json:"id,omitempty"`

			// The name of the access group. This name must be:
			// * Unique within your Tenable.io instance.
			// * A maximum of 255 characters.
			// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
			Name *string `json:"name,omitempty"`

			// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
			Principals *[]struct {
				// (Required) The permissions associated with the principal of the access group as described in <a href="/docs/permissions">Permissions</a>.
				Permissions *N200PrincipalsPermissions `json:"permissions,omitempty"`

				// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
				PrincipalId *string `json:"principal_id,omitempty"`

				// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
				PrincipalName *string `json:"principal_name,omitempty"`

				// (Required) The type of principal. Valid values include:
				//  - all_usersGrants access to all users in your organization. That access includes `Can View` access to the assets defined in the rules parameter.
				//  - userGrants access to the user you specify.
				//  - groupGrants access to all users assigned to the user group you specify.
				Type *N200PrincipalsType `json:"type,omitempty"`
			} `json:"principals,omitempty"`

			// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
			ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

			// The status of the process evaluating and assigning assets to the access group. Possible values are:
			//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
			//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
			//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
			Status *string `json:"status,omitempty"`

			// An ISO timestamp indicating the time and date on which the access group was last modified.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last modified the access group.
			UpdatedByName *string `json:"updated_by_name,omitempty"`

			// The UUID of the user who last modified the access group.
			UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`

			// Optional, user-defined value. This value must be incremented each time an access group is updated. Set to `1` by default.
			Version *int `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoV2AccessGroupsListFiltersResponse parses an HTTP response from a IoV2AccessGroupsListFiltersWithResponse call
func ParseIoV2AccessGroupsListFiltersResponse(rsp *http.Response) (*IoV2AccessGroupsListFiltersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV2AccessGroupsListFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The filters and operators for each field you can use when constructing filter (`f` parameter) values in the [GET /v2/access-groups](ref:io-v2-access-groups-list) endpoint.
			Filters *[]struct {
				// Indicates how the parameter appears in the Tenable.io user interface.
				Control *string `json:"control,omitempty"`

				// Corresponds to the field component of the `f` parameter.
				Name *string `json:"name,omitempty"`

				// Corresponds to the operator component of the `f` parameter.
				Operators *[]string `json:"operators,omitempty"`

				// The name of the parameter as it appears in the Tenable.io user interface.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"filters,omitempty"`

			// The fields you can use when constructing `sort` parameter values for the [GET /v2/access-groups](ref:io-v2-access-groups-list) endpoint.
			Sort *[]struct {
				// The names of the fields you can use when constructing `sort` parameter values for the [GET /v2/access-groups](ref:io-v2-access-groups-list) endpoint.
				SortableFields *string `json:"sortable_fields,omitempty"`
			} `json:"sort,omitempty"`

			// The fields you can use as a wildcard (`wf` parameter) value in the [GET /v2/access-groups](ref:io-v2-access-groups-list) endpoint.
			WildcardFields *[]string `json:"wildcard_fields,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoV2AccessGroupsListRuleFiltersResponse parses an HTTP response from a IoV2AccessGroupsListRuleFiltersWithResponse call
func ParseIoV2AccessGroupsListRuleFiltersResponse(rsp *http.Response) (*IoV2AccessGroupsListRuleFiltersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV2AccessGroupsListRuleFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// An array specifying values to use when constructing an asset rule for the [POST /access-groups](ref:io-v2-access-groups-create) and [PUT /access-groups/{id}](ref:io-v2-access-groups-edit) methods.
			Rules *[]struct {
				// Indicates how the field appears in the Tenable.io user interface.
				Control *[]struct {
					// The regular expression Tenable.io uses to match values of the rule type.
					Regex *string `json:"regex,omitempty"`

					// The type of control.
					Type *string `json:"type,omitempty"`
				} `json:"control,omitempty"`

				// The name of the filter parameter. Corresponds to the asset rule type.
				Name *string `json:"name,omitempty"`

				// The operator that specifies how Tenable.io matches the terms value to asset data. Corresponds to the operator component of the rules parameter. Possible operators include:
				// * eqTenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
				// * matchTenable.io matches the rule to assets based a partial match of the specified term.
				// * startsTenable.io matches the rule to assets that start with the specified term.
				// * endsTenable.io matches the rule to assets that end with the specified term.
				//  * set-hasTenable.io matches the rule to assets based on the specified `tag_uuid`.
				//
				// For a complete list of operators by rule type, use the [GET /v2/access-groups/filters](ref:io-v2-access-groups-list-filters) endpoint.
				Operators *[]string `json:"operators,omitempty"`

				// An example value.
				Placeholder *string `json:"placeholder,omitempty"`

				// The name of the field as it appears in the Tenable.io user interface.
				ReadableName *string `json:"readable_name,omitempty"`
			} `json:"rules,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoV2AccessGroupsDeleteResponse parses an HTTP response from a IoV2AccessGroupsDeleteWithResponse call
func ParseIoV2AccessGroupsDeleteResponse(rsp *http.Response) (*IoV2AccessGroupsDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV2AccessGroupsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIoV2AccessGroupsDetailsResponse parses an HTTP response from a IoV2AccessGroupsDetailsWithResponse call
func ParseIoV2AccessGroupsDetailsResponse(rsp *http.Response) (*IoV2AccessGroupsDetailsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV2AccessGroupsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The type of access group. It can be one of three possible types:
			//  * MANAGE_ASSETSUsers in this access group can view the asset records created during previous scans and scan the associated targets for those assets.
			//  * SCAN_TARGETSUsers in this access group can scan targets associated with the access group and view the results of those scans. Targets may be associated with existing assets.
			//  * ALLThis access group type is only applicable to the default system-generated "All Assets" access group that contains all assets in your organization. This group is referred to as the "All Assets" group in the user interface. By default, Tenable.io grants all users in this access group both CAN VIEW and CAN SCAN permissions.
			AccessGroupType *N200AccessGroupType `json:"access_group_type,omitempty"`

			// Specifies whether the access group is the system-provided All Assets access group:
			//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /v2/access-groups/{id}](ref:io-v2-access-groups-edit) endpoint.
			//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
			AllAssets *bool `json:"all_assets,omitempty"`

			// The UUID of your Tenable.io instance.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the access group was created.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the access group.
			CreatedByName *string `json:"created_by_name,omitempty"`

			// The UUID of the user who created the access group.
			CreatedByUuid *string `json:"created_by_uuid,omitempty"`

			// The UUID of the access group.
			Id *string `json:"id,omitempty"`

			// The name of the access group. This name must be:
			// * Unique within your Tenable.io instance.
			// * A maximum of 255 characters.
			// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
			Name *string `json:"name,omitempty"`

			// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
			Principals *[]struct {
				// (Required) The permissions associated with the principal of the access group as described in <a href="/docs/permissions">Permissions</a>.
				Permissions *N200PrincipalsPermissions `json:"permissions,omitempty"`

				// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
				PrincipalId *string `json:"principal_id,omitempty"`

				// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
				PrincipalName *string `json:"principal_name,omitempty"`

				// (Required) The type of principal. Valid values include:
				//  - all_usersGrants access to all users in your organization. That access includes `Can View` access to the assets defined in the rules parameter.
				//  - userGrants access to the user you specify.
				//  - groupGrants access to all users assigned to the user group you specify.
				Type *N200PrincipalsType `json:"type,omitempty"`
			} `json:"principals,omitempty"`

			// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
			ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

			// An array of asset rules. Tenable.io uses these rules to assign assets to the access group. You can specify a maximum of 1,000 rules for an individual access group. If you specify multiple rules for an access group, Tenable.io assigns an asset to the access group if the asset matches any of the rules. You can only add rules to access groups if the `all_assets` parameter is set to `false`.
			Rules *[]struct {
				// The operator that specifies how Tenable.io matches the terms value to asset data.
				//
				// Possible operators include:
				//  - eqTenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
				//  - matchTenable.io matches the rule to assets based a partial match of the specified term.
				//  - startsTenable.io matches the rule to assets that start with the specified term.
				//  - endsTenable.io matches the rule to assets that end with the specified term.
				//  - set-hasTenable.io matches the rule to assets based on the specified `tag_uuid`.
				//
				// For a complete list of operators by rule type, use the [GET /v2/access-groups/rules/filters](ref:io-v2-access-groups-list-rule-filters) endpoint.
				Operator *string `json:"operator,omitempty"`

				// The values that Tenable.io uses to match an asset to the rule. A term must correspond to the rule type.
				//
				// For example:
				//  - If the rule type is `aws_account`, the term is an AWS account ID.
				//  - If the rule type is `fqdn`, the term is a hostname or a fully-qualified domain name (FQDN).
				//  - If the rule type is `ipv4`, the term is an individual IPv4 address, a range of IPv4 addresses (for example, 192.0.2.57-192.0.2.60), or a CIDR range (for example, 192.0.2.57/24).
				//
				// For a complete list of supported values by rule type, use the [GET /v2/access-groups/rules/filters](ref:io-v2-access-groups-list-rule-filters) endpoint.
				//
				// If you specify multiple terms values, Tenable.io includes an asset in the access group if the asset's attributes match any of the terms in the rule.
				// <br >You can specify up to 100,000 terms per asset rule.
				Terms *[]string `json:"terms,omitempty"`

				// The type of asset rule. The asset rule type corresponds to the type of data you can specify in the `terms` parameter. For a complete list of supported rule types, use the [GET /v2/access-groups/filters](ref:io-v2-access-groups-list-filters) endpoint.
				Type *string `json:"type,omitempty"`
			} `json:"rules,omitempty"`

			// The status of the process evaluating and assigning assets to the access group. Possible values are:
			//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
			//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
			//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
			Status *string `json:"status,omitempty"`

			// An ISO timestamp indicating the time and date on which the access group was last modified.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last modified the access group.
			UpdatedByName *string `json:"updated_by_name,omitempty"`

			// The UUID of the user who last modified the access group.
			UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`

			// Optional, user-defined value. This value must be incremented each time an access group is updated. Set to `1` by default.
			Version *int `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIoV2AccessGroupsEditResponse parses an HTTP response from a IoV2AccessGroupsEditWithResponse call
func ParseIoV2AccessGroupsEditResponse(rsp *http.Response) (*IoV2AccessGroupsEditResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IoV2AccessGroupsEditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The type of access group. It can be one of three possible types:
			//  * MANAGE_ASSETSUsers in this access group can view the asset records created during previous scans and scan the associated targets for those assets.
			//  * SCAN_TARGETSUsers in this access group can scan targets associated with the access group and view the results of those scans. Targets may be associated with existing assets.
			//  * ALLThis access group type is only applicable to the default system-generated "All Assets" access group that contains all assets in your organization. This group is referred to as the "All Assets" group in the user interface. By default, Tenable.io grants all users in this access group both CAN VIEW and CAN SCAN permissions.
			AccessGroupType *N200AccessGroupType `json:"access_group_type,omitempty"`

			// Specifies whether the access group is the system-provided All Assets access group:
			//  - If `true`, the access group is the All Assets access group. The only change you can make to this access group is to refine user membership in the group. For more information, see descriptions of the all_users and principals parameters for the [PUT /v2/access-groups/{id}](ref:io-v2-access-groups-edit) endpoint.
			//  - If `false`, the access group is a user-defined access group, and you can change all parameters for the group. This parameter is `false` for all access groups you create.
			AllAssets *bool `json:"all_assets,omitempty"`

			// The UUID of your Tenable.io instance.
			ContainerUuid *string `json:"container_uuid,omitempty"`

			// An ISO timestamp indicating the date and time on which the access group was created.
			CreatedAt *string `json:"created_at,omitempty"`

			// The name of the user who created the access group.
			CreatedByName *string `json:"created_by_name,omitempty"`

			// The UUID of the user who created the access group.
			CreatedByUuid *string `json:"created_by_uuid,omitempty"`

			// The UUID of the access group.
			Id *string `json:"id,omitempty"`

			// The name of the access group. This name must be:
			// * Unique within your Tenable.io instance.
			// * A maximum of 255 characters.
			// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
			Name *string `json:"name,omitempty"`

			// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
			Principals *[]struct {
				// (Required) The permissions associated with the principal of the access group as described in <a href="/docs/permissions">Permissions</a>.
				Permissions *N200PrincipalsPermissions `json:"permissions,omitempty"`

				// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
				PrincipalId *string `json:"principal_id,omitempty"`

				// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
				PrincipalName *string `json:"principal_name,omitempty"`

				// (Required) The type of principal. Valid values include:
				//  - all_usersGrants access to all users in your organization. That access includes `Can View` access to the assets defined in the rules parameter.
				//  - userGrants access to the user you specify.
				//  - groupGrants access to all users assigned to the user group you specify.
				Type *N200PrincipalsType `json:"type,omitempty"`
			} `json:"principals,omitempty"`

			// The percentage of assets that Tenable.io has evaluated against the asset rules for the access group.
			ProcessingPercentComplete *int `json:"processing_percent_complete,omitempty"`

			// An array of asset rules. Tenable.io uses these rules to assign assets to the access group. You can specify a maximum of 1,000 rules for an individual access group. If you specify multiple rules for an access group, Tenable.io assigns an asset to the access group if the asset matches any of the rules. You can only add rules to access groups if the `all_assets` parameter is set to `false`.
			Rules *[]struct {
				// The operator that specifies how Tenable.io matches the terms value to asset data.
				//
				// Possible operators include:
				//  - eqTenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
				//  - matchTenable.io matches the rule to assets based a partial match of the specified term.
				//  - startsTenable.io matches the rule to assets that start with the specified term.
				//  - endsTenable.io matches the rule to assets that end with the specified term.
				//  - set-hasTenable.io matches the rule to assets based on the specified `tag_uuid`.
				//
				// For a complete list of operators by rule type, use the [GET /v2/access-groups/rules/filters](ref:io-v2-access-groups-list-rule-filters) endpoint.
				Operator *string `json:"operator,omitempty"`

				// The values that Tenable.io uses to match an asset to the rule. A term must correspond to the rule type.
				//
				// For example:
				//  - If the rule type is `aws_account`, the term is an AWS account ID.
				//  - If the rule type is `fqdn`, the term is a hostname or a fully-qualified domain name (FQDN).
				//  - If the rule type is `ipv4`, the term is an individual IPv4 address, a range of IPv4 addresses (for example, 192.0.2.57-192.0.2.60), or a CIDR range (for example, 192.0.2.57/24).
				//
				// For a complete list of supported values by rule type, use the [GET /v2/access-groups/rules/filters](ref:io-v2-access-groups-list-rule-filters) endpoint.
				//
				// If you specify multiple terms values, Tenable.io includes an asset in the access group if the asset's attributes match any of the terms in the rule.
				// <br >You can specify up to 100,000 terms per asset rule.
				Terms *[]string `json:"terms,omitempty"`

				// The type of asset rule. The asset rule type corresponds to the type of data you can specify in the `terms` parameter. For a complete list of supported rule types, use the [GET /v2/access-groups/filters](ref:io-v2-access-groups-list-filters) endpoint.
				Type *string `json:"type,omitempty"`
			} `json:"rules,omitempty"`

			// The status of the process evaluating and assigning assets to the access group. Possible values are:
			//  - PROCESSINGTenable.io is currently evaluating assets against the asset rules for the access group. For an indication of evaluation progress, see the `processing_percent_complete` attribute for the access group.
			//  - COMPLETEDTenable.io has successfully completed its evaluation of assets against the asset rules for the group.
			//  - ERRORTenable.io encountered an error while evaluating assets against asset rules for the access group. Rule validation typically prevents this status from occurring. However, if you encounter an ERROR status, Tenable recommends that you delete the existing asset rules, then recreate the rules after a short time has elapsed.
			Status *string `json:"status,omitempty"`

			// An ISO timestamp indicating the time and date on which the access group was last modified.
			UpdatedAt *string `json:"updated_at,omitempty"`

			// The name of the user who last modified the access group.
			UpdatedByName *string `json:"updated_by_name,omitempty"`

			// The UUID of the user who last modified the access group.
			UpdatedByUuid *string `json:"updated_by_uuid,omitempty"`

			// Optional, user-defined value. This value must be incremented each time an access group is updated. Set to `1` by default.
			Version *int `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExportsVulnsRequestExportResponse parses an HTTP response from a ExportsVulnsRequestExportWithResponse call
func ParseExportsVulnsRequestExportResponse(rsp *http.Response) (*ExportsVulnsRequestExportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportsVulnsRequestExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The UUID of the vulnerabilities export job.
			ExportUuid *string `json:"export_uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExportsVulnsExportStatusRecentResponse parses an HTTP response from a ExportsVulnsExportStatusRecentWithResponse call
func ParseExportsVulnsExportStatusRecentResponse(rsp *http.Response) (*ExportsVulnsExportStatusRecentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportsVulnsExportStatusRecentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Exports *[]struct {
				// The total number of completed chunks available for download.
				ChunksAvailableCount *int `json:"chunks_available_count,omitempty"`

				// The Unix timestamp when the export job was created.
				Created *int `json:"created,omitempty"`

				// The total number of empty chunks.
				EmptyChunksCount *int `json:"empty_chunks_count,omitempty"`

				// The filters used in the export job request. For a list of possible filters, see the [POST /vulns/export](ref:exports-vulns-request-export) and [POST /assets/export](ref:exports-assets-request-export) endpoints.
				Filters *map[string]interface{} `json:"filters,omitempty"`

				// The number of chunks that have been processed and are available for download.
				FinishedChunks *int `json:"finished_chunks,omitempty"`

				// The number of assets contained in each export chunk.
				NumAssetsPerChunk *int `json:"num_assets_per_chunk,omitempty"`

				// The status of the export request. Possible values include:
				//  - QUEUEDTenable.io has queued the export request until it completes other requests currently in process.
				//  - PROCESSINGTenable.io has started processing the export request.
				//  - FINISHEDTenable.io has completed processing the export request. The list of chunks is complete.
				//  - CANCELLEDAn administrator has cancelled the export request.
				//  - ERRORTenable.io encountered an error while processing the export request. Tenable recommends that you retry the request. If the status persists on retry, contact Support.
				Status *string `json:"status,omitempty"`

				// The total number of chunks associated with the export job as a whole.
				TotalChunks *int `json:"total_chunks,omitempty"`

				// The UUID for the export request.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"exports,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExportsVulnsExportCancelResponse parses an HTTP response from a ExportsVulnsExportCancelWithResponse call
func ParseExportsVulnsExportCancelResponse(rsp *http.Response) (*ExportsVulnsExportCancelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportsVulnsExportCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Text describing the export job status, `CANCELLED`.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseExportsVulnsDownloadChunkResponse parses an HTTP response from a ExportsVulnsDownloadChunkWithResponse call
func ParseExportsVulnsDownloadChunkResponse(rsp *http.Response) (*ExportsVulnsDownloadChunkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportsVulnsDownloadChunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExportsVulnsExportStatusResponse parses an HTTP response from a ExportsVulnsExportStatusWithResponse call
func ParseExportsVulnsExportStatusResponse(rsp *http.Response) (*ExportsVulnsExportStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportsVulnsExportStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Information about the export job.
			Status *struct {
				// A list of completed chunks available for download.
				ChunksAvailable *[]int32 `json:"chunks_available,omitempty"`

				// The total number of completed chunks available for download.
				ChunksAvailableCount *int `json:"chunks_available_count,omitempty"`

				// A list of chunks for which the export process was cancelled. If a chunk fails processing, Tenable.io automatically cancels all subsequent chunks queued for export in the same request.
				ChunksCancelled *[]int32 `json:"chunks_cancelled,omitempty"`

				// A list of chunks for which the export process failed. If a chunk fails processing, submit the export request again. If the chunk continues to fail, contact Support.
				ChunksFailed *[]int32 `json:"chunks_failed,omitempty"`

				// The Unix timestamp when the export job was created.
				Created *int `json:"created,omitempty"`

				// The total number of empty chunks.
				EmptyChunksCount *int `json:"empty_chunks_count,omitempty"`

				// The filters used in the export job request. For a list of possible filters, see the [POST /vulns/export](ref:exports-vulns-export-request-export) and [POST /assets/export](ref:exports-assets-request-export) endpoints.
				Filters *map[string]interface{} `json:"filters,omitempty"`

				// The number of chunks that have been processed and are available for download.
				FinishedChunks *int `json:"finished_chunks,omitempty"`

				// The number of assets contained in each export chunk.
				NumAssetsPerChunk *int `json:"num_assets_per_chunk,omitempty"`

				// The status of the export request. Possible values include:
				//  - QUEUEDTenable.io has queued the export request until it completes other requests currently in process.
				//  - PROCESSINGTenable.io has started processing the export request.
				//  - FINISHEDTenable.io has completed processing the export request. The list of chunks is complete.
				//  - CANCELLEDAn administrator has cancelled the export request.
				//  - ERRORTenable.io encountered an error while processing the export request. Tenable recommends that you retry the request. If the status persists on retry, contact Support.
				Status *string `json:"status,omitempty"`

				// The total number of chunks associated with the export job as a whole.
				TotalChunks *int `json:"total_chunks,omitempty"`

				// The UUID for the export request.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkbenchesAssetsResponse parses an HTTP response from a WorkbenchesAssetsWithResponse call
func ParseWorkbenchesAssetsResponse(rsp *http.Response) (*WorkbenchesAssetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// An array of asset objects.
			Assets *[]struct {
				// The key drivers that Tenable uses to calculate an asset's Tenable-provided ACR. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
				//
				// This attribute is only present if you have a Lumin license.
				AcrDrivers *[]struct {
					// The type of characteristic.
					DriverName *string `json:"driver_name,omitempty"`

					// The characteristic value.
					DriverValue *[]string `json:"driver_value,omitempty"`
				} `json:"acr_drivers,omitempty"`

				// The Asset Criticality Rating (ACR) for the asset. Tenable assigns an ACR to each asset on your network to represent the asset's relative risk as an integer from 1 to 10. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
				//
				// This attribute is only present if you have a Lumin license.
				AcrScore *int `json:"acr_score,omitempty"`

				// The names of any Nessus agents that scanned and identified the asset.
				AgentName *[]string `json:"agent_name,omitempty"`

				// The name of the virtual machine instance in AWS EC2.
				AwsEc2Name *[]string `json:"aws_ec2_name,omitempty"`

				// The unique identifier of the asset in HCL BigFix. For more information, see the HCL BigFix documentation.
				BigfixAssetId *[]string `json:"bigfix_asset_id,omitempty"`

				// The Asset Exposure Score (AES) for the asset. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
				//
				// This attribute is only present if you have a Lumin license.
				ExposureScore *int `json:"exposure_score,omitempty"`

				// A list of fully-qualified domain names (FQDNs) for the asset.
				Fqdn *[]string `json:"fqdn,omitempty"`

				// A value specifying whether a Nessus agent scan detected the asset (`true`).
				HasAgent *bool `json:"has_agent,omitempty"`

				// The UUID of the asset.
				Id *string `json:"id,omitempty"`

				// A list of ipv4 addresses for the asset.
				Ipv4 *[]string `json:"ipv4,omitempty"`

				// A list of ipv6 addresses for the asset.
				Ipv6 *[]string `json:"ipv6,omitempty"`

				// The IPv4 address, IPv6 address, or FQDN that the scanner last used to evaluate the asset.
				LastScanTarget *string `json:"last_scan_target,omitempty"`

				// The ISO timestamp of the scan that most recently detected the asset.
				LastSeen *string `json:"last_seen,omitempty"`

				// A list of MAC addresses for the asset.
				MacAddress *[]string `json:"mac_address,omitempty"`

				// The NetBIOS name for the asset.
				NetbiosName *[]string `json:"netbios_name,omitempty"`

				// The operating system installed on the asset.
				OperatingSystem *[]string `json:"operating_system,omitempty"`

				// Information about how often scans ran against the asset during specified intervals. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
				//
				// This attribute is only present if you have a Lumin license.
				ScanFrequency *[]struct {
					// The number of times that a scan ran against the asset during the specified interval.
					Frequency *int `json:"frequency,omitempty"`

					// The number of days over which Tenable searches for scans involving the asset.
					Interval *int `json:"interval,omitempty"`

					// Indicates whether the asset was licensed at the time of the identified scans.
					Licensed *bool `json:"licensed,omitempty"`
				} `json:"scan_frequency,omitempty"`

				// A list of sources for the asset record.
				Sources *[]struct {
					// The ISO timestamp when the source first reported the asset.
					FirstSeen *string `json:"first_seen,omitempty"`

					// The ISO timestamp when the source last reported the asset.
					LastSeen *string `json:"last_seen,omitempty"`

					// The name of the entity that reported the asset details. Sources can include sensors, connectors, and API imports. Source names can be customized by your organization (for example, you specify a name when you import asset records). If your organization does not customize source names, system-generated names include:
					//  - AWSYou obtained the asset data from an Amazon Web Services connector.
					//  - NESSUS_AGENTYou obtained the asset data obtained from a Nessus agent scan.
					//  - PVSYou obtained the asset data from a Nessus Network Monitor (NNM) scan.
					//  - NESSUS_SCANYou obtained the asset data from a Nessus scan.
					//  - WASYou obtained the asset data from a  Web Application Scanning scan.
					Name *string `json:"name,omitempty"`
				} `json:"sources,omitempty"`
			} `json:"assets,omitempty"`

			// The total count of returned assets.
			Total *int `json:"total,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkbenchesAssetsVulnerabilitiesResponse parses an HTTP response from a WorkbenchesAssetsVulnerabilitiesWithResponse call
func ParseWorkbenchesAssetsVulnerabilitiesResponse(rsp *http.Response) (*WorkbenchesAssetsVulnerabilitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesAssetsVulnerabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// The names of any Nessus agents that scanned and identified the asset.
			AgentName *[]string `json:"agent_name,omitempty"`

			// A list of fully-qualified domain names (FQDNs) for the asset.
			Fqdn *[]string `json:"fqdn,omitempty"`

			// The UUID of the asset.
			Id *string `json:"id,omitempty"`

			// A list of ipv4 addresses for the asset.
			Ipv4 *[]string `json:"ipv4,omitempty"`

			// A list of ipv6 addresses for the asset.
			Ipv6 *[]string `json:"ipv6,omitempty"`

			// The ISO timestamp of the scan that most recently detected the asset.
			LastSeen *string `json:"last_seen,omitempty"`

			// The NetBIOS name for the asset.
			NetbiosName *[]string `json:"netbios_name,omitempty"`

			// A count of vulnerabilities by severity.
			Severities *[]struct {
				// The number of vulnerabilities with the specified severity.
				Count *int `json:"count,omitempty"`

				// The code for the severity. Possible values include:
				//  - 0The vulnerability has a CVSS score of 0, which corresponds to the "info" severity level.
				//  - 1The vulnerability has a CVSS score between 0.1 and 3.9, which corresponds to the "low" severity level.
				//  - 2The vulnerability has a CVSS score between 4.0 and 6.9, which corresponds to the "medium" severity level.
				//  - 3The vulnerability has a CVSS score between 7.0 and 9.9, which corresponds to the "high" severity level.
				//  - 4The vulnerability has a CVSS score of 10.0, which corresponds to the "critical" severity level.
				Level *int `json:"level,omitempty"`

				// The severity of the vulnerability as defined using the Common Vulnerability Scoring System (CVSS) base score. Possible values include `info` (CVSS score of 0), `low` (CVSS score between 0.1 and 3.9), `medium` (CVSS score between 4.0 and 6.9), `high` (CVSS score between 7.0 and 9.9), and `critical` (CVSS score of 10.0).
				Name *string `json:"name,omitempty"`
			} `json:"severities,omitempty"`

			// The total number of vulnerabilities detected on the asset.
			Total *int `json:"total,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkbenchesAssetInfoResponse parses an HTTP response from a WorkbenchesAssetInfoWithResponse call
func ParseWorkbenchesAssetInfoResponse(rsp *http.Response) (*WorkbenchesAssetInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesAssetInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Info *struct {
				// The key drivers that Tenable uses to calculate an asset's Tenable-provided ACR. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
				//
				// This attribute is only present if you have a Lumin license.
				AcrDrivers *[]struct {
					// The type of characteristic.
					DriverName *string `json:"driver_name,omitempty"`

					// The characteristic value.
					DriverValue *[]string `json:"driver_value,omitempty"`
				} `json:"acr_drivers,omitempty"`

				// The Asset Criticality Rating (ACR) for the asset. Tenable assigns an ACR to each asset on your network to represent the asset's relative risk as an integer from 1 to 10. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
				//
				// This attribute is only present if you have a Lumin license.
				AcrScore *int `json:"acr_score,omitempty"`

				// The names of any Nessus agents that scanned and identified the asset.
				AgentName *[]string `json:"agent_name,omitempty"`

				// The availability zone where Amazon Web Services hosts the virtual machine instance, for example, `us-east-1a`. Availability zones are subdivisions of AWS regions. For more information, see Regions and Availability Zones in the AWS documentation.
				AwsAvailabilityZone *[]string `json:"aws_availability_zone,omitempty"`

				// The unique identifier of the Linux AMI image in Amazon Elastic Compute Cloud (Amazon EC2). For more information, see the Amazon Elastic Compute Cloud Documentation.
				AwsEc2InstanceAmiId *[]string `json:"aws_ec2_instance_ami_id,omitempty"`

				// The virtual machine instance's group in AWS.
				AwsEc2InstanceGroupName *[]string `json:"aws_ec2_instance_group_name,omitempty"`

				// The unique identifier of the Linux instance in Amazon EC2. For more information, see the Amazon Elastic Compute Cloud Documentation.
				AwsEc2InstanceId *[]string `json:"aws_ec2_instance_id,omitempty"`

				// The state of the virtual machine instance in AWS at the time of the scan. For more information on instance states, see the AWS documentation.
				AwsEc2InstanceStateName *[]string `json:"aws_ec2_instance_state_name,omitempty"`

				// The type of instance in AWS EC2.
				AwsEc2InstanceType *[]string `json:"aws_ec2_instance_type,omitempty"`

				// The name of the virtual machine instance in AWS EC2.
				AwsEc2Name *[]string `json:"aws_ec2_name,omitempty"`

				// The product code associated with the AMI used to launch the virtual machine instance in AWS EC2.
				AwsEc2ProductCode *[]string `json:"aws_ec2_product_code,omitempty"`

				// The canonical user identifier for the AWS account associated with the virtual machine instance. For example, `79a59df900b949e55d96a1e698fbacedfd6e09d98eacf8f8d5218e7cd47ef2be`. For more information, see AWS Account Identifiers in the AWS documentation.
				AwsOwnerId *[]string `json:"aws_owner_id,omitempty"`

				// The region where AWS hosts the virtual machine instance, for example, `us-east-1`. For more information, see Regions and Availability Zones in the AWS documentation.
				AwsRegion *[]string `json:"aws_region,omitempty"`

				// The unique identifier of the AWS subnet where the virtual machine instance was running at the time of the scan.
				AwsSubnetId *[]string `json:"aws_subnet_id,omitempty"`

				// The unique identifier for the public cloud that hosts the AWS virtual machine instance. For more information, see the Amazon Virtual Private Cloud User Guide.
				AwsVpcId *[]string `json:"aws_vpc_id,omitempty"`

				// The unique identifier of the resource in the Azure Resource Manager. For more information, see the Azure Resource Manager Documentation.
				AzureResourceId *[]string `json:"azure_resource_id,omitempty"`

				// The unique identifier of the Microsoft Azure virtual machine instance. For more information, see "Accessing and Using Azure VM Unique ID" in the Microsoft Azure documentation.
				AzureVmId *[]string `json:"azure_vm_id,omitempty"`

				// The BIOS UUID that scans have associated with the asset.
				BiosUuid *[]string `json:"bios_uuid,omitempty"`

				// Counts of vulnerabilities on the asset, as well as counts of audit checks performed on the asset. For more information about this object, see [Common Asset Attributes](doc:common-asset-attributes).
				Counts *map[string]interface{} `json:"counts,omitempty"`

				// The time and date when Tenable.io created the asset record.
				CreatedAt *string `json:"created_at,omitempty"`

				// The Asset Exposure Score (AES) for the asset. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
				//
				// This attribute is only present if you have a Lumin license.
				ExposureScore *int `json:"exposure_score,omitempty"`

				// The time and date when a scan first identified the asset.
				FirstSeen *string `json:"first_seen,omitempty"`

				// The fully-qualified domain names that scans have associated with the asset record.
				Fqdn *[]string `json:"fqdn,omitempty"`

				// The unique identifier of the virtual machine instance in GCP.
				GcpInstanceId *[]string `json:"gcp_instance_id,omitempty"`

				// The customized name of the project to which the virtual machine instance belongs in Google Cloud Platform (GCP). For more information, see "Creating and Managing Projects" in the GCP documentation.
				GcpProjectId *[]string `json:"gcp_project_id,omitempty"`

				// The zone where the virtual machine instance runs in GCP. For more information, see "Regions and Zones" in the GCP documentation.
				GcpZone *[]string `json:"gcp_zone,omitempty"`

				// A value specifying whether a Nessus agent scan detected the asset.
				HasAgent *bool `json:"has_agent,omitempty"`

				// The hostnames that scans have associated with the asset record.
				Hostname *[]string `json:"hostname,omitempty"`

				// The UUID of the asset.
				Id *string `json:"id,omitempty"`

				// A list of Common Platform Enumeration (CPE) values that represent software applications a scan identified as present on an asset. This attribute supports the CPE 2.2 format. For more information, see the "Component Syntax" section of the [CPE Specification, Version 2.2](https://cpe.mitre.org/files/cpe-specification_2.2.pdf). For assets identified in Tenable scans, this attribute contains data only if a scan using [Nessus Plugin ID 45590](https://www.tenable.com/plugins/nessus/45590) has evaluated the asset.
				//
				// **Note:** If no scan detects an application within 30 days of the scan that originally detected the application, Tenable.io considers the detection of that application expired. As a result, the next time a scan evaluates the asset, Tenable.io removes the expired application from the installed_software attribute. This activity is logged as a `remove` type of `attribute_change` update in the asset activity log.
				InstalledSoftware *[]string `json:"installed_software,omitempty"`

				// The IPv4 addresses that scans have associated with the asset record.
				Ipv4 *[]string `json:"ipv4,omitempty"`

				// The IPv6 addresses that scans have associated with the asset record.
				Ipv6 *[]string `json:"ipv6,omitempty"`

				// The time and date of the last credentialed scan run on the asset.
				LastAuthenticatedScanDate *string `json:"last_authenticated_scan_date,omitempty"`

				// The time and date of the last scan that identified the asset as licensed. Tenable.io categorizes an asset as licensed if a scan of that asset has returned results from a non-discovery plugin within the last 90 days.
				LastLicensedScanDate *string `json:"last_licensed_scan_date,omitempty"`

				// The IPv4 address, IPv6 address, or FQDN that the scanner last used to evaluate the asset.
				LastScanTarget *string `json:"last_scan_target,omitempty"`

				// The time and date of the scan that most recently identified the asset.
				LastSeen *string `json:"last_seen,omitempty"`

				// The MAC addresses that scans have associated with the asset record.
				MacAddress *[]string `json:"mac_address,omitempty"`

				// The unique identifier of the McAfee ePO agent that identified the asset. For more information, see the McAfee documentation.
				McafeeEpoAgentGuid *[]string `json:"mcafee_epo_agent_guid,omitempty"`

				// The unique identifier of the asset in McAfee ePolicy Orchestrator (ePO). For more information, see the McAfee documentation.
				McafeeEpoGuid *[]string `json:"mcafee_epo_guid,omitempty"`

				// The NetBIOS names that scans have associated with the asset record.
				NetbiosName *[]string `json:"netbios_name,omitempty"`

				// The operating systems that scans have associated with the asset record.
				OperatingSystem *[]string `json:"operating_system,omitempty"`

				// The Asset ID of the asset in Qualys. For more information, see the Qualys documentation.
				QualysAssetId *[]string `json:"qualys_asset_id,omitempty"`

				// The Host ID of the asset in Qualys. For more information, see the Qualys documentation.
				QualysHostId *[]string `json:"qualys_host_id,omitempty"`

				// Information about how often scans ran against the asset during specified intervals. For more information, see [Lumin Metrics](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminMetrics.htm) in the *Tenable.io Vulnerability Management User Guide*.
				//
				// This attribute is only present if you have a Lumin license.
				ScanFrequency *[]struct {
					// The number of times that a scan ran against the asset during the specified interval.
					Frequency *int `json:"frequency,omitempty"`

					// The number of days over which Tenable searches for scans involving the asset.
					Interval *int `json:"interval,omitempty"`

					// Indicates whether the asset was licensed at the time of the identified scans.
					Licensed *bool `json:"licensed,omitempty"`
				} `json:"scan_frequency,omitempty"`

				// The unique record identifier of the asset in ServiceNow. For more information, see the ServiceNow documentation.
				ServicenowSysid *[]string `json:"servicenow_sysid,omitempty"`

				// The sources of the scans that identified the asset.
				Sources *[]struct {
					// The ISO timestamp when the source first reported the asset.
					FirstSeen *string `json:"first_seen,omitempty"`

					// The ISO timestamp when the source last reported the asset.
					LastSeen *string `json:"last_seen,omitempty"`

					// The name of the entity that reported the asset details. Sources can include sensors, connectors, and API imports. Source names can be customized by your organization (for example, you specify a name when you import asset records). If your organization does not customize source names, system-generated names include:
					//  - AWSYou obtained the asset data from an Amazon Web Services connector.
					//  - NESSUS_AGENTYou obtained the asset data obtained from a Nessus agent scan.
					//  - PVSYou obtained the asset data from a Nessus Network Monitor (NNM) scan.
					//  - NESSUS_SCANYou obtained the asset data from a Nessus scan.
					//  - WASYou obtained the asset data from a  Web Application Scanning scan.
					Name *string `json:"name,omitempty"`
				} `json:"sources,omitempty"`

				// The SSH key fingerprints that scans have associated with the asset record.
				SshFingerprint *[]string `json:"ssh_fingerprint,omitempty"`

				// The system types as reported by Plugin ID 54615. Possible values include `router`, `general-purpose`, `scan-host`, and `embedded`.
				SystemType *[]string `json:"system_type,omitempty"`

				// Category tags assigned to the asset in Tenable.io.
				Tags *[]struct {
					// The ISO timestamp when the tag was assigned to the asset.
					AddedAt *string `json:"added_at,omitempty"`

					// The UUID of the user who assigned the tag to the asset.
					AddedBy *string `json:"added_by,omitempty"`

					// The tag type:
					//  - staticA user manually applied the tag to an asset. You can use the Tenable.io API to create and assign static tags to assets.
					//  - dynamicTenable.io automatically applies the tag based on asset attribute rules. For more information, see [Apply Dynamic Tags](doc:apply-dynamic-tags).
					Source *string `json:"source,omitempty"`

					// The tag category (the first half of the category:value pair).
					TagKey *string `json:"tag_key,omitempty"`

					// The UUID of the tag.
					TagUuid *string `json:"tag_uuid,omitempty"`

					// The tag value (the second half of the category:value pair).
					TagValue *string `json:"tag_value,omitempty"`
				} `json:"tags,omitempty"`

				// The UUID of the agent if an agent is present on the asset. If no agent is present on the asset, then the UUID is a unique identifier assigned by Tenable.io during a credentialed scan when the [Create unique identifier on hosts scanned with credentials](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/Classic/AdvancedSettings.htm) option is enabled. Note that no UUID is set for uncredentialed, non-agent scans.
				TenableUuid *[]string `json:"tenable_uuid,omitempty"`

				// The scan end timestamp, in ISO-8601 format, when the asset was first detected.
				TimeEnd *string `json:"time_end,omitempty"`

				// The scan start timestamp, in ISO-8601 format, when the asset was first detected.
				TimeStart *string `json:"time_start,omitempty"`

				// The time and date when the asset record was last updated.
				UpdatedAt *string `json:"updated_at,omitempty"`

				// The UUID of the asset. Use this value as the unique key for the asset.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"info,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkbenchesAssetVulnerabilitiesResponse parses an HTTP response from a WorkbenchesAssetVulnerabilitiesWithResponse call
func ParseWorkbenchesAssetVulnerabilitiesResponse(rsp *http.Response) (*WorkbenchesAssetVulnerabilitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesAssetVulnerabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The total number of assets.
			TotalAssetCount *int `json:"total_asset_count,omitempty"`

			// The total number of discovered vulnerabilities.
			TotalVulnerabilityCount *int `json:"total_vulnerability_count,omitempty"`

			// A list of discovered vulnerabilities.
			Vulnerabilities *[]struct {
				// The number of times that a user in the user interface created an accept rule for this vulnerability. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/AboutRecastRules.htm" target="_blank">Recast Rules</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
				AcceptedCount *int32 `json:"accepted_count,omitempty"`

				// The number of times that a scan detected the vulnerability on an asset.
				Count *int `json:"count,omitempty"`

				// The number of times that a scan detected the vulnerability on an asset, grouped by severity level.
				CountsBySeverity *[]struct {
					// The number of times that a scan detected the vulnerability on an asset while the vulnerability was assigned the specified severity level.
					Count *int32 `json:"count,omitempty"`

					// The severity level of the vulnerabilities in the group.
					Value *int `json:"value,omitempty"`
				} `json:"counts by severity,omitempty"`

				// The plugin's family.
				PluginFamily *string `json:"plugin_family,omitempty"`

				// The unique plugin ID.
				PluginId *int `json:"plugin_id,omitempty"`

				// The name of the plugin that detected the vulnerability.
				PluginName *string `json:"plugin_name,omitempty"`

				// The number of times that a user in the user interface created a recast rule for this vulnerability. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/AboutRecastRules.htm" target="_blank">Recast Rules</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
				RecastedCount *int32 `json:"recasted_count,omitempty"`

				// The severity level of the vulnerability, as defined using the Common Vulnerability Scoring System (CVSS) base score. Possible values include:
				//  - 0The vulnerability has a CVSS score of 0, which corresponds to the "info" severity level.
				//  - 1The vulnerability has a CVSS score between 0.1 and 3.9, which corresponds to the "low" severity level.
				//  - 2The vulnerability has a CVSS score between 4.0 and 6.9, which corresponds to the "medium" severity level.
				//  - 3The vulnerability has a CVSS score between 7.0 and 9.9, which corresponds to the "high" severity level.
				//  - 4The vulnerability has a CVSS score of 10.0, which corresponds to the "critical" severity level.
				Severity *int32 `json:"severity,omitempty"`

				// The Vulnerability Priority Rating (VPR) for the vulnerability. If a plugin is designed to detect multiple vulnerabilities, the VPR represents the highest value calculated for a vulnerability associated with the plugin. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/RiskMetrics.htm" target="_blank">Severity vs. VPR</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
				VprScore *float32 `json:"vpr_score,omitempty"`

				// The current state of the reported plugin. Possible states include:
				//  - ActiveThe vulnerability is currently present on an asset.
				//  - NewThe vulnerability is active on an asset, and was first detected within the last 14 days.
				//  - FixedA subsequent scan detected that the formerly-active vulnerability is no longer present on an asset.
				//  - ResurfacedThe vulnerability was previously marked as fixed on an asset, but a subsequent scan detected the vulnerability on the asset again.
				VulnerabilityState *string `json:"vulnerability_state,omitempty"`
			} `json:"vulnerabilities,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkbenchesAssetVulnerabilityInfoResponse parses an HTTP response from a WorkbenchesAssetVulnerabilityInfoWithResponse call
func ParseWorkbenchesAssetVulnerabilityInfoResponse(rsp *http.Response) (*WorkbenchesAssetVulnerabilityInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesAssetVulnerabilityInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Info *struct {
				// A count of the vulnerability occurrences.
				Count *int32 `json:"count,omitempty"`

				// The description of the vulnerability.
				Description *string `json:"description,omitempty"`
				Discovery   *struct {
					// The Unix timestamp of the scan that first detected the vulnerability on an asset.
					SeenFirst *string `json:"seen_first,omitempty"`

					// The Unix timestamp of the scan that most recently detected the vulnerability on an asset.
					SeenLast *string `json:"seen_last,omitempty"`
				} `json:"discovery,omitempty"`
				PluginDetails *struct {
					// The plugin family.
					Family *string `json:"family,omitempty"`

					// The ISO timestamp when Tenable last updated the plugin definition.
					ModificationDate *string `json:"modification_date,omitempty"`

					// The name of the plugin.
					Name *string `json:"name,omitempty"`

					// The ISO timestamp when Tenable first published the plugin definition.
					PublicationDate *string `json:"publication_date,omitempty"`

					// The severity level of the plugin.
					Severity *int32 `json:"severity,omitempty"`

					// The type of scan that uses the plugin, either a network scan (`remote`) or a credentialed scan (`local`).
					Type *string `json:"type,omitempty"`

					// The plugin version.
					Version *string `json:"version,omitempty"`
				} `json:"plugin_details,omitempty"`
				ReferenceInformation *[]struct {
					// The source of the reference information about the vulnerability. Possible values include:
					//  - bidBugtraq (Symantec Connect)
					//  - certCERT/CC Vulnerability Notes Database
					//  - cveNIST National Vulnerability Database (NVD)
					//  - edb-idThe Exploit Database
					//  - iavainformation assurance vulnerability alert
					//  - osvdbOpen Sourced Vulnerability Database
					Name *string `json:"name,omitempty"`

					// The URL of the source site, if available.
					Url *string `json:"url,omitempty"`

					// The unique identifier(s) for the vulnerability at the source.
					Values *[]string `json:"values,omitempty"`
				} `json:"reference_information,omitempty"`
				RiskInformation *struct {
					// The CVSSv3 base score (intrinsic and fundamental characteristics of a vulnerability that are constant over time and user environments).
					Cvss3BaseScore *string `json:"cvss3_base_score,omitempty"`

					// The CVSSv3 temporal score (characteristics of a vulnerability that change over time but not among user environments).
					Cvss3TemporalScore *string `json:"cvss3_temporal_score,omitempty"`

					// CVSSv3 temporal metrics for the vulnerability.
					Cvss3TemporalVector *string `json:"cvss3_temporal_vector,omitempty"`

					// The raw CVSSv3 metrics for the vulnerability. For more information, see CVSSv3 documentation.
					Cvss3Vector *string `json:"cvss3_vector,omitempty"`

					// The CVSSv2 base score (intrinsic and fundamental characteristics of a vulnerability that are constant over time and user environments).
					CvssBaseScore *string `json:"cvss_base_score,omitempty"`

					// The CVSSv2 temporal score (characteristics of a vulnerability that change over time but not among user environments).
					CvssTemporalScore *string `json:"cvss_temporal_score,omitempty"`

					// The raw CVSSv2 temporal metrics for the vulnerability.
					CvssTemporalVector *string `json:"cvss_temporal_vector,omitempty"`

					// The raw CVSSv2 metrics for the vulnerability. For more information, see CVSSv2 documentation.
					CvssVector *string `json:"cvss_vector,omitempty"`

					// The risk factor associated with the plugin. Possible values are: `Low`, `Medium`, `High`, or `Critical`. See the `risk_factor` attribute in [Tenable Plugin Attributes](doc:tenable-plugin-attributes).
					RiskFactor *string `json:"risk_factor,omitempty"`

					// Security Technical Implementation Guide (STIG) severity code for the vulnerability.
					StigSeverity *string `json:"stig_severity,omitempty"`
				} `json:"risk_information,omitempty"`

				// Links to external websites that contain helpful information about the vulnerability.
				SeeAlso *[]string `json:"see_also,omitempty"`

				// The severity level of the vulnerability.
				Severity *int `json:"severity,omitempty"`

				// Information on how to fix the vulnerability.
				Solution *string `json:"solution,omitempty"`

				// A brief summary of the vulnerability.
				Synopsis *string `json:"synopsis,omitempty"`

				// Information about the Vulnerability Priority Rating (VPR) for the vulnerability.
				Vpr *struct {
					// The key drivers Tenable uses to calculate a vulnerability's VPR. For more information, see <[Vulnerability Priority Rating Drivers](doc:vpr-drivers-tio).
					Drivers *map[string]interface{} `json:"drivers,omitempty"`

					// The Vulnerability Priority Rating (VPR) for the vulnerability. If a plugin is designed to detect multiple vulnerabilities, the VPR represents the highest value calculated for a vulnerability associated with the plugin. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/RiskMetrics.htm" target="_blank">Severity vs. VPR</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
					Score *float32 `json:"score,omitempty"`

					// The ISO timestamp when Tenable.io last imported the VPR for this vulnerability. Tenable.io imports a VPR value the first time you scan a vulnerability on your network. Then, Tenable.io automatically re-imports new and updated VPR values daily.
					Updated *string `json:"updated,omitempty"`
				} `json:"vpr,omitempty"`
				VulnCount                *int32 `json:"vuln_count,omitempty"`
				VulnerabilityInformation *struct {
					AssetInventory *string `json:"asset_inventory,omitempty"`

					// The Common Platform Enumeration (CPE) number for the plugin.
					Cpe            *string `json:"cpe,omitempty"`
					DefaultAccount *string `json:"default_account,omitempty"`

					// A value specifying whether a public exploit exists for the vulnerability.
					ExploitAvailable *bool `json:"exploit_available,omitempty"`

					// A list of exploit frameworks that have identified the vulnerability.
					ExploitFrameworks *[]struct {
						// A list of exploits associated with the vulnerability in the specified exploit framework.
						Exploits *[]struct {
							// The name of the identified exploit.
							Name *string `json:"name,omitempty"`

							// The URL for the exploit in the framework.
							Url *string `json:"url,omitempty"`
						} `json:"exploits,omitempty"`

						// The name of the exploit framework.
						Name *string `json:"name,omitempty"`
					} `json:"exploit_frameworks,omitempty"`

					// Description of how easy it is to exploit the issue.
					ExploitabilityEase *string `json:"exploitability_ease,omitempty"`

					// The vulnerability discovered by this plugin is known to be exploited by malware.
					ExploitedByMalware *bool `json:"exploited_by_malware,omitempty"`

					// A value specifying whether Nessus exploited the vulnerability during the process of identification.
					ExploitedByNessus *bool `json:"exploited_by_nessus,omitempty"`

					// A value specifying whether this plugin has received media attention (for example, ShellShock, Meltdown).
					InTheNews *bool   `json:"in_the_news,omitempty"`
					Malware   *string `json:"malware,omitempty"`

					// The ISO timestamp for date on which the vendor published a patch for the vulnerability.
					PatchPublicationDate *string `json:"patch_publication_date,omitempty"`

					// Software found by this plugin is unsupported by the software's vendor (for example, Windows 95 or Firefox 3).
					UnsupportedByVendor *bool `json:"unsupported_by_vendor,omitempty"`

					// The ISO timestamp for the first publication date of the plugin.
					VulnerabilityPublicationDate *string `json:"vulnerability_publication_date,omitempty"`
				} `json:"vulnerability_information,omitempty"`
			} `json:"info,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkbenchesAssetVulnerabilityOutputResponse parses an HTTP response from a WorkbenchesAssetVulnerabilityOutputWithResponse call
func ParseWorkbenchesAssetVulnerabilityOutputResponse(rsp *http.Response) (*WorkbenchesAssetVulnerabilityOutputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesAssetVulnerabilityOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A list of vulnerabilities discovered by the plugin.
			Outputs *[]struct {
				// The plugin's output about the vulnerability. May be an empty string.
				PluginOutput *string `json:"plugin_output,omitempty"`

				// Vulnerability state items.
				States *[]struct {
					// The current state of the reported plugin (Active, Fixed, New, etc.)
					Name    *string `json:"name,omitempty"`
					Results *[]struct {
						// The application protocol where this vulnerability was found.
						ApplicationProtocol *string `json:"application_protocol,omitempty"`

						// A list of assets where this output was found.
						Assets *[]struct {
							// Indicates when the asset was discovered by a scan.
							FirstSeen *time.Time `json:"first_seen,omitempty"`

							// The FQDN of the asset.
							Fqdn *string `json:"fqdn,omitempty"`

							// The host name of the asset.
							Hostname *string `json:"hostname,omitempty"`

							// The ID of the asset.
							Id *string `json:"id,omitempty"`

							// The IPV4 of the asset.
							Ipv4 *string `json:"ipv4,omitempty"`

							// Indicates when the asset was last observed by a scan.
							LastSeen *time.Time `json:"last_seen,omitempty"`

							// The NetBios name of the asset.
							NetbiosName *string `json:"netbios_name,omitempty"`

							// The UUID of the asset. Use this value as the unique key for the asset.
							Uuid *string `json:"uuid,omitempty"`
						} `json:"assets,omitempty"`

						// The port number where this vulnerability was found.
						Port *int `json:"port,omitempty"`

						// Integer [0-4] indicating how severe the vulnerability is, where 0 is info only.
						Severity *int `json:"severity,omitempty"`

						// The transportation protocol (TCP or UDP) where this vulnerability was found.
						TransportProtocol *string `json:"transport_protocol,omitempty"`
					} `json:"results,omitempty"`
				} `json:"states,omitempty"`
			} `json:"outputs,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkbenchesAssetsDeleteResponse parses an HTTP response from a WorkbenchesAssetsDeleteWithResponse call
func ParseWorkbenchesAssetsDeleteResponse(rsp *http.Response) (*WorkbenchesAssetsDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesAssetsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseWorkbenchesAssetsActivityResponse parses an HTTP response from a WorkbenchesAssetsActivityWithResponse call
func ParseWorkbenchesAssetsActivityResponse(rsp *http.Response) (*WorkbenchesAssetsActivityResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesAssetsActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Details *struct {
				// The UUID of the asset.
				AssetId *string `json:"assetId,omitempty"`

				// The UUID of your Tenable.io instance.
				ContainerId *string `json:"containerId,omitempty"`

				// The timestamp of the asset creation. The timestamp is reported in ISO 8601 format in UTC time.
				CreatedAt *int `json:"createdAt,omitempty"`

				// If deleted, the timestamp of asset deletion. The timestamp is reported in ISO 8601 format in UTC time.
				DeletedAt *int `json:"deletedAt,omitempty"`

				// The UUID of the user that deleted the asset.
				DeletedBy *string `json:"deletedBy,omitempty"`

				// The timestamp of the completion of the scan that discovered or observed the asset for the first time. The timestamp is reported in ISO 8601 format in UTC time.
				FirstScanTime *int `json:"firstScanTime,omitempty"`

				// Specifies whether the asset has an agent installed.
				HasAgent *bool `json:"hasAgent,omitempty"`

				// Specifies whether or not any plugin results match this asset.
				HasPluginResults *bool `json:"hasPluginResults,omitempty"`

				// The timestamp of the completion of the last authenticated scan of the asset. The timestamp is reported in ISO 8601 format in UTC time.
				LastAuthenticatedScanTime *int `json:"lastAuthenticatedScanTime,omitempty"`

				// The timestamp of the scan completion time when asset was last scanned and matched license v1 requirements. The timestamp is reported in ISO 8601 format in UTC time.
				LastLicensedScanTime *int `json:"lastLicensedScanTime,omitempty"`

				// The timestamp of the scan completion time when asset was last scanned and matched license v2 requirements. The timestamp is reported in ISO 8601 format in UTC time.
				LastLicensedScanTimeV2 *int `json:"lastLicensedScanTimeV2,omitempty"`

				// The timestamp of the completion of the last asset scan. The timestamp is reported in ISO 8601 format in UTC time.
				LastScanTime *int `json:"lastScanTime,omitempty"`

				// Additional asset attributes. For attribute definitions, see [Common Asset Attributes](doc:common-asset-attributes).
				Properties *map[string]interface{} `json:"properties,omitempty"`

				// An array of source objects representing the entity that logged the event.
				Sources *[]struct {
					// The ISO timestamp when the source first reported the asset.
					FirstSeen *string `json:"firstSeen,omitempty"`

					// The ISO timestamp when the source last reported the asset.
					LastSeen *string `json:"lastSeen,omitempty"`

					// The name of the entity that reported the asset details. Sources can include sensors, connectors, and API imports. Source names can be customized by your organization (for example, you specify a name when you import asset records). If your organization does not customize source names, system-generated names include:
					//  - AWSYou obtained the asset data from an Amazon Web Services connector.
					//  - NESSUS_AGENTYou obtained the asset data obtained from a Nessus agent scan.
					//  - PVSYou obtained the asset data from a Nessus Network Monitor (NNM) scan.
					//  - NESSUS_SCANYou obtained the asset data from a Nessus scan.
					//  - WASYou obtained the asset data from a  Web Application Scanning scan.
					Name *string `json:"name,omitempty"`
				} `json:"sources,omitempty"`

				// If terminated, the timestamp of asset termination. The timestamp is reported in ISO 8601 format in UTC time.
				TerminatedAt *int `json:"terminatedAt,omitempty"`

				// The UUID of the user that terminated the asset.
				TerminatedBy *string `json:"terminatedBy,omitempty"`

				// The timestamp of the asset update time. The timestamp is reported in ISO 8601 format in UTC time.
				UpdatedAt *int `json:"updatedAt,omitempty"`
			} `json:"details,omitempty"`

			// The UUID of the scan that logged the event.
			ScanId *string `json:"scan_id,omitempty"`

			// The ID of the scheduled scan associated with the event.
			ScheduleId *string `json:"schedule_id,omitempty"`

			// The entity that logged the event, for example, NESSUS_AGENT, NESSUS_AGENT, PVS, or WAS.
			Source *string `json:"source,omitempty"`

			// The timestamp of the event. The timestamp is reported in ISO 8601 format in UTC time.
			Timestamp *int `json:"timestamp,omitempty"`

			// Event type:
			//  - discoveredAsset created (for example, by a network scan or import).
			//  - seenAsset observed by a network scan without any changes to its attributes.
			//  - taggingTag added to or removed from asset.
			//  - attribute_changeA scan identified new or changed attributes for the asset (for example, new software applications installed on the asset).
			//  - updatedAsset updated either manually by a user or automatically by a new scan.
			Type *string `json:"type,omitempty"`

			// (attribute_change entries only) A list of updates to the asset's attributes.
			Updates *[]struct {
				// The update method. Possible values include:
				//  - addA scan identified a new software application installed on the asset.
				//  - removeTenable.io identified the specified application as expired and removed it from the installed_software attribute of the asset. Tenable.io considers an application detection expired if no scan detects the application within 30 days of the scan that originally detected the application.
				Method *string `json:"method,omitempty"`

				// The name of the updated attribute.
				Property *string `json:"property,omitempty"`

				// The updated value of the attribute.
				Value *string `json:"value,omitempty"`
			} `json:"updates,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkbenchesExportRequestResponse parses an HTTP response from a WorkbenchesExportRequestWithResponse call
func ParseWorkbenchesExportRequestResponse(rsp *http.Response) (*WorkbenchesExportRequestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesExportRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The ID of the generated file.
			File *int `json:"file,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Standard HTTP error name, or a brief message about the cause of the error.
			Error *string `json:"error,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseWorkbenchesExportDownloadResponse parses an HTTP response from a WorkbenchesExportDownloadWithResponse call
func ParseWorkbenchesExportDownloadResponse(rsp *http.Response) (*WorkbenchesExportDownloadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesExportDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWorkbenchesExportStatusResponse parses an HTTP response from a WorkbenchesExportStatusWithResponse call
func ParseWorkbenchesExportStatusResponse(rsp *http.Response) (*WorkbenchesExportStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesExportStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The number of already processed items.
			Progress *string `json:"progress,omitempty"`

			// The total number of items included in export.
			ProgressTotal *string `json:"progress_total,omitempty"`

			// The export processing status, for example, READY or LOADING.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkbenchesVulnerabilitiesResponse parses an HTTP response from a WorkbenchesVulnerabilitiesWithResponse call
func ParseWorkbenchesVulnerabilitiesResponse(rsp *http.Response) (*WorkbenchesVulnerabilitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesVulnerabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// The total number of assets.
			TotalAssetCount *int `json:"total_asset_count,omitempty"`

			// The total number of discovered vulnerabilities.
			TotalVulnerabilityCount *int `json:"total_vulnerability_count,omitempty"`

			// A list of discovered vulnerabilities.
			Vulnerabilities *[]struct {
				// The number of times that a user in the user interface created an accept rule for this vulnerability. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/AboutRecastRules.htm" target="_blank">Recast Rules</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
				AcceptedCount *int32 `json:"accepted_count,omitempty"`

				// The number of times that a scan detected the vulnerability on an asset.
				Count *int `json:"count,omitempty"`

				// The number of times that a scan detected the vulnerability on an asset, grouped by severity level.
				CountsBySeverity *[]struct {
					// The number of times that a scan detected the vulnerability on an asset while the vulnerability was assigned the specified severity level.
					Count *int32 `json:"count,omitempty"`

					// The severity level of the vulnerabilities in the group.
					Value *int `json:"value,omitempty"`
				} `json:"counts by severity,omitempty"`

				// The plugin's family.
				PluginFamily *string `json:"plugin_family,omitempty"`

				// The unique plugin ID.
				PluginId *int `json:"plugin_id,omitempty"`

				// The name of the plugin that detected the vulnerability.
				PluginName *string `json:"plugin_name,omitempty"`

				// The number of times that a user in the user interface created a recast rule for this vulnerability. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/AboutRecastRules.htm" target="_blank">Recast Rules</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
				RecastedCount *int32 `json:"recasted_count,omitempty"`

				// The severity level of the vulnerability, as defined using the Common Vulnerability Scoring System (CVSS) base score. Possible values include:
				//  - 0The vulnerability has a CVSS score of 0, which corresponds to the "info" severity level.
				//  - 1The vulnerability has a CVSS score between 0.1 and 3.9, which corresponds to the "low" severity level.
				//  - 2The vulnerability has a CVSS score between 4.0 and 6.9, which corresponds to the "medium" severity level.
				//  - 3The vulnerability has a CVSS score between 7.0 and 9.9, which corresponds to the "high" severity level.
				//  - 4The vulnerability has a CVSS score of 10.0, which corresponds to the "critical" severity level.
				Severity *int32 `json:"severity,omitempty"`

				// The Vulnerability Priority Rating (VPR) for the vulnerability. If a plugin is designed to detect multiple vulnerabilities, the VPR represents the highest value calculated for a vulnerability associated with the plugin. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/RiskMetrics.htm" target="_blank">Severity vs. VPR</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
				VprScore *float32 `json:"vpr_score,omitempty"`

				// The current state of the reported plugin. Possible states include:
				//  - ActiveThe vulnerability is currently present on an asset.
				//  - NewThe vulnerability is active on an asset, and was first detected within the last 14 days.
				//  - FixedA subsequent scan detected that the formerly-active vulnerability is no longer present on an asset.
				//  - ResurfacedThe vulnerability was previously marked as fixed on an asset, but a subsequent scan detected the vulnerability on the asset again.
				VulnerabilityState *string `json:"vulnerability_state,omitempty"`
			} `json:"vulnerabilities,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkbenchesVulnerabilityInfoResponse parses an HTTP response from a WorkbenchesVulnerabilityInfoWithResponse call
func ParseWorkbenchesVulnerabilityInfoResponse(rsp *http.Response) (*WorkbenchesVulnerabilityInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesVulnerabilityInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// A count of the vulnerability occurrences.
			Count *int32 `json:"count,omitempty"`

			// The description of the vulnerability.
			Description *string `json:"description,omitempty"`
			Discovery   *struct {
				// The Unix timestamp of the scan that first detected the vulnerability on an asset.
				SeenFirst *string `json:"seen_first,omitempty"`

				// The Unix timestamp of the scan that most recently detected the vulnerability on an asset.
				SeenLast *string `json:"seen_last,omitempty"`
			} `json:"discovery,omitempty"`
			PluginDetails *struct {
				// The plugin family.
				Family *string `json:"family,omitempty"`

				// The ISO timestamp when Tenable last updated the plugin definition.
				ModificationDate *string `json:"modification_date,omitempty"`

				// The name of the plugin.
				Name *string `json:"name,omitempty"`

				// The ISO timestamp when Tenable first published the plugin definition.
				PublicationDate *string `json:"publication_date,omitempty"`

				// The severity level of the plugin.
				Severity *int32 `json:"severity,omitempty"`

				// The type of scan that uses the plugin, either a network scan (`remote`) or a credentialed scan (`local`).
				Type *string `json:"type,omitempty"`

				// The plugin version.
				Version *string `json:"version,omitempty"`
			} `json:"plugin_details,omitempty"`
			ReferenceInformation *[]struct {
				// The source of the reference information about the vulnerability. Possible values include:
				//  - bidBugtraq (Symantec Connect)
				//  - certCERT/CC Vulnerability Notes Database
				//  - cveNIST National Vulnerability Database (NVD)
				//  - edb-idThe Exploit Database
				//  - iavainformation assurance vulnerability alert
				//  - osvdbOpen Sourced Vulnerability Database
				Name *string `json:"name,omitempty"`

				// The URL of the source site, if available.
				Url *string `json:"url,omitempty"`

				// The unique identifier(s) for the vulnerability at the source.
				Values *[]string `json:"values,omitempty"`
			} `json:"reference_information,omitempty"`
			RiskInformation *struct {
				// The CVSSv3 base score (intrinsic and fundamental characteristics of a vulnerability that are constant over time and user environments).
				Cvss3BaseScore *string `json:"cvss3_base_score,omitempty"`

				// The CVSSv3 temporal score (characteristics of a vulnerability that change over time but not among user environments).
				Cvss3TemporalScore *string `json:"cvss3_temporal_score,omitempty"`

				// CVSSv3 temporal metrics for the vulnerability.
				Cvss3TemporalVector *string `json:"cvss3_temporal_vector,omitempty"`

				// The raw CVSSv3 metrics for the vulnerability. For more information, see CVSSv3 documentation.
				Cvss3Vector *string `json:"cvss3_vector,omitempty"`

				// The CVSSv2 base score (intrinsic and fundamental characteristics of a vulnerability that are constant over time and user environments).
				CvssBaseScore *string `json:"cvss_base_score,omitempty"`

				// The CVSSv2 temporal score (characteristics of a vulnerability that change over time but not among user environments).
				CvssTemporalScore *string `json:"cvss_temporal_score,omitempty"`

				// The raw CVSSv2 temporal metrics for the vulnerability.
				CvssTemporalVector *string `json:"cvss_temporal_vector,omitempty"`

				// The raw CVSSv2 metrics for the vulnerability. For more information, see CVSSv2 documentation.
				CvssVector *string `json:"cvss_vector,omitempty"`

				// The risk factor associated with the plugin. Possible values are: `Low`, `Medium`, `High`, or `Critical`. See the `risk_factor` attribute in [Tenable Plugin Attributes](doc:tenable-plugin-attributes).
				RiskFactor *string `json:"risk_factor,omitempty"`

				// Security Technical Implementation Guide (STIG) severity code for the vulnerability.
				StigSeverity *string `json:"stig_severity,omitempty"`
			} `json:"risk_information,omitempty"`

			// Links to external websites that contain helpful information about the vulnerability.
			SeeAlso *[]string `json:"see_also,omitempty"`

			// The severity level of the vulnerability.
			Severity *int `json:"severity,omitempty"`

			// Information on how to fix the vulnerability.
			Solution *string `json:"solution,omitempty"`

			// A brief summary of the vulnerability.
			Synopsis *string `json:"synopsis,omitempty"`

			// Information about the Vulnerability Priority Rating (VPR) for the vulnerability.
			Vpr *struct {
				// The key drivers Tenable uses to calculate a vulnerability's VPR. For more information, see <[Vulnerability Priority Rating Drivers](doc:vpr-drivers-tio).
				Drivers *map[string]interface{} `json:"drivers,omitempty"`

				// The Vulnerability Priority Rating (VPR) for the vulnerability. If a plugin is designed to detect multiple vulnerabilities, the VPR represents the highest value calculated for a vulnerability associated with the plugin. For more information, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/RiskMetrics.htm" target="_blank">Severity vs. VPR</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
				Score *float32 `json:"score,omitempty"`

				// The ISO timestamp when Tenable.io last imported the VPR for this vulnerability. Tenable.io imports a VPR value the first time you scan a vulnerability on your network. Then, Tenable.io automatically re-imports new and updated VPR values daily.
				Updated *string `json:"updated,omitempty"`
			} `json:"vpr,omitempty"`
			VulnCount                *int32 `json:"vuln_count,omitempty"`
			VulnerabilityInformation *struct {
				AssetInventory *string `json:"asset_inventory,omitempty"`

				// The Common Platform Enumeration (CPE) number for the plugin.
				Cpe            *string `json:"cpe,omitempty"`
				DefaultAccount *string `json:"default_account,omitempty"`

				// A value specifying whether a public exploit exists for the vulnerability.
				ExploitAvailable *bool `json:"exploit_available,omitempty"`

				// A list of exploit frameworks that have identified the vulnerability.
				ExploitFrameworks *[]struct {
					// A list of exploits associated with the vulnerability in the specified exploit framework.
					Exploits *[]struct {
						// The name of the identified exploit.
						Name *string `json:"name,omitempty"`

						// The URL for the exploit in the framework.
						Url *string `json:"url,omitempty"`
					} `json:"exploits,omitempty"`

					// The name of the exploit framework.
					Name *string `json:"name,omitempty"`
				} `json:"exploit_frameworks,omitempty"`

				// Description of how easy it is to exploit the issue.
				ExploitabilityEase *string `json:"exploitability_ease,omitempty"`

				// The vulnerability discovered by this plugin is known to be exploited by malware.
				ExploitedByMalware *bool `json:"exploited_by_malware,omitempty"`

				// A value specifying whether Nessus exploited the vulnerability during the process of identification.
				ExploitedByNessus *bool `json:"exploited_by_nessus,omitempty"`

				// A value specifying whether this plugin has received media attention (for example, ShellShock, Meltdown).
				InTheNews *bool   `json:"in_the_news,omitempty"`
				Malware   *string `json:"malware,omitempty"`

				// The ISO timestamp for date on which the vendor published a patch for the vulnerability.
				PatchPublicationDate *string `json:"patch_publication_date,omitempty"`

				// Software found by this plugin is unsupported by the software's vendor (for example, Windows 95 or Firefox 3).
				UnsupportedByVendor *bool `json:"unsupported_by_vendor,omitempty"`

				// The ISO timestamp for the first publication date of the plugin.
				VulnerabilityPublicationDate *string `json:"vulnerability_publication_date,omitempty"`
			} `json:"vulnerability_information,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkbenchesVulnerabilityOutputResponse parses an HTTP response from a WorkbenchesVulnerabilityOutputWithResponse call
func ParseWorkbenchesVulnerabilityOutputResponse(rsp *http.Response) (*WorkbenchesVulnerabilityOutputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkbenchesVulnerabilityOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// The plugin's output about the vulnerability. May be an empty string.
			PluginOutput *string `json:"plugin_output,omitempty"`

			// Vulnerability state items.
			States *[]struct {
				// The current state of the reported plugin (Active, Fixed, New, etc.)
				Name    *string `json:"name,omitempty"`
				Results *[]struct {
					// The application protocol where this vulnerability was found.
					ApplicationProtocol *string `json:"application_protocol,omitempty"`

					// A list of assets where this output was found.
					Assets *[]struct {
						// Indicates when the asset was discovered by a scan.
						FirstSeen *time.Time `json:"first_seen,omitempty"`

						// The FQDN of the asset.
						Fqdn *string `json:"fqdn,omitempty"`

						// The host name of the asset.
						Hostname *string `json:"hostname,omitempty"`

						// The ID of the asset.
						Id *string `json:"id,omitempty"`

						// The IPV4 of the asset.
						Ipv4 *string `json:"ipv4,omitempty"`

						// Indicates when the asset was last observed by a scan.
						LastSeen *time.Time `json:"last_seen,omitempty"`

						// The NetBios name of the asset.
						NetbiosName *string `json:"netbios_name,omitempty"`

						// The UUID of the asset. Use this value as the unique key for the asset.
						Uuid *string `json:"uuid,omitempty"`
					} `json:"assets,omitempty"`

					// The port number where this vulnerability was found.
					Port *int `json:"port,omitempty"`

					// Integer [0-4] indicating how severe the vulnerability is, where 0 is info only.
					Severity *int `json:"severity,omitempty"`

					// The transportation protocol (TCP or UDP) where this vulnerability was found.
					TransportProtocol *string `json:"transport_protocol,omitempty"`
				} `json:"results,omitempty"`
			} `json:"states,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
