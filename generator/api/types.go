// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.3 DO NOT EDIT.
package api

const (
	CloudScopes = "cloud.Scopes"
)

// IoV1AccessGroupsListParams defines parameters for IoV1AccessGroupsList.
type IoV1AccessGroupsListParams struct {
	// A filter condition in the following format: `field:operator:value`. For a list of possible fields and operators, use the [GET /access-groups/filters](ref:io-v1-access-groups-list-filters) endpoint. You can specify multiple `f` parameters, separated by ampersand (&) characters. If you specify multiple `f` parameters, use the `ft` parameter to specify how Tenable.io applies the multiple filter conditions.
	F *string `json:"f,omitempty"`

	// If multiple `f` parameters are present, specifies whether Tenable.io applies `AND` or `OR` to conditions. Supported values are `and` and `or`. If you omit this parameter when using multiple `f` parameters, Tenable.io applies `AND` by default.
	Ft *string `json:"ft,omitempty"`

	// The search value that Tenable.io applies across the wildcard fields. Wildcard fields are specified in the `wf` parameter.
	W *string `json:"w,omitempty"`

	// A comma-separated list of fields where Tenable.io applies the search value specified in the `w` parameter. For a list of supported wildcard fields, use the [GET /access-groups/filters](ref:io-v1-access-groups-list-filters) endpoint.
	Wf *string `json:"wf,omitempty"`

	// Specifies whether or not to include the `rules` and `principals` objects in the response. Tenable.io defaults to `false` if this parameter is omitted.
	Fullypopulateresponse *bool `json:"fullypopulateresponse,omitempty"`

	// The number of records to retrieve.
	Limit *int32 `json:"limit,omitempty"`

	// The starting record to retrieve. If this parameter is omitted, Tenable.io uses the default value of `0`.
	Offset *int32 `json:"offset,omitempty"`

	// The field you want to use to sort the results by along with the sort order. The field is specified first, followed by a colon, and the order is specified second (`asc` or `desc`). For example, `name:desc` would sort results by the `name` field in descending order.
	//
	// If you specify multiple fields, the fields must be separated by commas. For example, `name:desc,created_at:asc` would first sort results by the `name` field in descending order and then by the `created_at` field in ascending order.
	//
	// For a list of supported sort fields, use the [GET /access-groups/filters](ref:io-v1-access-groups-list-filters) endpoint.
	Sort *string `json:"sort,omitempty"`
}

// IoV1AccessGroupsCreateJSONBody defines parameters for IoV1AccessGroupsCreate.
type IoV1AccessGroupsCreateJSONBody struct {
	// This parameter must always be `false` or omitted from create requests to specify that the access group is a user-created group. If you submit a create request with this parameter set to `true`, the create request fails.
	AllAssets *bool `json:"all_assets,omitempty"`

	// Specifies whether assets in the access group can be viewed by all or only some users in your organization:
	// * If `true`, all users in your organization have Can View access to the assets defined in the rules parameter. Tenable.io ignores any principal parameters in your request.
	// * If `false`, only specified users have Can View access to the assets defined in the rules parameter. You define which users or user groups have access in the principals parameter of the request.
	//
	// If you omit this parameter, Tenable.io sets the parameter to `false` by default.
	AllUsers *bool `json:"all_users,omitempty"`

	// The name of the access group you want to create. This name must be:
	// * Unique within your Tenable.io instance.
	// * A maximum of 255 characters.
	// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
	//
	// **Note:** You can add a maximum of 5,000 access groups to an individual container.
	Name string `json:"name"`

	// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
	//
	// Tenable.io handles data in this array based on the `all_users` parameter of the request:
	// * If `all_users` is `true`, Tenable.io ignores any principal data in the request. You can omit this parameter from the request.
	// * If `all_users` is `false`, Tenable.io adds the principal data to the access group.
	Principals *[]struct {
		// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
		PrincipalId *string `json:"principal_id,omitempty"`

		// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
		PrincipalName *string `json:"principal_name,omitempty"`

		// (Required) The type of principal. Valid values include:
		//  - user—Grants access to the user you specify.
		//  - group—Grants access to all users assigned to the user group you specify.
		Type *string `json:"type,omitempty"`
	} `json:"principals,omitempty"`

	// An array of asset rules. Tenable.io uses these rules to assign assets to the access group. You can specify a maximum of 1,000 rules for an individual access group. If you specify multiple rules for an access group, Tenable.io assigns an asset to the access group if the asset matches any of the rules. You can only add rules to access groups if the `all_assets` parameter is set to `false`.
	Rules []struct {
		// The operator that specifies how Tenable.io matches the terms value to asset data.
		//
		// Possible operators include:
		//  - eq—Tenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
		//  - match—Tenable.io matches the rule to assets based a partial match of the specified term.
		//  - starts—Tenable.io matches the rule to assets that start with the specified term.
		//  - ends—Tenable.io matches the rule to assets that end with the specified term.
		//  - set-has—Tenable.io matches the rule to assets based on an exact match of the specified `tag_uuid`.
		//
		// For a complete list of operators by rule type, use the [GET /access-groups/rules/filters](ref:io-v1-access-groups-list-rule-filters) endpoint.
		Operator *string `json:"operator,omitempty"`

		// The values that Tenable.io uses to match an asset to the rule. A term must correspond to the rule type.
		//
		// For example:
		//  - If the rule type is `aws_account`, the term is an AWS account ID.
		//  - If the rule type is `fqdn`, the term is a hostname or a fully-qualified domain name (FQDN).
		//  - If the rule type is `ipv4`, the term is an individual IPv4 address, a range of IPv4 addresses (for example, 192.0.2.57-192.0.2.60), or a CIDR range (for example, 192.0.2.57/24).
		//
		// For a complete list of supported values by rule type, use the [GET /access-groups/rules/filters](ref:io-v1-access-groups-list-rule-filters) endpoint.
		//
		// If you specify multiple terms values, Tenable.io includes an asset in the access group if the asset's attributes match any of the terms in the rule.
		// <br >You can specify up to 100,000 terms per asset rule.
		Terms *[]string `json:"terms,omitempty"`

		// The type of asset rule. The asset rule type corresponds to the type of data you can specify in the `terms` parameter. For a complete list of supported rule types, use the [GET /access-groups/filters](ref:io-v1-access-groups-list-filters) endpoint.
		Type *string `json:"type,omitempty"`
	} `json:"rules"`
}

// IoV1AccessGroupsEditJSONBody defines parameters for IoV1AccessGroupsEdit.
type IoV1AccessGroupsEditJSONBody struct {
	// Specifies whether the access group you want to modify is the All Assets group or a user-defined group:
	// * If you want to refine membership in the All Assets access group (the only change you can make to the All Assets group), this parameter must be `true`. Tenable.io ignores any rules parameters in your request, but overwrrites existing principals parameters with those in the request based on the `all_users` and principals parameters in the request.
	// * If you want to modify a user-defined access group, this parameter must be `false`. Tenable.io overwrites the existing rules parameters with the rules parameters you specify in this request, and overwrites existing principals parameters based on the `all_users` and principals parameters in the request.
	AllAssets *bool `json:"all_assets,omitempty"`

	// Specifies whether assets in the access group can be viewed by all or only some users in your organization:
	// * If `true`, all users in your organization have Can View access to the assets defined in the rules parameter. Tenable.io ignores any principal parameters in your request.
	// * If `false`, only specified users have Can View access to the assets defined in the rules parameter. You define which users or user groups have access in the principals parameter of the request.
	//
	// If you omit this parameter, Tenable.io sets the parameter to `false` by default.
	AllUsers *bool `json:"all_users,omitempty"`

	// The name of the access group you want to modify.
	Name *string `json:"name,omitempty"`

	// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
	Principals *[]struct {
		// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
		PrincipalId *string `json:"principal_id,omitempty"`

		// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
		PrincipalName *string `json:"principal_name,omitempty"`

		// (Required) The type of principal. Valid values include:
		//  - user—Grants access to the user you specify.
		//  - group—Grants access to all users assigned to the user group you specify.
		Type *string `json:"type,omitempty"`
	} `json:"principals,omitempty"`

	// An array of asset rules. Tenable.io uses these rules to assign assets to the access group. You can specify a maximum of 1,000 rules for an individual access group. If you specify multiple rules for an access group, Tenable.io assigns an asset to the access group if the asset matches any of the rules. You can only add rules to access groups if the `all_assets` parameter is set to `false`.
	Rules *[]struct {
		// The operator that specifies how Tenable.io matches the terms value to asset data.
		//
		// Possible operators include:
		//  - eq—Tenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
		//  - match—Tenable.io matches the rule to assets based a partial match of the specified term.
		//  - starts—Tenable.io matches the rule to assets that start with the specified term.
		//  - ends—Tenable.io matches the rule to assets that end with the specified term.
		//  - set-has—Tenable.io matches the rule to assets based on an exact match of the specified `tag_uuid`.
		//
		// For a complete list of operators by rule type, use the [GET /access-groups/rules/filters](ref:io-v1-access-groups-list-rule-filters) endpoint.
		Operator *string `json:"operator,omitempty"`

		// The values that Tenable.io uses to match an asset to the rule. A term must correspond to the rule type.
		//
		// For example:
		//  - If the rule type is `aws_account`, the term is an AWS account ID.
		//  - If the rule type is `fqdn`, the term is a hostname or a fully-qualified domain name (FQDN).
		//  - If the rule type is `ipv4`, the term is an individual IPv4 address, a range of IPv4 addresses (for example, 192.0.2.57-192.0.2.60), or a CIDR range (for example, 192.0.2.57/24).
		//
		// For a complete list of supported values by rule type, use the [GET /access-groups/rules/filters](ref:io-v1-access-groups-list-rule-filters) endpoint.
		//
		// If you specify multiple terms values, Tenable.io includes an asset in the access group if the asset's attributes match any of the terms in the rule.
		// <br >You can specify up to 100,000 terms per asset rule.
		Terms *[]string `json:"terms,omitempty"`

		// The type of asset rule. The asset rule type corresponds to the type of data you can specify in the `terms` parameter. For a complete list of supported rule types, use the [GET /access-groups/filters](ref:io-v1-access-groups-list-filters) endpoint.
		Type *string `json:"type,omitempty"`
	} `json:"rules,omitempty"`
}

// AssetsBulkUpdateAcrJSONBody defines parameters for AssetsBulkUpdateAcr.
type AssetsBulkUpdateAcrJSONBody []struct {
	// The ACR score you want to assign to the asset. The ACR must be an integer from 1 to 10.
	AcrScore int `json:"acr_score"`

	// The identifiers of the assets to update to the specified ACR. At least one asset object is required in this array.
	Asset []struct {
		// Fully-qualified domain names (FQDNs) associated with the asset or assets.
		Fqdn *[]string `json:"fqdn,omitempty"`

		// The UUID for a specific asset. Use this value as the unique key for the asset.
		Id *string `json:"id,omitempty"`

		// IPv4 addresses associated with the asset or assets.
		Ipv4 *[]string `json:"ipv4,omitempty"`

		// MAC addresses associated with the asset or assets.
		MacAddress *[]string `json:"mac_address,omitempty"`

		// The NetBIOS name for the asset.
		NetbiosName *string `json:"netbios_name,omitempty"`
	} `json:"asset"`

	// Any notes you want to add to clarify the circumstances behind the update. This parameter corresponds to the **Note** parameter when editing an ACR in the Tenable.io Lumin user interface. For more information, see [Edit an ACR](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminEditACR.htm).
	Note *string `json:"note,omitempty"`

	// The reasons you are updating the ACR for the assets. Supported values include:
	//
	//  - Business Critical
	//  - In Scope For Compliance
	//  - Existing Mitigation Control
	//  - Dev only
	//  - Key drivers does not match
	//  - Other
	//
	// This parameter corresponds to the **Overwrite Reasoning** parameter when editing an ACR in the Tenable.io Lumin user interface. For more information, see [Edit an ACR](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/LuminEditACR.htm).
	Reason *[]AssetsBulkUpdateAcrJSONBodyReason `json:"reason,omitempty"`
}

// AssetsBulkUpdateAcrJSONBodyReason defines parameters for AssetsBulkUpdateAcr.
type AssetsBulkUpdateAcrJSONBodyReason string

// AssetsBulkDeleteJSONBody defines parameters for AssetsBulkDelete.
type AssetsBulkDeleteJSONBody struct {
	// Indicates whether or not to completely remove the asset from your licensed asset count along with all related data. If this parameter is omitted, Tenable.io uses the default value of `false`.
	HardDelete *bool `json:"hard_delete,omitempty"`

	// The query for selecting the assets to delete. Must include one or more filters. A filter must include an asset attribute, an operator, and a value. To get the list of supported filters, use the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. Sets of multiple filters must be specified inside `and` or `or` arrays.
	//
	// **Note:** You can also nest conditions, for example, specify a set of `or` sub-conditions for a condition inside the `and` array.
	Query struct {
		// To select assets that match all of multiple conditions, specify the conditions inside the `and` array.
		And *[]struct {
			// The name of the asset attribute to match. Asset attributes can include tags, for example, `tag.city`.
			Field *string `json:"field,omitempty"`

			// The operator to apply to the matched value, for example, `eq` (equals), `neq` (does not equal), or `match` (contains).
			Operator *string `json:"operator,omitempty"`

			// The asset attribute value to match.
			//
			//  **Note:** The value is case sensitive when used with the `match` (contains) or `nmatch` (does not contain) operators.
			Value *string `json:"value,omitempty"`
		} `json:"and,omitempty"`

		// The name of the asset attribute to match. Asset attributes can include tags, for example, `tag.city`.
		Field *string `json:"field,omitempty"`

		// The operator to apply to the matched value, for example, `eq` (equals), `neq` (does not equal), or `match` (contains).
		Operator *string `json:"operator,omitempty"`

		// To select assets that match any of multiple conditions, specify the conditions inside the `or` array.
		Or *[]struct {
			// The name of the asset attribute to match. Asset attributes can include tags, for example, `tag.city`.
			Field *string `json:"field,omitempty"`

			// The operator to apply to the matched value, for example, `eq` (equals), `neq` (does not equal), or `match` (contains).
			Operator *string `json:"operator,omitempty"`

			// The asset attribute value to match.
			//
			//  **Note:** The value is case sensitive when used with the `match` (contains) or `nmatch` (does not contain) operators.
			Value *string `json:"value,omitempty"`
		} `json:"or,omitempty"`

		// The asset attribute value to match.
		//
		//  **Note:** The value is case sensitive when used with the `match` (contains) or `nmatch` (does not contain) operators.
		Value *string `json:"value,omitempty"`
	} `json:"query"`
}

// AssetsBulkMoveJSONBody defines parameters for AssetsBulkMove.
type AssetsBulkMoveJSONBody struct {
	// The UUID of the network to associate with the specified assets. Use the [GET /networks](ref:networks-list) endpoint with the name filter to find the UUID of the network.
	Destination string `json:"destination"`

	// The UUID of the network currently associated with the assets. Use the [GET /networks](ref:networks-list) endpoint with the name attribute as filter to find the UUID of the network.
	Source string `json:"source"`

	// The IPv4 addresses of the assets to move. The addresses can be represented as a comma-separated list, a range, or CIDR, for example `1.1.1.1, 2.2.2.2-2.2.2.200, 3.3.3.0/24`.
	Targets string `json:"targets"`
}

// VulnerabilitiesImportV2JSONBody defines parameters for VulnerabilitiesImportV2.
type VulnerabilitiesImportV2JSONBody struct {
	// An array of asset objects with vulnerabilities information. A valid asset record requires at least one valid network_interface object.
	//
	// **Note:** Tenable.io supports a maximum of 50 individual asset objects per request message. In addition, because Tenable.io supports a total size limit of 15 MB for the request message, you may want to limit the number of asset objects you include in an individual request, depending on the number of vulnerabilities identified on the assets and the size of the related vulnerability output.
	//
	// **Note:** This endpoint does not support the network_id attribute in asset objects for import. Tenable.io automatically assigns imported assets to the default network object. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
	Assets []struct {
		// Specifies that the asset has been scanned with credentials for OS or application authentication.
		Authenticated *bool `json:"authenticated,omitempty"`

		// The BIOS UUID of the asset.
		BiosUuid *string `json:"bios_uuid,omitempty"`

		// The asset's hostname.
		Hostname *string `json:"hostname,omitempty"`

		// The NetBIOS name that the scan has associated with the asset.
		NetbiosName *string `json:"netbios_name,omitempty"`

		// A valid network_interface object must contain at least one of the following parameters: `ipv4`, `netbios_name`, `fqdn`.
		NetworkInterfaces *[]struct {
			// The fully-qualified domain name (FQDN) of the network interface.
			Fqdn *string `json:"fqdn,omitempty"`

			// A list of IPv4 address that the scan identified as associated with the network interface.
			Ipv4 *[]string `json:"ipv4,omitempty"`

			// A list of IPv6 addresses that the scan identified as associated with the network interface.
			Ipv6 *[]string `json:"ipv6,omitempty"`

			// The MAC address of the network interface.
			MacAddress *string `json:"mac_address,omitempty"`

			// The NETBIOS name of the network interface.
			NetbiosName *string `json:"netbios_name,omitempty"`
		} `json:"network_interfaces,omitempty"`

		// The operating system the asset is running.
		OperatingSystems *string `json:"operating_systems,omitempty"`

		// The unique record identifier of the asset in ServiceNow. For more information, see the ServiceNow documentation.
		ServicenowSysid *string `json:"servicenow_sysid,omitempty"`

		// The SSH key fingerprint that the scan has associated with the asset.
		SshFingerprint *string `json:"ssh_fingerprint,omitempty"`

		// The unique ID of the Nessus agent installed on the asset. This parameter is supported only if the `vendor` parameter for the request is `tenable`.
		TenableAgentId *string `json:"tenable_agent_id,omitempty"`

		// The unique identifier for the [network](doc:manage-networks-tio) where Tenable.io assigns the asset during import.
		TenableNetworkId *string `json:"tenable_network_id,omitempty"`

		// A valid vulnerability object must contain at least one of the following parameters: `tenable_plugin_id` or `cve`.
		Vulnerabilities *[]struct {
			// A value specifying whether the scan that identified the vulnerability was an authenticated (credentialed) scan.
			Authenticated *bool `json:"authenticated,omitempty"`

			// The Common Vulnerability and Exposure (CVE) ID for the vulnerability. This parameter is required if the vulnerability object does not specify a `tenable_plugin_id` value.
			Cve *string `json:"cve,omitempty"`

			// The date (in Unix time) when a scan last identified the vulnerability on the asset.
			LastFound *int32 `json:"last_found,omitempty"`

			// (Required) The text output of the scanner, up to 2,000 maximum characters.
			Output *string `json:"output,omitempty"`

			// The port the scanner used to communicate with the asset.
			Port *int32 `json:"port,omitempty"`

			// The protocol the scanner used to communicate with the asset.
			Protocol *string `json:"protocol,omitempty"`

			// The ID of the Nessus plugin that identified the vulnerability. This parameter is required if the vulnerability object does not specify a cve value.
			TenablePluginId *string `json:"tenable_plugin_id,omitempty"`
		} `json:"vulnerabilities,omitempty"`
	} `json:"assets"`

	// .
	Coverage *struct {
		// A string or range of IDs that each represents a check that the scan used to detect vulnerabilities you are importing. This parameter supports Tenable plugin checks only. For more information, see [Plugins](https://www.tenable.com/plugins).
		Ids *string `json:"ids,omitempty"`
	} `json:"coverage,omitempty"`

	// The type of scan that identified the vulnerabilities you want to import. To categorize the imported vulnerabilities in the same way that Tenable.io categorizes vulnerabilities detected in scans it manages, use the following values:
	//  - vm—A Vulnerability Management scan identified the vulnerabilities.
	DataType string `json:"data_type"`

	// The name of the product from the vendor that is the source of the vulnerability data being imported.
	//  - tenable.sc—The vulnerability data source is Tenable.sc.
	Product string `json:"product"`

	// A unique string value used to track the set of assets and vulnerabilities that Tenable.io is importing and processing. For data imported from Tenable.sc via [Lumin synchronization](https://docs.tenable.com/tenablesc/Content/LuminSynchronization.htm), this value has the following format:
	// scan_uuid:scan_chunk_uuid
	//
	// where scan_uuid is the unique identifier for the scan in Tenable.sc (equivalent to the scan id used in [Tenable.sc API requests](https://docs.tenable.com/tenablesc/api/Scan.html)), and scan_chunk_uuid is the unique identifer that Tenable.sc assigns to individual chunks of scan data during the Lumin synchronization process.
	Source string `json:"source"`

	// The company that owns the product that is the source of the vulnerability data. To categorize the imported vulnerabilities in the same way that Tenable.io categorizes vulnerabilities detected in scans it manages, use the following values:
	//  - tenable—A Nessus scan identified the vulnerabilities you want to import. Use this value for all Nessus scans, regardless of the scan manager (Tenable.io, Tenable.sc, or Nessus Manager).
	Vendor string `json:"vendor"`
}

// ExportsAssetsRequestExportJSONBody defines parameters for ExportsAssetsRequestExport.
type ExportsAssetsRequestExportJSONBody struct {
	// Specifies the number of assets per exported chunk. The range is 100-10000. If you specify a value outside of that range, Tenable.io returns a 400 error.
	//
	// **Note:** Using smaller chunks size can improve performance. Tenable does not recommend using a chunk size larger than 5000 as the potential for an error increases above this amount.
	ChunkSize int32 `json:"chunk_size"`

	// Specifies filters for exported assets. To return all assets, omit the filters object. If your request specifies multiple filters, the system combines the filters using the AND search operator.
	//
	// **Note:** If you submit an asset export request with filters that are identical to a previously submitted asset export request then the old export is canceled and a new export is submitted.
	Filters *struct {
		// Returns all assets created later than the date specified. The specified date must be in the Unix timestamp format.
		CreatedAt *int64 `json:"created_at,omitempty"`

		// Returns all assets deleted later than the date specified. The specified date must in the Unix timestamp format.
		DeletedAt *int64 `json:"deleted_at,omitempty"`

		// Returns all assets with a first scan time later than the date specified. The specified date must be in the Unix timestamp format.
		FirstScanTime *int64 `json:"first_scan_time,omitempty"`

		// Filter by whether or not the asset has plugin results associated with it. If `true`, Tenable.io returns all assets that have plugin results. If `false`, Tenable.io returns all assets that do not have plugin results. An asset may not have plugin results if the asset details originated from a connector or an API import.
		HasPluginResults *bool `json:"has_plugin_results,omitempty"`

		// When set to `true`, returns assets which have any value for the `deleted_at` attribute.
		IsDeleted *bool `json:"is_deleted,omitempty"`

		// Specifies whether the asset is included in the asset count for the Tenable.io instance. If `true`, Tenable.io returns only licensed assets. If `false`, Tenable.io returns all assets, both licensed and unlicensed.
		IsLicensed *bool `json:"is_licensed,omitempty"`

		// When set to `true`, returns assets which have any value for the `terminated_at` attribute.
		IsTerminated *bool `json:"is_terminated,omitempty"`

		// Returns all assets with a last assessed time later than the date specified. Tenable.io considers an asset assessed if it has been scanned by a credentialed or non-credentialed scan. The specified date must be in the Unix timestamp format.
		LastAssessed *int64 `json:"last_assessed,omitempty"`

		// Returns all assets with a last credentialed scan time later than the date specified. The specified date must be in the Unix timestamp format.
		LastAuthenticatedScanTime *int64 `json:"last_authenticated_scan_time,omitempty"`

		// The ID of the network object associated with scanners that identified the assets you want to export. The default network ID is `00000000-0000-0000-0000-000000000000`. To determine the ID of a custom network, use the [GET /networks](ref:networks-list) endpoint. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkId *string `json:"network_id,omitempty"`

		// If `true`, returns all assets that have a ServiceNow Sys ID, regardless of value. If `false`, returns all assets that do not have a ServiceNow Sys ID.
		ServicenowSysid *bool `json:"servicenow_sysid,omitempty"`

		// Returns assets that have the specified source. An asset source is the entity that reported the asset details. Sources can include sensors, connectors, and API imports. If your request specifies multiple sources, Tenable.io returns all assets that have been seen by any of the specified sources.
		//
		// The items in the sources array must correspond to the names of the sources as defined in your organization's implementation of Tenable.io. Commonly used names include:
		//  - AWS—You obtained the asset data from an Amazon Web Services connector.
		//  - NESSUS_AGENT—You obtained the asset data obtained from a Nessus agent scan.
		//  - PVS—You obtained the asset data from a Nessus Network Monitor (NNM) scan.
		//  - NESSUS_SCAN—You obtained the asset data from a Nessus scan.
		//  - WAS—You obtained the asset data from a  Web Application Scanning scan.
		Sources *[]string `json:"sources,omitempty"`

		// Returns all assets with the specified tag. The filter is defined as "tag", a period ("."), and the tag category name. The value of the filter is the tag value. For more information about tags, see [Tenable.io Vulnerability Management User Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/TagFormatAndApplication.htm).
		Tagcategory *string `json:"tag.<category>,omitempty"`

		// Returns all assets terminated later than the date specified. The specified date must be in the Unix timestamp format.
		TerminatedAt *int64 `json:"terminated_at,omitempty"`

		// Returns all assets updated later than the date specified. The specified date must be in the Unix timestamp format.
		UpdatedAt *int64 `json:"updated_at,omitempty"`
	} `json:"filters,omitempty"`
}

// AuditLogEventsParams defines parameters for AuditLogEvents.
type AuditLogEventsParams struct {
	// A filter condition in the `field.operator:value` format. Filter conditions can include:
	// * date.gt:&lt;YYYY-MM-DD>—Tenable.io returns events only if the date when the events occurred is after the date you specify. For example: `f=date.gt:2017-12-31`
	// * date.lt:&lt;YYYY-MM-DD>—Tenable.io returns events only if the date when the events occurred is before the date you specify. For example: `f=date.lt:2017-12-31`
	// * actor_id.match:&lt;UUID>—Tenable.io returns only the events with a matching actor UUID. For example: `f=actor_id.match:ee512c41-282e-489c-a2cf-8bda1151e630`
	// * target_id.match:&lt;UUID>—Tenable.io returns only the events with a matching target UUID. For example: `f=target_id.match:ee512c41-282e-489c-a2cf-8bda1151e630`
	//
	// You can specify multiple `f` parameters, separated by ampersand (&) characters. For example: `?f=date.gt:2018-12-31&f=date.lt:2019-12-31&f=actor_id.match:f54eeec5-84e0-44bb-9ebe-64898bea0e59&limit=5000`
	F *string `json:"f,omitempty"`

	// Sets the limit for how many events Tenable.io should return by the call. By default, this value is 50. For example: `limit=5000`
	Limit *int32 `json:"limit,omitempty"`
}

// IoExportsComplianceCreateJSONBody defines parameters for IoExportsComplianceCreate.
type IoExportsComplianceCreateJSONBody struct {
	// A list of asset UUIDs for which you want to return compliance data. The list can contain a maximum of 200 asset UUIDs.
	Asset *[]string `json:"asset,omitempty"`

	// A list of filters that Tenable.io applies to exported compliance data. To return compliance data for all assets, omit the filters object.
	//
	// **Note:** The `first_seen` filter cannot be used by itself. You must use `last_seen` and `first_seen` together or only `last_seen`.
	Filters *struct {
		// Filters assets that were first seen by a scan between the specified date (in Unix time) and now.
		FirstSeen *int64 `json:"first_seen,omitempty"`

		// Filters assets that were last seen by a scan between the specified date (in Unix time) and now.
		LastSeen *int64 `json:"last_seen,omitempty"`
	} `json:"filters,omitempty"`

	// Specifies the number of compliance findings per exported chunk. The range is 50-10000. If your request omits the `num_findings` body parameter, the value defaults to `5000`. If you specify a value outside of the supported range, Tenable.io uses the upper or lower-bound value.
	NumFindings *int32 `json:"num_findings,omitempty"`
}

// CredentialsListParams defines parameters for CredentialsList.
type CredentialsListParams struct {
	// A filter condition in the following format: `field:operator:value`. For managed credentials, you can only filter on the `name` field, using the following operators:
	// * eq—The name of the returned credential is equal to the text you specify.
	// * neq—The returned list of managed credentials excludes the credential object where the name is equal to the text you specify.
	// * match—The returned list includes managed credentials where the name contains the text you specify at least partially.
	//
	// You can specify multiple `f` parameters, separated by ampersand (&) characters. If you specify multiple `f` parameters, use the `ft` parameter to specify how Tenable.io applies the multiple filter conditions.
	F *string `json:"f,omitempty"`

	// The operator that Tenable.io applies if multiple \`f\` parameters are present. The `OR` operator is the only supported value. If you omit this parameter and multiple `f` parameters are present, Tenable.io applies the `OR` operator by default.
	Ft *string `json:"ft,omitempty"`

	// The UUID of a scan owner. This parameter limits the returned data to managed credentials assigned to scans owned by the specified user.
	ReferrerOwnerUuid *string `json:"referrer_owner_uuid,omitempty"`

	// The number of records to retrieve. If this parameter is omitted, Tenable.io uses the default value of `50`.
	Limit *int32 `json:"limit,omitempty"`

	// The starting record to retrieve. If this parameter is omitted, Tenable.io uses the default value of `0`.
	Offset *int32 `json:"offset,omitempty"`

	// The field you want to use to sort the results by along with the sort order. The field is specified first, followed by a colon, and the order is specified second (`asc` or `desc`). For example, `name:asc` would sort results by the `name` field in ascending order.
	Sort *string `json:"sort,omitempty"`
}

// CredentialsCreateJSONBody defines parameters for CredentialsCreate.
type CredentialsCreateJSONBody struct {
	// The description of the managed credential object.
	Description *string `json:"description,omitempty"`

	// The name of the managed credential. This name must be unique within your Tenable.io instance.
	Name string `json:"name"`

	// A list of user permissions for the managed credential. If a request message omits this parameter, Tenable.io automatically creates a `permissions` object for the user account that submits the request.
	Permissions *[]struct {
		// The UUID of the user or user group granted permissions for the managed credential.
		//
		// This parameter is required when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
		GranteeUuid *string `json:"grantee_uuid,omitempty"`

		// The name of the user or user group that you want to grant permissions for the managed credential.
		//
		// This parameter is optional when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
		Name *string `json:"name,omitempty"`

		// A value specifying the permissions granted to the user or user group for the credential. Possible values are:
		//  - 32—The user can view credential information and use the credential in scans. Corresponds to the **Can Use** permission in the user interface.
		//  - 64—The user can view and edit credential settings, delete the credential, and use the credential in scans. Corresponds to the **Can Edit** permission in the user interface.
		//
		// This parameter is required when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
		Permissions *int `json:"permissions,omitempty"`

		// A value specifying whether the grantee is a user (`user`) or a user group (`group`).
		//
		// This parameter is required when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
		Type *CredentialsCreateJSONBodyPermissionsType `json:"type,omitempty"`
	} `json:"permissions,omitempty"`

	// The configuration settings for the credential. The parameters of this object vary depending on the credential type. For more information, see [Determine Settings for a Credential Type](doc:determine-settings-for-credential-type).
	//
	// **Note:** This form displays limited parameters that support a Windows type of credential that uses password authentication.
	Settings struct {
		// The name for the authentication method. This value corresponds to the credentials[].types[].configuration[].options[].id attribute in the response message for the [GET /credentials/types](ref:credentials-list-credential-types) endpoint.
		AuthMethod *CredentialsCreateJSONBodySettingsAuthMethod `json:"auth_method,omitempty"`

		// The Windows domain to which the username belongs.
		Domain *string `json:"domain,omitempty"`

		// The user password on the target system.
		Password *string `json:"password,omitempty"`

		// The username on the target system.
		Username *string `json:"username,omitempty"`
	} `json:"settings"`

	// The type of credential object. For a list of supported credential types, use the GET /credentials/types endpoint.
	Type string `json:"type"`
}

// CredentialsCreateJSONBodyPermissionsType defines parameters for CredentialsCreate.
type CredentialsCreateJSONBodyPermissionsType string

// CredentialsCreateJSONBodySettingsAuthMethod defines parameters for CredentialsCreate.
type CredentialsCreateJSONBodySettingsAuthMethod string

// CredentialsUpdateJSONBody defines parameters for CredentialsUpdate.
type CredentialsUpdateJSONBody struct {
	// A value specifying if the credential is managed (`false`) versus stored in a scan or policy configuration (`true`). You can only set this parameter from `true` to `false`. You cannot set this parameter to `true`. If you omit this parameter, the value defaults to `false`.
	AdHoc *bool `json:"ad_hoc,omitempty"`

	// The new description of the managed credential object.
	Description *string `json:"description,omitempty"`

	// The new name of the managed credential object. This name must be unique within your Tenable.io instance.
	Name *string `json:"name,omitempty"`

	// User permissions for the managed credential.
	Permissions *[]struct {
		// The UUID of the user or user group granted permissions for the managed credential.
		//
		// This parameter is required when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
		GranteeUuid *string `json:"grantee_uuid,omitempty"`

		// The name of the user or user group that you want to grant permissions for the managed credential.
		//
		// This parameter is optional when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
		Name *string `json:"name,omitempty"`

		// A value specifying the permissions granted to the user or user group for the credential. Possible values are:
		//  - 32—The user can view credential information and use the credential in scans. Corresponds to the **Can Use** permission in the user interface.
		//  - 64—The user can view and edit credential settings, delete the credential, and use the credential in scans. Corresponds to the **Can Edit** permission in the user interface.
		//
		// This parameter is required when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
		Permissions *int `json:"permissions,omitempty"`

		// A value specifying whether the grantee is a user (`user`) or a user group (`group`).
		//
		// This parameter is required when assigning CAN USE (32) or CAN EDIT (64) permissions for a managed credential.
		Type *CredentialsUpdateJSONBodyPermissionsType `json:"type,omitempty"`
	} `json:"permissions,omitempty"`

	// The configuration settings for the credential. The parameters of this object vary depending on the credential type. For more information, see [Determine Settings for a Credential Type](doc:determine-settings-for-credential-type).
	//
	// **Note:** This form displays limited parameters that support a Windows type of credential that uses password authentication.
	Settings *struct {
		// The name for the authentication method. This value corresponds to the credentials[].types[].configuration[].options[].id attribute in the response message for the [GET /credentials/types](ref:credentials-list-credential-types) endpoint.
		AuthMethod *CredentialsUpdateJSONBodySettingsAuthMethod `json:"auth_method,omitempty"`

		// The Windows domain to which the username belongs.
		Domain *string `json:"domain,omitempty"`

		// The user password on the target system.
		Password *string `json:"password,omitempty"`

		// The username on the target system.
		Username *string `json:"username,omitempty"`
	} `json:"settings,omitempty"`
}

// CredentialsUpdateJSONBodyPermissionsType defines parameters for CredentialsUpdate.
type CredentialsUpdateJSONBodyPermissionsType string

// CredentialsUpdateJSONBodySettingsAuthMethod defines parameters for CredentialsUpdate.
type CredentialsUpdateJSONBodySettingsAuthMethod string

// EditorListTemplatesParamsType defines parameters for EditorListTemplates.
type EditorListTemplatesParamsType string

// EditorTemplateDetailsParamsType defines parameters for EditorTemplateDetails.
type EditorTemplateDetailsParamsType string

// EditorDetailsParamsType defines parameters for EditorDetails.
type EditorDetailsParamsType string

// EditorAuditsParamsType defines parameters for EditorAudits.
type EditorAuditsParamsType string

// ExclusionsCreateJSONBody defines parameters for ExclusionsCreate.
type ExclusionsCreateJSONBody struct {
	// The description of the exclusion.
	Description *string `json:"description,omitempty"`

	// The targets that you want excluded from scans. Specify multiple targets as a comma-separated string. Targets can be in the following formats:
	//  - an individual IPv4 address (192.0.2.1)
	//  - a range of IPv4 addresses (192.0.2.1-192.0.2.255)
	//  - CIDR notation (192.0.2.0/24)
	//  - a fully-qualified domain name (FQDN) (host.domain.com)
	Members string `json:"members"`

	// The name of the exclusion.
	Name string `json:"name"`

	// The ID of the network object associated with scanners where Tenable.io applies the exclusion. The default network ID is `00000000-0000-0000-0000-000000000000`. To determine the ID of a custom network, use the [GET /networks](ref:networks-list) endpoint. If you omit this parameter from the request message, Tenable.io automatically assigns the exclusion to the default network. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
	NetworkId *string `json:"network_id,omitempty"`

	// The schedule parameters for the exclusion.
	Schedule *struct {
		// If `true`, the exclusion schedule is active.
		Enabled *bool `json:"enabled,omitempty"`

		// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
		Endtime *string `json:"endtime,omitempty"`

		// The recurrence rules for the exclusion.
		Rrules *struct {
			// The day of the month to repeat a MONTHLY freq rule on.
			Bymonthday *int `json:"bymonthday,omitempty"`

			// A comma-separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
			Byweekday *string `json:"byweekday,omitempty"`

			// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
			Freq *string `json:"freq,omitempty"`

			// The interval of the rule.
			Interval *int `json:"interval,omitempty"`
		} `json:"rrules,omitempty"`

		// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
		Starttime *string `json:"starttime,omitempty"`

		// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
		Timezone *string `json:"timezone,omitempty"`
	} `json:"schedule,omitempty"`
}

// ExclusionsImportJSONBody defines parameters for ExclusionsImport.
type ExclusionsImportJSONBody struct {
	// The name of the file to import as provided by the response from [file: upload](ref:file).
	File string `json:"file"`
}

// ExclusionsEditJSONBody defines parameters for ExclusionsEdit.
type ExclusionsEditJSONBody struct {
	// The description of the exclusion.
	Description *string `json:"description,omitempty"`

	// The targets that you want excluded from scans. Specify multiple targets as a comma-separated string. Targets can be in the following formats:
	//  - an individual IPv4 address (192.0.2.1)
	//  - a range of IPv4 addresses (192.0.2.1-192.0.2.255)
	//  - CIDR notation (192.0.2.0/24)
	//  - a fully-qualified domain name (FQDN) (host.domain.com)
	Members *string `json:"members,omitempty"`

	// The name of the exclusion.
	Name *string `json:"name,omitempty"`

	// The ID of the network object associated with scanners where Tenable.io applies the exclusion. The default network ID is `00000000-0000-0000-0000-000000000000`. To determine the ID of a custom network, use the [GET /networks](ref:networks-list) endpoint. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
	NetworkId *string `json:"network_id,omitempty"`

	// The schedule parameters for the exclusion.
	Schedule *struct {
		// If `true`, the exclusion schedule is active.
		Enabled *bool `json:"enabled,omitempty"`

		// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
		Endtime *string `json:"endtime,omitempty"`

		// The recurrence rules for the exclusion.
		Rrules *struct {
			// The day of the month to repeat a MONTHLY freq rule on.
			Bymonthday *int `json:"bymonthday,omitempty"`

			// A comma-separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
			Byweekday *string `json:"byweekday,omitempty"`

			// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
			Freq *string `json:"freq,omitempty"`

			// The interval of the rule.
			Interval *int `json:"interval,omitempty"`
		} `json:"rrules,omitempty"`

		// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
		Starttime *string `json:"starttime,omitempty"`

		// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
		Timezone *string `json:"timezone,omitempty"`
	} `json:"schedule,omitempty"`
}

// FileUploadParams defines parameters for FileUpload.
type FileUploadParams struct {
	// Send value of `1` when uploading an encrypted file.
	NoEnc *FileUploadParamsNoEnc `json:"no_enc,omitempty"`
}

// FileUploadParamsNoEnc defines parameters for FileUpload.
type FileUploadParamsNoEnc int32

// IoFiltersAssetsListV2JSONBody defines parameters for IoFiltersAssetsListV2.
type IoFiltersAssetsListV2JSONBody struct {
	// A list of tag UUIDs that are guaranteed to be returned in the initial data set of the `tag_uuid` filter, if the tags exist.
	TagUuids *[]string `json:"tag_uuids,omitempty"`
}

// IoFiltersVulnerabilitiesWorkbenchListV2JSONBody defines parameters for IoFiltersVulnerabilitiesWorkbenchListV2.
type IoFiltersVulnerabilitiesWorkbenchListV2JSONBody struct {
	// A list of tag UUIDs that are guaranteed to be returned in the initial data set of the `tag_uuid` filter, if the tags exist.
	TagUuids *[]string `json:"tag_uuids,omitempty"`
}

// FoldersCreateJSONBody defines parameters for FoldersCreate.
type FoldersCreateJSONBody struct {
	// The name of the folder.
	//
	// **Note:** Folder names can only contain letters, numbers, underscores, hyphens, and whitespace.
	Name string `json:"name"`
}

// FoldersEditJSONBody defines parameters for FoldersEdit.
type FoldersEditJSONBody struct {
	// The name of the folder.
	// **Note:** Tenable.io does not allow the following special characters in folder names: `( ) [ ] : ; = + / | \ ? , ^ % & $`
	Name string `json:"name"`
}

// AssetsImportJSONBody defines parameters for AssetsImport.
type AssetsImportJSONBody struct {
	// An array of asset objects to import. Each asset object requires a value for at least one of the following properties: fqdn, ipv4, netbios\_name, mac\_address.
	//
	// For an example of this request body, see [Add Asset Data to Tenable.io](doc:add-asset-data-to-tenableio). For the complete list of importable asset attributes, see [Common Asset Attributes](doc:common-asset-attributes#section-asset-attribute-definitions).
	Assets []struct {
		// The availability zone where Amazon Web Services hosts the virtual machine instance, for example, `us-east-1a`. Availability zones are subdivisions of AWS regions. For more information, see "Regions and Availability Zones" in the AWS documentation.
		AwsAvailabilityZone *string `json:"aws_availability_zone,omitempty"`

		// The unique identifier of the Linux AMI image in Amazon Elastic Compute Cloud (Amazon EC2). For more information, see the Amazon Elastic Compute Cloud Documentation.
		AwsEc2InstanceAmiId *string `json:"aws_ec2_instance_ami_id,omitempty"`

		// The virtual machine instance's group in AWS.
		AwsEc2InstanceGroupName *string `json:"aws_ec2_instance_group_name,omitempty"`

		// The unique identifier of the Linux instance in Amazon EC2. For more information, see the Amazon Elastic Compute Cloud Documentation.
		AwsEc2InstanceId *string `json:"aws_ec2_instance_id,omitempty"`

		// The state of the virtual machine instance in AWS at the time of the scan. For more information on instance states, see the AWS documentation.
		AwsEc2InstanceStateName *string `json:"aws_ec2_instance_state_name,omitempty"`

		// The type of instance in AWS EC2.
		AwsEc2InstanceType *string `json:"aws_ec2_instance_type,omitempty"`

		// The name of the virtual machine instance in AWS EC2.
		AwsEc2Name *string `json:"aws_ec2_name,omitempty"`

		// The product code associated with the AMI used to launch the virtual machine instance in AWS EC2.
		AwsEc2ProductCode *string `json:"aws_ec2_product_code,omitempty"`

		// The canonical user identifier for the AWS account associated with the asset. For more information, see "AWS Account Identifiers" in the AWS documentation.
		AwsOwnerId *string `json:"aws_owner_id,omitempty"`

		// The region where AWS hosts the virtual machine instance, for example, `us-east-1`. For more information, see "Regions and Availability Zones" in the AWS documentation.
		AwsRegion *string `json:"aws_region,omitempty"`

		// The unique identifier of the AWS subnet where the virtual machine instance was running at the time of the scan.
		AwsSubnetId *string `json:"aws_subnet_id,omitempty"`

		// The unique identifier of the public cloud that hosts the AWS virtual machine instance. For more information, see the Amazon Virtual Private Cloud User Guide.
		AwsVpcId *string `json:"aws_vpc_id,omitempty"`

		// The unique identifier of the resource in the Azure Resource Manager. For more information, see the Azure Resource Manager Documentation.
		AzureResourceId *string `json:"azure_resource_id,omitempty"`

		// The unique identifier of the Microsoft Azure virtual machine instance. For more information, see "Accessing and Using Azure VM Unique ID" in the Microsoft Azure documentation.
		AzureVmId *string `json:"azure_vm_id,omitempty"`

		// The unique identifiers of the asset in HCL BigFix. For more information, see the HCL BigFix documentation.
		BigfixAssetId *[]string `json:"bigfix_asset_id,omitempty"`

		// The BIOS UUID of the asset.
		BiosUuid *string `json:"bios_uuid,omitempty"`

		// A list of FQDNs for the asset.
		Fqdn *[]string `json:"fqdn,omitempty"`

		// The unique identifier of the virtual machine instance in GCP.
		GcpInstanceId *string `json:"gcp_instance_id,omitempty"`

		// The customized name of the project to which the virtual machine instance belongs in Google Cloud Platform (GCP). For more information see "Creating and Managing Projects" in the GCP documentation.
		GcpProjectId *string `json:"gcp_project_id,omitempty"`

		// The zone where the virtual machine instance runs in GCP. For more information, see "Regions and Zones" in the GCP documentation.
		GcpZone *string `json:"gcp_zone,omitempty"`

		// A list of hostnames for the asset.
		Hostname *[]string `json:"hostname,omitempty"`

		// A list of Common Platform Enumeration (CPE) values that represent software applications a scan identified as present on an asset. The strings in this array must be valid CPE 2.2 values. For more information, see the "Component Syntax" section of the [CPE Specification, Version 2.2](https://cpe.mitre.org/files/cpe-specification_2.2.pdf).
		//
		// **Note:** If no scan detects an application within 30 days of the scan that originally detected the application, Tenable.io considers the detection of that application expired. As a result, the next time a scan evaluates the asset, Tenable.io removes the expired application from the installed_software attribute. This activity is logged as a `remove` type of `attribute_change` update in the asset activity log.
		InstalledSoftware *[]string `json:"installed_software,omitempty"`

		// A list of IPv4 addresses for the asset. Tenable.io supports this legacy field for backwards compatibility, but for new requests, this field should be replaced by the ipv4 field.
		IpAddress *[]string `json:"ip_address,omitempty"`

		// A list of IPv4 addresses for the asset.
		Ipv4 *[]string `json:"ipv4,omitempty"`

		// A list of IPv6 addresses for the asset.
		Ipv6 *[]string `json:"ipv6,omitempty"`

		// A list of MAC addresses for the asset.
		MacAddress *[]string `json:"mac_address,omitempty"`

		// The manufacturer's unique identifier of the Trusted Platform Module (TPM) associated with the asset.
		ManufacturerTpmId *string `json:"manufacturer_tpm_id,omitempty"`

		// The unique identifier of the McAfee ePO agent that identified the asset. For more information, see the McAfee documentation.
		McafeeEpoAgentGuid *string `json:"mcafee_epo_agent_guid,omitempty"`

		// The unique identifier of the asset in McAfee ePolicy Orchestrator (ePO). For more information, see the McAfee documentation.
		McafeeEpoGuid *string `json:"mcafee_epo_guid,omitempty"`

		// The NetBIOS name for the asset.
		NetbiosName *string `json:"netbios_name,omitempty"`

		// The operating systems that scans have associated with the asset record.
		OperatingSystem *[]string `json:"operating_system,omitempty"`

		// The Asset ID of the asset in Qualys. For more information, see the Qualys documentation.
		QualysAssetId *string `json:"qualys_asset_id,omitempty"`

		// The Host ID of the asset in Qualys. For more information, see the Qualys documentation.
		QualysHostId *string `json:"qualys_host_id,omitempty"`

		// The unique record identifier of the asset in ServiceNow. For more information, see the ServiceNow documentation.
		ServicenowSysId *string `json:"servicenow_sys_id,omitempty"`

		// The SSH key fingerprints that scans have associated with the asset record.
		SshFingerprint *string `json:"ssh_fingerprint,omitempty"`

		// The hardware key for the asset in Symantec Endpoint Protection.
		SymantecEpHardwareKey *string `json:"symantec_ep_hardware_key,omitempty"`
	} `json:"assets"`

	// A user-defined name for the source of the import containing the asset records. You can specify only one source for each import.
	Source string `json:"source"`
}

// VulnerabilitiesImportJSONBody defines parameters for VulnerabilitiesImport.
type VulnerabilitiesImportJSONBody struct {
	// An array of asset objects with vulnerabilities information. A valid asset record requires at least one valid network_interface object.
	//
	// **Note:** Tenable.io supports a maximum of 50 individual asset objects per request message. In addition, because Tenable.io supports a total size limit of 15 MB for the request message, you may want to limit the number of asset objects you include in an individual request, depending on the number of vulnerabilities identified on the assets and the size of the related vulnerability output.
	//
	// **Note:** This endpoint does not support the network_id attribute in asset objects for import. Tenable.io automatically assigns imported assets to the default network object. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
	Assets []struct {
		// The BIOS UUID of the asset.
		BiosUuid *string `json:"bios_uuid,omitempty"`

		// The asset's hostname.
		Hostname *string `json:"hostname,omitempty"`

		// The NetBIOS name that the scan has associated with the asset.
		NetbiosName *string `json:"netbios_name,omitempty"`

		// A valid network_interface object must contain at least one of the following parameters: `ipv4`, `netbios_name`, `fqdn`.
		NetworkInterfaces *[]struct {
			// The fully-qualified domain name (FQDN) of the network interface.
			Fqdn *string `json:"fqdn,omitempty"`

			// A list of IPv4 address that the scan identified as associated with the network interface.
			Ipv4 *[]string `json:"ipv4,omitempty"`

			// A list of IPv6 addresses that the scan identified as associated with the network interface.
			Ipv6 *[]string `json:"ipv6,omitempty"`

			// The MAC address of the network interface.
			MacAddress *string `json:"mac_address,omitempty"`

			// The NETBIOS name of the network interface.
			NetbiosName *string `json:"netbios_name,omitempty"`
		} `json:"network_interfaces,omitempty"`

		// The unique record identifier of the asset in ServiceNow. For more information, see the ServiceNow documentation.
		ServicenowSysid *string `json:"servicenow_sysid,omitempty"`

		// The SSH key fingerprint that the scan has associated with the asset.
		SshFingerprint *string `json:"ssh_fingerprint,omitempty"`

		// The unique ID of the Nessus agent installed on the asset. This parameter is supported only if the `source` parameter for the request is `security_center`.
		TenableAgentId *int `json:"tenable_agent_id,omitempty"`

		// A valid vulnerability object must contain at least one of the following parameters: `tenable_plugin_id` or `cve`.
		Vulnerabilities *[]struct {
			// A value specifying whether the scan that identified the vulnerability was an authenticated (credentialed) scan.
			Authenticated *bool `json:"authenticated,omitempty"`

			// The Common Vulnerability and Exposure (CVE) ID for the vulnerability. This parameter is required if the vulnerability object does not specify a `tenable_plugin_id` value.
			Cve *string `json:"cve,omitempty"`

			// The date (in Unix time) when a scan first identified the vulnerability on the asset.
			FirstFound *int32 `json:"first_found,omitempty"`

			// The date (in Unix time) when the vulnerability state was changed to `fixed`. Tenable.io updates the vulnerability state to fixed when a scan no longer detects a previously detected vulnerability on the asset.
			LastFixed *int32 `json:"last_fixed,omitempty"`

			// The date (in Unix time) when a scan last identified the vulnerability on the asset.
			LastFound *int32 `json:"last_found,omitempty"`

			// (Required) The text output of the scanner, up to 2,000 maximum characters.
			Output *string `json:"output,omitempty"`

			// The port the scanner used to communicate with the asset.
			Port *int32 `json:"port,omitempty"`

			// The protocol the scanner used to communicate with the asset.
			Protocol *string `json:"protocol,omitempty"`

			// The ID of the Nessus plugin that identified the vulnerability. This parameter is required if the vulnerability object does not specify a cve value.
			TenablePluginId *string `json:"tenable_plugin_id,omitempty"`
		} `json:"vulnerabilities,omitempty"`
	} `json:"assets"`

	// An array of objects, each representing a check that the scan used to detect the vulnerabilities you are importing. This parameter supports Tenable plugin checks only. For more information, see [Plugins](https://www.tenable.com/plugins).
	ChecksRan *[]struct {
		// The port on the asset where the check ran.
		Port *int `json:"port,omitempty"`

		// The protocol used to communicate with the asset while running the check.
		Protocol *string `json:"protocol,omitempty"`

		// The Tenable plugin ID.
		TenablePluginId *string `json:"tenable_plugin_id,omitempty"`
	} `json:"checks_ran,omitempty"`

	// The source of the scan that generated the vulnerability data. If you want to categorize the imported vulnerabilities in the same way that Tenable.io categorizes vulnerabilities detected in scans it manages, use the following values:
	//  - security_center—A Nessus scan identified the vulnerabilities you want to import. Use this value for all Nessus scans, regardless of the scan manager (Tenable.io, SecurityCenter, or Nessus Manager).
	Source string `json:"source"`

	// The type of scan that identified the vulnerabilities you want to import. If you want to categorize the imported vulnerabilities in the same way that Tenable.io categorizes vulnerabilities detected in scans it manages, use the following values:
	//  - vm—A Vulnerability Management scan identified the vulnerabilities.
	//  - was—A Web Application Scanning scan identified the vulnerabilities.
	//  - pc—A scan of a personal computer identified the vulnerabilities.
	Type string `json:"type"`
}

// NetworksListParams defines parameters for NetworksList.
type NetworksListParams struct {
	// A filter condition in the following format: `field:operator:value`. For network objects, you can only filter on the `name` field, using the following operators:
	// * eq—The name of the returned network object is equal to the text you specify.
	// * neq—The returned list of network objects excludes the network object where the name is equal to the text you specify.
	// * match—The returned list includes network objects where the name contains the text you specify at least partially.
	//
	// You can specify multiple `f` parameters, separated by ampersand (&) characters. If you specify multiple `f` parameters, use the `ft` parameter to specify how Tenable.io applies the multiple filter conditions.
	F *string `json:"f,omitempty"`

	// The operator that Tenable.io applies if multiple \`f\` parameters are present. The `OR` operator is the only supported value. If you omit this parameter and multiple `f` parameters are present, Tenable.io applies the `OR` operator by default.
	Ft *string `json:"ft,omitempty"`

	// The number of records to retrieve. If this parameter is omitted, Tenable.io uses the default value of `50`.
	Limit *int32 `json:"limit,omitempty"`

	// The starting record to retrieve. If this parameter is omitted, Tenable.io uses the default value of `0`.
	Offset *int32 `json:"offset,omitempty"`

	// The field you want to use to sort the results by along with the sort order. The field is specified first, followed by a colon, and the order is specified second (`asc` or `desc`). For example, `name:asc` would sort results by the `name` field in ascending order.
	Sort *string `json:"sort,omitempty"`

	// Indicates whether Tenable.io includes deleted network objects in the response message. Deleted network objects contain the additional attributes, `deleted` and `deleted_by`, which specifies the date (in Unix time) when the network object was deleted and the UUID of the user that deleted the network object.
	IncludeDeleted *bool `json:"includeDeleted,omitempty"`
}

// NetworksCreateJSONBody defines parameters for NetworksCreate.
type NetworksCreateJSONBody struct {
	// The number of days to wait before assets age out. Assets will be permanently deleted if they are not seen on a scan within the specified number of days.<ul><li>Minimum value: 90</li><li>Maximum value: 365</li></ul> **Warning:** If you enable this option, Tenable.io immediately deletes assets in the specified network that have not been seen for the specified number of days. All asset records and associated vulnerabilities are deleted and cannot be recovered. The deleted assets no longer count towards [your license](https://docs.tenable.com/earlyaccess/tenableio/vulnerabilitymanagement/Content/GettingStarted/Licenses.htm).
	AssetsTtlDays *int `json:"assets_ttl_days,omitempty"`

	// The description of the network object.
	Description *string `json:"description,omitempty"`

	// The name of the network object. This name must be unique within your Tenable.io instance, cannot duplicate the name of a previously deleted network, and cannot be `default`.
	//
	// **Note:** You can add a maximum of 50,000 network objects to an individual Tenable.io instance.
	Name string `json:"name"`
}

// NetworksUpdateJSONBody defines parameters for NetworksUpdate.
type NetworksUpdateJSONBody struct {
	// The number of days to wait before assets age out. Assets will be permanently deleted if they are not seen on a scan within the specified number of days.<ul><li>Minimum value: 90</li><li>Maximum value: 365</li></ul> **Warning:** If you enable this option, Tenable.io immediately deletes assets in the specified network that have not been seen for the specified number of days. All asset records and associated vulnerabilities are deleted and cannot be recovered. The deleted assets no longer count towards [your license](https://docs.tenable.com/earlyaccess/tenableio/vulnerabilitymanagement/Content/GettingStarted/Licenses.htm).
	AssetsTtlDays *int `json:"assets_ttl_days,omitempty"`

	// The new description of the network object.
	Description *string `json:"description,omitempty"`

	// The new name of the network object. This name must be unique within your Tenable.io instance, cannot duplicate the name of a previously deleted network, and cannot be `default`.
	Name string `json:"name"`
}

// NetworksAssignScannerBulkJSONBody defines parameters for NetworksAssignScannerBulk.
type NetworksAssignScannerBulkJSONBody struct {
	// A list of UUIDs for the scanners and scanner groups you want to bulk move to a network object. To get values for this list, use the [GET /networks/{network_id}/assignable-scanners](ref:networks-list-assignable-scanners) endpoint.
	ScannerUuids []string `json:"scanner_uuids"`
}

// PermissionsListParamsObjectType defines parameters for PermissionsList.
type PermissionsListParamsObjectType string

// PermissionsChangeJSONBody defines parameters for PermissionsChange.
type PermissionsChangeJSONBody struct {
	Acls *struct {
		// The unique ID of the user or group.
		Id *int `json:"id,omitempty"`

		// The permission value to grant access as described in [Permissions](doc:permissions).
		Permissions *int32 `json:"permissions,omitempty"`

		// The type of permission (default, user, group).
		Type *PermissionsChangeJSONBodyAclsType `json:"type,omitempty"`
	} `json:"acls,omitempty"`
}

// PermissionsChangeParamsObjectType defines parameters for PermissionsChange.
type PermissionsChangeParamsObjectType string

// PermissionsChangeJSONBodyAclsType defines parameters for PermissionsChange.
type PermissionsChangeJSONBodyAclsType string

// IoPluginsFamiliesListParams defines parameters for IoPluginsFamiliesList.
type IoPluginsFamiliesListParams struct {
	// Specifies whether to return all plugin families. If `true`, the plugin families hidden in Tenable.io UI, for example, Port Scanners, are included in the list.
	All *bool `json:"all,omitempty"`
}

// IoPluginsListParams defines parameters for IoPluginsList.
type IoPluginsListParams struct {
	// The last updated date to filter on in the `YYYY-MM-DD` format. Tenable.io returns only the plugins that have been updated after the specified date.
	LastUpdated *string `json:"last_updated,omitempty"`

	// The number of records to include in the result set. Default is 1,000. The maximum size is 10,000.
	Size *int32 `json:"size,omitempty"`

	// The index of the page to return relative to the specified page size. For example, to return records 10-19 with page size 10, you must specify page 2. If you omit this parameter, Tenable.io applies the default value of 1.
	Page *int32 `json:"page,omitempty"`
}

// PoliciesCreateJSONBody defines parameters for PoliciesCreate.
type PoliciesCreateJSONBody struct {
	Settings *map[string]interface{} `json:"settings,omitempty"`

	// The uuid for the editor template to use.
	Uuid string `json:"uuid"`
}

// PoliciesImportJSONBody defines parameters for PoliciesImport.
type PoliciesImportJSONBody struct {
	// The name of the file to import as provided by the response from file-upload.
	File string `json:"file"`
}

// ScannerGroupsCreateJSONBody defines parameters for ScannerGroupsCreate.
type ScannerGroupsCreateJSONBody struct {
	// The name for the new scanner group.
	Name string `json:"name"`

	// The type of scanner group. If you omit this parameter, Tenable.io automatically uses the default (`load_balancing`).
	Type *ScannerGroupsCreateJSONBodyType `json:"type,omitempty"`
}

// ScannerGroupsCreateJSONBodyType defines parameters for ScannerGroupsCreate.
type ScannerGroupsCreateJSONBodyType string

// ScannerGroupsEditJSONBody defines parameters for ScannerGroupsEdit.
type ScannerGroupsEditJSONBody struct {
	// The new name for the scanner group.
	Name string `json:"name"`
}

// IoScannerGroupsUpdateRoutesJSONBody defines parameters for IoScannerGroupsUpdateRoutes.
type IoScannerGroupsUpdateRoutesJSONBody struct {
	// A list of zero or more hostnames, hostname wildcards, IP addresses, CIDR addresses, or IP ranges. For more information about supported route formats, see [Supported Scan Routing Target Formats](doc:manage-scan-routing-tio#section-supported-scan-routing-target-formats).
	Routes []string `json:"routes"`
}

// BulkAddAgentsJSONBody defines parameters for BulkAddAgents.
type BulkAddAgentsJSONBody struct {
	// Specifies criteria you wish to filter agents on.
	Criteria *struct {
		// Indicates whether or not to match against all agents.
		AllAgents *bool `json:"all_agents,omitempty"`

		// Indicates how to combine the `filters` conditions. Possible values are `and` or `or`.
		FilterType *BulkAddAgentsJSONBodyCriteriaFilterType `json:"filter_type,omitempty"`

		// An array of string or numeric operations to match against agents. For example, `name:match:laptop` or `core_version:lt:10.0.0`.
		Filters *[]interface{} `json:"filters,omitempty"`

		// Additional filters that will always be added as `and` conditions.
		HardcodedFilters *[]interface{} `json:"hardcoded_filters,omitempty"`

		// A string used to match against all string-like attributes of an agent.
		Wildcard *string `json:"wildcard,omitempty"`
	} `json:"criteria,omitempty"`

	// An array of agent IDs or UUIDs to add to the criteria filter.
	Items *[]interface{} `json:"items,omitempty"`

	// An array of agent IDs or UUIDs to exclude from the criteria filter.
	NotItems *[]interface{} `json:"not_items,omitempty"`
}

// BulkAddAgentsJSONBodyCriteriaFilterType defines parameters for BulkAddAgents.
type BulkAddAgentsJSONBodyCriteriaFilterType string

// IoAgentBulkOperationsGroupDirectiveJSONBody defines parameters for IoAgentBulkOperationsGroupDirective.
type IoAgentBulkOperationsGroupDirectiveJSONBody struct {
	// Specifies criteria you wish to filter agents on.
	Criteria *struct {
		// Indicates whether or not to match against all agents.
		AllAgents *bool `json:"all_agents,omitempty"`

		// Indicates how to combine the `filters` conditions. Possible values are `and` or `or`.
		FilterType *IoAgentBulkOperationsGroupDirectiveJSONBodyCriteriaFilterType `json:"filter_type,omitempty"`

		// An array of string or numeric operations to match against agents. For example, `name:match:laptop` or `core_version:lt:10.0.0`.
		Filters *[]interface{} `json:"filters,omitempty"`

		// Additional filters that will always be added as `and` conditions.
		HardcodedFilters *[]interface{} `json:"hardcoded_filters,omitempty"`

		// A string used to match against all string-like attributes of an agent.
		Wildcard *string `json:"wildcard,omitempty"`
	} `json:"criteria,omitempty"`

	// Specifies the instructions you wish to send to the agents.
	Directive *struct {
		// Additional information about the instruction to perform. For example, if the `type` is `restart`, you can use the options `"hard": true` or `"idle": true`.
		Options *map[string]interface{} `json:"options,omitempty"`

		// The type of instruction to perform. Possible instructions are `restart` and `settings`.
		Type *IoAgentBulkOperationsGroupDirectiveJSONBodyDirectiveType `json:"type,omitempty"`
	} `json:"directive,omitempty"`

	// An array of agent IDs or UUIDs to add to the criteria filter.
	Items *[]interface{} `json:"items,omitempty"`

	// An array of agent IDs or UUIDs to exclude from the criteria filter.
	NotItems *[]interface{} `json:"not_items,omitempty"`
}

// IoAgentBulkOperationsGroupDirectiveJSONBodyCriteriaFilterType defines parameters for IoAgentBulkOperationsGroupDirective.
type IoAgentBulkOperationsGroupDirectiveJSONBodyCriteriaFilterType string

// IoAgentBulkOperationsGroupDirectiveJSONBodyDirectiveType defines parameters for IoAgentBulkOperationsGroupDirective.
type IoAgentBulkOperationsGroupDirectiveJSONBodyDirectiveType string

// BulkRemoveAgentsJSONBody defines parameters for BulkRemoveAgents.
type BulkRemoveAgentsJSONBody struct {
	// Specifies criteria you wish to filter agents on.
	Criteria *struct {
		// Indicates whether or not to match against all agents.
		AllAgents *bool `json:"all_agents,omitempty"`

		// Indicates how to combine the `filters` conditions. Possible values are `and` or `or`.
		FilterType *BulkRemoveAgentsJSONBodyCriteriaFilterType `json:"filter_type,omitempty"`

		// An array of string or numeric operations to match against agents. For example, `name:match:laptop` or `core_version:lt:10.0.0`.
		Filters *[]interface{} `json:"filters,omitempty"`

		// Additional filters that will always be added as `and` conditions.
		HardcodedFilters *[]interface{} `json:"hardcoded_filters,omitempty"`

		// A string used to match against all string-like attributes of an agent.
		Wildcard *string `json:"wildcard,omitempty"`
	} `json:"criteria,omitempty"`

	// An array of agent IDs or UUIDs to add to the criteria filter.
	Items *[]interface{} `json:"items,omitempty"`

	// An array of agent IDs or UUIDs to exclude from the criteria filter.
	NotItems *[]interface{} `json:"not_items,omitempty"`
}

// BulkRemoveAgentsJSONBodyCriteriaFilterType defines parameters for BulkRemoveAgents.
type BulkRemoveAgentsJSONBodyCriteriaFilterType string

// IoAgentBulkOperationsAddToNetworkJSONBody defines parameters for IoAgentBulkOperationsAddToNetwork.
type IoAgentBulkOperationsAddToNetworkJSONBody struct {
	// Specifies criteria you wish to filter agents on.
	Criteria *struct {
		// Indicates whether or not to match against all agents.
		AllAgents *bool `json:"all_agents,omitempty"`

		// Indicates how to combine the `filters` conditions. Possible values are `and` or `or`.
		FilterType *IoAgentBulkOperationsAddToNetworkJSONBodyCriteriaFilterType `json:"filter_type,omitempty"`

		// An array of string or numeric operations to match against agents. For example, `name:match:laptop` or `core_version:lt:10.0.0`.
		Filters *[]interface{} `json:"filters,omitempty"`

		// Additional filters that will always be added as `and` conditions.
		HardcodedFilters *[]interface{} `json:"hardcoded_filters,omitempty"`

		// A string used to match against all string-like attributes of an agent.
		Wildcard *string `json:"wildcard,omitempty"`
	} `json:"criteria,omitempty"`

	// An array of agent IDs or UUIDs to add to the criteria filter.
	Items *[]interface{} `json:"items,omitempty"`

	// An array of agent IDs or UUIDs to exclude from the criteria filter.
	NotItems *[]interface{} `json:"not_items,omitempty"`
}

// IoAgentBulkOperationsAddToNetworkJSONBodyCriteriaFilterType defines parameters for IoAgentBulkOperationsAddToNetwork.
type IoAgentBulkOperationsAddToNetworkJSONBodyCriteriaFilterType string

// IoAgentBulkOperationsDirectiveJSONBody defines parameters for IoAgentBulkOperationsDirective.
type IoAgentBulkOperationsDirectiveJSONBody struct {
	// Specifies criteria you wish to filter agents on.
	Criteria *struct {
		// Indicates whether or not to match against all agents.
		AllAgents *bool `json:"all_agents,omitempty"`

		// Indicates how to combine the `filters` conditions. Possible values are `and` or `or`.
		FilterType *IoAgentBulkOperationsDirectiveJSONBodyCriteriaFilterType `json:"filter_type,omitempty"`

		// An array of string or numeric operations to match against agents. For example, `name:match:laptop` or `core_version:lt:10.0.0`.
		Filters *[]interface{} `json:"filters,omitempty"`

		// Additional filters that will always be added as `and` conditions.
		HardcodedFilters *[]interface{} `json:"hardcoded_filters,omitempty"`

		// A string used to match against all string-like attributes of an agent.
		Wildcard *string `json:"wildcard,omitempty"`
	} `json:"criteria,omitempty"`

	// Specifies the instructions you wish to send to the agents.
	Directive *struct {
		// Additional information about the instruction to perform. For example, if the `type` is `restart`, you can use the options `"hard": true` or `"idle": true`.
		Options *map[string]interface{} `json:"options,omitempty"`

		// The type of instruction to perform. Possible instructions are `restart` and `settings`.
		Type *IoAgentBulkOperationsDirectiveJSONBodyDirectiveType `json:"type,omitempty"`
	} `json:"directive,omitempty"`

	// An array of agent IDs or UUIDs to add to the criteria filter.
	Items *[]interface{} `json:"items,omitempty"`

	// An array of agent IDs or UUIDs to exclude from the criteria filter.
	NotItems *[]interface{} `json:"not_items,omitempty"`
}

// IoAgentBulkOperationsDirectiveJSONBodyCriteriaFilterType defines parameters for IoAgentBulkOperationsDirective.
type IoAgentBulkOperationsDirectiveJSONBodyCriteriaFilterType string

// IoAgentBulkOperationsDirectiveJSONBodyDirectiveType defines parameters for IoAgentBulkOperationsDirective.
type IoAgentBulkOperationsDirectiveJSONBodyDirectiveType string

// IoAgentBulkOperationsRemoveFromNetworkJSONBody defines parameters for IoAgentBulkOperationsRemoveFromNetwork.
type IoAgentBulkOperationsRemoveFromNetworkJSONBody struct {
	// Specifies criteria you wish to filter agents on.
	Criteria *struct {
		// Indicates whether or not to match against all agents.
		AllAgents *bool `json:"all_agents,omitempty"`

		// Indicates how to combine the `filters` conditions. Possible values are `and` or `or`.
		FilterType *IoAgentBulkOperationsRemoveFromNetworkJSONBodyCriteriaFilterType `json:"filter_type,omitempty"`

		// An array of string or numeric operations to match against agents. For example, `name:match:laptop` or `core_version:lt:10.0.0`.
		Filters *[]interface{} `json:"filters,omitempty"`

		// Additional filters that will always be added as `and` conditions.
		HardcodedFilters *[]interface{} `json:"hardcoded_filters,omitempty"`

		// A string used to match against all string-like attributes of an agent.
		Wildcard *string `json:"wildcard,omitempty"`
	} `json:"criteria,omitempty"`

	// An array of agent IDs or UUIDs to add to the criteria filter.
	Items *[]interface{} `json:"items,omitempty"`

	// An array of agent IDs or UUIDs to exclude from the criteria filter.
	NotItems *[]interface{} `json:"not_items,omitempty"`
}

// IoAgentBulkOperationsRemoveFromNetworkJSONBodyCriteriaFilterType defines parameters for IoAgentBulkOperationsRemoveFromNetwork.
type IoAgentBulkOperationsRemoveFromNetworkJSONBodyCriteriaFilterType string

// BulkUnlinkAgentsJSONBody defines parameters for BulkUnlinkAgents.
type BulkUnlinkAgentsJSONBody struct {
	// Specifies criteria you wish to filter agents on.
	Criteria *struct {
		// Indicates whether or not to match against all agents.
		AllAgents *bool `json:"all_agents,omitempty"`

		// Indicates how to combine the `filters` conditions. Possible values are `and` or `or`.
		FilterType *BulkUnlinkAgentsJSONBodyCriteriaFilterType `json:"filter_type,omitempty"`

		// An array of string or numeric operations to match against agents. For example, `name:match:laptop` or `core_version:lt:10.0.0`.
		Filters *[]interface{} `json:"filters,omitempty"`

		// Additional filters that will always be added as `and` conditions.
		HardcodedFilters *[]interface{} `json:"hardcoded_filters,omitempty"`

		// A string used to match against all string-like attributes of an agent.
		Wildcard *string `json:"wildcard,omitempty"`
	} `json:"criteria,omitempty"`

	// An array of agent IDs or UUIDs to add to the criteria filter.
	Items *[]interface{} `json:"items,omitempty"`

	// An array of agent IDs or UUIDs to exclude from the criteria filter.
	NotItems *[]interface{} `json:"not_items,omitempty"`
}

// BulkUnlinkAgentsJSONBodyCriteriaFilterType defines parameters for BulkUnlinkAgents.
type BulkUnlinkAgentsJSONBodyCriteriaFilterType string

// ScannersEditJSONBody defines parameters for ScannersEdit.
type ScannersEditJSONBody struct {
	// Specifies how often, in minutes, the scanner checks in with Tenable.io (Amazon Web Services scanners only).
	AwsUpdateInterval *int32 `json:"aws_update_interval,omitempty"`

	// Pass 1 to reboot the scanner and run the latest software update (only valid if automatic updates are disabled).
	FinishUpdate *int32 `json:"finish_update,omitempty"`

	// Pass 1 to force a plugin update.
	ForcePluginUpdate *int32 `json:"force_plugin_update,omitempty"`

	// Pass 1 to force a UI update.
	ForceUiUpdate *int32 `json:"force_ui_update,omitempty"`

	// Sets the registration code for the scanner.
	RegistrationCode *string `json:"registration_code,omitempty"`
}

// AgentGroupsCreateJSONBody defines parameters for AgentGroupsCreate.
type AgentGroupsCreateJSONBody struct {
	// The name of the agent group.
	Name string `json:"name"`
}

// AgentGroupListAgentsParams defines parameters for AgentGroupListAgents.
type AgentGroupListAgentsParams struct {
	// Apply a filter in the format `::`. For example, `field1:match:sometext` would match any records where the value of field1 contains `sometext`. You can use multiple query filters. For a list of supported filters, use the [GET /filters/scans/agents](ref:filters-agents-filters) endpoint.
	F *string `json:"f,omitempty"`

	// Filter type. If the filter type is `and`, the record is only returned if all filters match. If the filter type is `or`, the record is returned if any of the filters match.
	Ft *string `json:"ft,omitempty"`

	// Wildcard filter text. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the wildcard\_fields' values matches against the filter string, then the record matches the wildcard filter. For a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters. For example, if `w=wild&f=field1:match:one&f=field2:match:two&ft=or`, the record would match if the value of any supported wildcard\_fields contained `wild`, AND either field1's value contained `one` or field2's value contained `two`.
	W *string `json:"w,omitempty"`

	// A comma-delimited subset of wildcard\_fields to search when applying the wildcard filter. For example, `field1,field2`. If `w` is provided, but `wf` is not, then all wildcard\_fields' values are searched against the wildcard filter text.
	Wf *string `json:"wf,omitempty"`

	// The number of records to retrieve. If this parameter is omitted, Tenable.io uses the default value of `50`. The minimum supported limit is `1`, and the maximum supported limit is `5000`.
	Limit *int32 `json:"limit,omitempty"`

	// The starting record to retrieve. If this parameter is omitted, Tenable.io uses the default value of `0`.
	Offset *int32 `json:"offset,omitempty"`

	// The field you want to use to sort the results by along with the sort order. The field is specified first, followed by a colon, and the order is specified second (`asc` or `desc`). For example, `name:desc` would sort results by the `name` field in descending order.
	//
	// If you specify multiple fields, the fields must be separated by commas. For example, `name:desc,platform:asc` would first sort results by the `name` field in descending order and then by the `platform` field in ascending order.
	//
	// Sort can only be applied to the sortable_fields specified by the filter capabilities. There may be no more than max_sort_fields number of columns used in the sort, as specified by the filter capabilities.
	Sort *string `json:"sort,omitempty"`
}

// AgentGroupsDetailsParams defines parameters for AgentGroupsDetails.
type AgentGroupsDetailsParams struct {
	// Apply a filter in the format `::`. For example, `field1:match:sometext` would match any records where the value of field1 contains `sometext`. You can use multiple query filters.
	F *string `json:"f,omitempty"`

	// Filter type. If the filter type is `and`, the record is only returned if all filters match. If the filter type is `or`, the record is returned if any of the filters match.
	Ft *string `json:"ft,omitempty"`

	// Wildcard filter text. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the wildcard\_fields' values matches against the filter string, then the record matches the wildcard filter. For a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters. For example, if `w=wild&f=field1:match:one&f=field2:match:two&ft=or`, the record would match if the value of any supported wildcard\_fields contained `wild`, AND either field1's value contained `one` or field2's value contained `two`.
	W *string `json:"w,omitempty"`

	// A comma delimited subset of wildcard\_fields to search when applying the wildcard filter. For example, `field1,field2`. If `w` is provided, but `wf` is not, then all wildcard\_fields' values are searched against the wildcard filter text.
	Wf *string `json:"wf,omitempty"`

	// The number of records to retrieve. If this parameter is omitted, Tenable.io uses the default value of `50`. The minimum supported limit is `1`, and the maximum supported limit is `5000`.
	Limit *int32 `json:"limit,omitempty"`

	// The starting record to retrieve. If this parameter is omitted, Tenable.io uses the default value of `0`.
	Offset *int32 `json:"offset,omitempty"`

	// The field you want to use to sort the results by along with the sort order. The field is specified first, followed by a colon, and the order is specified second (`asc` or `desc`). For example, `name:desc` would sort results by the `name` field in descending order.
	//
	// If you specify multiple fields, the fields must be separated by commas. For example, `name:desc,creation_date:asc` would first sort results by the `name` field in descending order and then by the `creation_date` field in ascending order.
	//
	// Sort can only be applied to the sortable_fields specified by the filter capabilities. There may be no more than max_sort_fields number of columns used in the sort, as specified by the filter capabilities.
	Sort *string `json:"sort,omitempty"`
}

// AgentGroupsConfigureJSONBody defines parameters for AgentGroupsConfigure.
type AgentGroupsConfigureJSONBody struct {
	// The name for the agent group.
	Name string `json:"name"`
}

// AgentsListParams defines parameters for AgentsList.
type AgentsListParams struct {
	// Apply a filter in the format `::`. For example, `field1:match:sometext` would match any records where the value of field1 contains `sometext`. You can use multiple query filters. For a list of supported filters, use the [GET /filters/scans/agents](ref:filters-agents-filters) endpoint.
	F *string `json:"f,omitempty"`

	// Filter type. If the filter type is `and`, the record is only returned if all filters match. If the filter type is `or`, the record is returned if any of the filters match.
	Ft *string `json:"ft,omitempty"`

	// Wildcard filter text. Wildcard search is a mechanism where multiple fields of a record are filtered against one specific filter string. If any one of the wildcard\_fields' values matches against the filter string, then the record matches the wildcard filter. For a record to be returned, it must pass the wildcard filter (if there is one) AND the set of standard filters. For example, if `w=wild&f=field1:match:one&f=field2:match:two&ft=or`, the record would match if the value of any supported wildcard\_fields contained `wild`, AND either field1's value contained `one` or field2's value contained `two`.
	W *string `json:"w,omitempty"`

	// A comma-delimited subset of wildcard\_fields to search when applying the wildcard filter. For example, `field1,field2`. If `w` is provided, but `wf` is not, then all wildcard\_fields' values are searched against the wildcard filter text.
	Wf *string `json:"wf,omitempty"`

	// The number of records to retrieve. If this parameter is omitted, Tenable.io uses the default value of `50`. The minimum supported limit is `1`, and the maximum supported limit is `5000`.
	Limit *int32 `json:"limit,omitempty"`

	// The starting record to retrieve. If this parameter is omitted, Tenable.io uses the default value of `0`.
	Offset *int32 `json:"offset,omitempty"`

	// The field you want to use to sort the results by along with the sort order. The field is specified first, followed by a colon, and the order is specified second (`asc` or `desc`). For example, `name:desc` would sort results by the `name` field in descending order.
	//
	// If you specify multiple fields, the fields must be separated by commas. For example, `name:desc,platform:asc` would first sort results by the `name` field in descending order and then by the `platform` field in ascending order.
	//
	// Sort can only be applied to the sortable_fields specified by the filter capabilities. There may be no more than max_sort_fields number of columns used in the sort, as specified by the filter capabilities.
	Sort *string `json:"sort,omitempty"`
}

// AgentConfigEditJSONBody defines parameters for AgentConfigEdit.
type AgentConfigEditJSONBody struct {
	AutoUnlink *struct {
		// If true, agent auto-unlink is enabled. Enabling auto-unlink causes it to take effect against all agents retroactively.
		Enabled *bool `json:"enabled,omitempty"`

		// The expiration time for agents, in days. If an agent has not communicated in this number of days, it will be considered `expired` and auto-unlinked if auto\_unlink.enabled is `true`. Valid values are 1-365.
		Expiration *int32 `json:"expiration,omitempty"`
	} `json:"auto_unlink,omitempty"`

	// If true, software updates are enabled for agents pursuant to any agent exclusions that are in effect. If false, software updates are disabled for all agents, even if no agent exclusions are in effect.
	SoftwareUpdate *bool `json:"software_update,omitempty"`
}

// AgentExclusionsCreateJSONBody defines parameters for AgentExclusionsCreate.
type AgentExclusionsCreateJSONBody struct {
	// The description of the exclusion.
	Description *string `json:"description,omitempty"`

	// The name of the exclusion.
	Name     string `json:"name"`
	Schedule struct {
		// If true, the exclusion is scheduled.
		Enabled *bool `json:"enabled,omitempty"`

		// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
		Endtime *string `json:"endtime,omitempty"`
		Rrules  struct {
			// The day of the month to repeat a MONTHLY freq rule on.
			Bymonthday *int `json:"bymonthday,omitempty"`

			// A comma separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
			Byweekday *string `json:"byweekday,omitempty"`

			// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
			Freq AgentExclusionsCreateJSONBodyScheduleRrulesFreq `json:"freq"`

			// The interval of the rule.
			Interval *int `json:"interval,omitempty"`
		} `json:"rrules"`

		// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
		Starttime string `json:"starttime"`

		// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
		Timezone string `json:"timezone"`
	} `json:"schedule"`
}

// AgentExclusionsCreateJSONBodyScheduleRrulesFreq defines parameters for AgentExclusionsCreate.
type AgentExclusionsCreateJSONBodyScheduleRrulesFreq string

// AgentExclusionsEditJSONBody defines parameters for AgentExclusionsEdit.
type AgentExclusionsEditJSONBody struct {
	// The description of the exclusion.
	Description *string `json:"description,omitempty"`

	// The name of the exclusion.
	Name     *string `json:"name,omitempty"`
	Schedule struct {
		// If true, the exclusion is scheduled.
		Enabled *bool `json:"enabled,omitempty"`

		// The end time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
		Endtime *string `json:"endtime,omitempty"`
		Rrules  struct {
			// The day of the month to repeat a MONTHLY freq rule on.
			Bymonthday *int `json:"bymonthday,omitempty"`

			// A comma separated string of days to repeat a WEEKLY freq rule on (SU,MO,TU,WE,TH,FR, or SA).
			Byweekday *string `json:"byweekday,omitempty"`

			// The frequency of the rule (ONETIME, DAILY, WEEKLY, MONTHLY, YEARLY).
			Freq AgentExclusionsEditJSONBodyScheduleRrulesFreq `json:"freq"`

			// The interval of the rule.
			Interval *int `json:"interval,omitempty"`
		} `json:"rrules"`

		// The start time of the exclusion formatted as `YYYY-MM-DD HH:MM:SS`.
		Starttime string `json:"starttime"`

		// The timezone for the exclusion as returned by [scans: timezones](ref:scans-timezones).
		Timezone string `json:"timezone"`
	} `json:"schedule"`
}

// AgentExclusionsEditJSONBodyScheduleRrulesFreq defines parameters for AgentExclusionsEdit.
type AgentExclusionsEditJSONBodyScheduleRrulesFreq string

// ScannersToggleLinkStateJSONBody defines parameters for ScannersToggleLinkState.
type ScannersToggleLinkStateJSONBody struct {
	// Pass `1` enable the link. Pass `0` to disable.
	Link int32 `json:"link"`
}

// ScannersControlScansJSONBody defines parameters for ScannersControlScans.
type ScannersControlScansJSONBody struct {
	// An action to perform on a scan. Valid values are `stop`, `pause`, and `resume`.
	Action string `json:"action"`
}

// ScansListParams defines parameters for ScansList.
type ScansListParams struct {
	// The ID of the folder where the scans you want to list are stored.
	FolderId *int `json:"folder_id,omitempty"`

	// Limit the results to those scans that have run since the specified time. This parameter does not represent the date on which the scan configuration was last modified. Must be in Unix time format.
	LastModificationDate *int `json:"last_modification_date,omitempty"`
}

// ScansCreateJSONBody defines parameters for ScansCreate.
type ScansCreateJSONBody struct {
	// An object that specifies credential parameters that enable a scanner to authenticate a connection to a target host.
	Credentials *struct {
		// A credentials object you want to add to the scan. For scan-specific credentials, the parameters of the object vary based on credentials category, credentials type, and type-specific settings. For more information, see [Determine Settings for a Credential Type](doc:determine-settings-for-credential-type). For managed credentials, the object contains a single parameter `id`, which specifies the UUID of the managed credentials you want to add.
		//
		// **Note:** This form displays limited parameters that support a Windows type of credentials that uses password authentication.
		Add *struct {
			// The name of this parameter corresponds to the display name that uniquely identifies the credentials category (in this case, `Host` for credentials from the Host category). This value corresponds to the following response message attributes:
			//  - `credentials[].data[].name` in the [GET /editor/type/templates/{template_uuid}](/reference#editor-template-details) response message
			//  - `credentials[].id` in the [GET /credentials/types](/reference#credentials-list-credential-types) response message
			Host *struct {
				// The name of this parameter corresponds to the display name that uniquely identifies the credentials type (in this case, `Windows` for a Windows credential). This value corresponds to the following response message attributes:
				//  - `credentials[].data[].types[].name` in the [GET /editor/type/templates/{template_uuid}](/reference#editor-template-details) response message
				//  - `credentials[].types[].id` in the [GET /credentials/types](/reference#credentials-list-credential-types) response message`
				Windows *[]struct {
					// The name for the authentication method. This value corresponds to the credentials[].types[].configuration[].options[].id attribute in the response message for the [GET /credentials/types](/reference#credentials-list-credential-types) endpoint.
					AuthMethod *ScansCreateJSONBodyCredentialsAddHostWindowsAuthMethod `json:"auth_method,omitempty"`

					// The Windows domain to which the username belongs.
					Domain *string `json:"domain,omitempty"`

					// The user password on the target system.
					Password *string `json:"password,omitempty"`

					// The username on the target system.
					Username *string `json:"username,omitempty"`
				} `json:"Windows,omitempty"`
			} `json:"Host,omitempty"`
		} `json:"add,omitempty"`
	} `json:"credentials,omitempty"`

	// A list of plugins to add to the non-remediation scans. Use the [GET /plugins/families](ref:io-plugins-families-list) endpoint to get a list of plugin families to choose from. Then, use the [GET /plugins/families/{id}](ref:io-plugins-family-details) endpoint to find plugins within the family to add to the scan.
	//
	// **Note:** This form displays limited parameters. The example below illustrates how to add two plugins within the `Web Servers` plugin family to a scan.
	Plugins *struct {
		// A list of plugin families containing individual plugins to add to the scan. Use the [GET /plugins/families](ref:io-plugins-families-list) endpoint to get a list of plugin families.
		WebServers *struct {
			// A list of individual plugins within the specified plugin family.
			Individual *struct {
				// The status (`enabled` or `disabled`) of the individual plugin within the plugin family to add to the scan.
				N11213 *ScansCreateJSONBodyPluginsWebServersIndividual11213 `json:"11213,omitempty"`

				// The status (`enabled` or `disabled`) of the individual plugin within the plugin family to add to the scan.
				N18261 *ScansCreateJSONBodyPluginsWebServersIndividual18261 `json:"18261,omitempty"`
			} `json:"individual,omitempty"`
		} `json:"Web Servers,omitempty"`
	} `json:"plugins,omitempty"`
	Settings struct {
		// An array containing permissions to apply to the scan.
		Acls *[]struct {
			// The name of the user or group granted the specified permissions, as it appears in the Tenable.io user interface.
			DisplayName *string `json:"display_name,omitempty"`

			// A number representing the order in which the user or user groups display in the Permissions tab in the Tenable.io user interface.
			Id *int `json:"id,omitempty"`

			// The name of the user or group granted the specified permissions.
			Name *string `json:"name,omitempty"`

			// A value that indicates whether the user or user group specified in the object owns the scan. Possible values include: `null` (system-owned permissions), `0` (the user is not the owner of the scan), `1` (the user is the owner of the scan).
			Owner *int `json:"owner,omitempty"`

			// The scan permission. For more information, see [Permissions](doc:permissions).
			Permissions *int `json:"permissions,omitempty"`

			// The type of scan permissions: `default` (default permissions for the scan), `user` (permissions for an individual user), or `group` (permissions for a user group).
			Type *string `json:"type,omitempty"`
		} `json:"acls,omitempty"`

		// An array of agent group UUIDs to scan. Required if the scan is an agent scan.
		AgentGroupId *[]string `json:"agent_group_id,omitempty"`

		// The description of the scan.
		Description *string `json:"description,omitempty"`

		// A comma-separated list of accounts that receive the email summary report.
		Emails *string `json:"emails,omitempty"`

		// If `true`, the schedule for the scan is enabled. If you omit this parameter from the request, Tenable.io assigns the default value `true`. This parameter corresponds to the **Enabled** toggle in scan schedule settings in the Tenable.io user interface. Note that scheduled scans do not run if they are in the scan owner's trash folder.
		Enabled bool `json:"enabled"`

		// The name of a file containing the list of targets to scan. Before you use this parameter, use the [POST /files/upload](ref:file-upload) endpoint to upload the file to Tenable.io; then, use the `fileuploaded` attribute of the response message as the `file_targets` parameter value.
		//
		// This parameter is required if your request omits other target parameters. For more information, see "Required Scan Target Parameters" in [Create a Scan](doc:create-scan-tio).
		//
		//  **Note:** Unicode/UTF-8 encoding is not supported in the targets file.
		FileTargets *string `json:"file_targets,omitempty"`

		// The unique ID of the folder where you want to store the scan. Use the [GET /folders](ref:folders-list) endpoint to find the folder ID. If you omit this parameter from the request, Tenable.io assigns the ID of the Tenable-provided `main` folder.
		FolderId *int32 `json:"folder_id,omitempty"`

		// When to launch the scan. Possible values are: ON\_DEMAND, DAILY, WEEKLY, MONTHLY, YEARLY. Note that scheduled scans do not run if they are in the scan owner's trash folder.
		Launch *ScansCreateJSONBodySettingsLaunch `json:"launch,omitempty"`

		// The name of the scan.
		Name string `json:"name"`

		// The unique ID of the policy to use to create the scan. If your user permissions are set to SCAN OPERATOR [24], this parameter is required. Use the [GET /policies](ref:policies-list) endpoint to find the policy ID.
		PolicyId *int32 `json:"policy_id,omitempty"`

		// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
		//
		// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
		Rrules *string `json:"rrules,omitempty"`

		// The time frame, in minutes, during which agents must transmit scan results to Tenable.io in order to be included in dashboards and reports. If your request omits this parameter, the default value is 180 minutes. For non-agent scans, this attribute is null.
		ScanTimeWindow *int `json:"scan_time_window,omitempty"`

		// The unique ID of the scanner to use. Use the [GET /scanners](ref:scanners-list) endpoint to find the scanner ID. You can use the special value `AUTO-ROUTED` to assign scan targets to scanner groups based on the groups' configured scan routes. For more information, see [Manage Scan Routing](doc:manage-scan-routing-tio).
		//
		// **Note:** If you omit this parameter from the request, Tenable.io assigns the US Cloud Scanner by default.
		ScannerId *string `json:"scanner_id,omitempty"`

		// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` parameter.
		//
		// This parameter must be in the following format: `YYYYMMDDTHHMMSS`.
		//
		// This parameter corresponds to the **Starts** drop-down boxes in scan schedule settings in the Tenable.io user interface.
		Starttime *string `json:"starttime,omitempty"`

		// The list of asset tag identifiers that the scan uses to determine which assets it evaluates. For more information about tag-based scans, see [Manage Tag-Based Scans](doc:manage-tag-based-scans-tio).
		//
		// This parameter is required if your request omits other target parameters. For more information, see "Required Scan Target Parameters" in [Create a Scan](doc:create-scan-tio).
		TagTargets *[]string `json:"tag_targets,omitempty"`

		// An array of target group IDs to scan. Use the [GET /target-groups](/reference#target-groups-list) endpoint to determine target group IDs. This parameter is required if your request omits other target parameters. For more information, see "Required Scan Target Parameters" in [Create a Scan](doc:create-scan-tio).
		TargetGroups *[]int `json:"target_groups,omitempty"`

		// This field is required if the `scanner_id` parameter is `AUTO-ROUTED`. Specify a value as follows:<ul><li>If your scans involve separate environments with overlapping IP ranges, specify the UUID of the [network](doc:manage-networks-tio) you want to associate with the results of the auto-routed scan. This value must match the network where you have assigned the scanner groups that you configured for scan routing.</li><li>Otherwise, specify the default network (`00000000-0000-0000-0000-000000000000`).</li></ul>
		//
		// **Note:** This parameter does not override network associations for scans that are not auto-routed. Tenable.io automatically associates a non-routed scan with the network to which you have assigned the scanner that performs the scan.
		TargetNetworkUuid *string `json:"target_network_uuid,omitempty"`

		// The list of targets to scan. For a full list of supported target formats, see the [Tenable.io Vulnerability Management User Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AboutScanTargets.htm). You can specify multiple targets (of differing formats) as a comma-delimited list.
		//
		// This parameter is required if your request omits other target parameters. For more information, see "Required Scan Target Parameters" in [Create a Scan](doc:create-scan-tio).
		//
		// **Note:** Tenable.io does not perform validation on values you submit for this parameter. If you submit invalid values, Tenable.io stores the invalid values in the scan configuration, and when the scan runs, scanning fails on the invalid targets.
		TextTargets *string `json:"text_targets,omitempty"`

		// The timezone of the scheduled start time for the scan (as specified in the `starttime` parameter). Use the [GET /scans/timezones](ref:scans-timezones) endpoint to determine this value.
		//
		//  Corresponds to the **Timezone** drop-down box in the scan schedule settings in the Tenable.io user interface.
		Timezone *string `json:"timezone,omitempty"`
	} `json:"settings"`

	// The UUID for the Tenable-provided scan template to use. Use the [GET /editor/scan/templates](ref:editor-list-templates) endpoint to find the template UUID.
	Uuid string `json:"uuid"`
}

// ScansCreateJSONBodyCredentialsAddHostWindowsAuthMethod defines parameters for ScansCreate.
type ScansCreateJSONBodyCredentialsAddHostWindowsAuthMethod string

// ScansCreateJSONBodyPluginsWebServersIndividual11213 defines parameters for ScansCreate.
type ScansCreateJSONBodyPluginsWebServersIndividual11213 string

// ScansCreateJSONBodyPluginsWebServersIndividual18261 defines parameters for ScansCreate.
type ScansCreateJSONBodyPluginsWebServersIndividual18261 string

// ScansCreateJSONBodySettingsLaunch defines parameters for ScansCreate.
type ScansCreateJSONBodySettingsLaunch string

// IoScansCheckAutoTargetsJSONBody defines parameters for IoScansCheckAutoTargets.
type IoScansCheckAutoTargetsJSONBody struct {
	// Specify a value as follows:<ul><li>If your scans involve separate environments with overlapping IP ranges, specify the UUID of the [network](doc:manage-networks-tio) you want to associate with the results of the auto-routed scan. This value must match the network where you have assigned the scanner groups that you configured for scan routing.</li><li>Otherwise, specify the default network (00000000-0000-0000-0000-000000000000).</li></ul>
	NetworkUuid string `json:"network_uuid"`

	// A list of asset tags UUIDs.
	Tags *[]string `json:"tags,omitempty"`

	// A comma-delimited list of targets to scan. For a full list of supported target formats, see the [Tenable.io Vulnerability Management User Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AboutScanTargets.htm).
	TextTargets *string `json:"text_targets,omitempty"`
}

// IoScansCheckAutoTargetsParams defines parameters for IoScansCheckAutoTargets.
type IoScansCheckAutoTargetsParams struct {
	// Limit the number of missed targets returned in the response.
	Limit *int32 `json:"limit,omitempty"`

	// Limit the number of matched resource UUIDs returned in the response.
	MatchedResourceLimit *int32 `json:"matched_resource_limit,omitempty"`
}

// ScansImportJSONBody defines parameters for ScansImport.
type ScansImportJSONBody struct {
	// The name of the file to import as provided by the response from [Upload File](ref:file-upload) endpoint.
	File string `json:"file"`

	// The ID of the destination folder. If you omit this parameter, Tenable.io stores the imported scan in the default folder.
	FolderId *int32 `json:"folder_id,omitempty"`

	// The password for the file to import (required for nessus.db).
	Password *string `json:"password,omitempty"`
}

// ScansImportParams defines parameters for ScansImport.
type ScansImportParams struct {
	// Specifies whether to include the imported scan data in the vulnerabilities dashboard views. To include, use `1`. To exclude, use `0`. If you don't specify the include_aggregate parameter, the data does not appear in the dashboard.
	IncludeAggregate *ScansImportParamsIncludeAggregate `json:"include_aggregate,omitempty"`
}

// ScansImportParamsIncludeAggregate defines parameters for ScansImport.
type ScansImportParamsIncludeAggregate int

// IoScansRemediationListParams defines parameters for IoScansRemediationList.
type IoScansRemediationListParams struct {
	// The number of records to retrieve. Minimum value is `1`. Maximum value is `200`. If this parameter is omitted, Tenable.io uses the default value of `50`.
	Limit *int `json:"limit,omitempty"`

	// The starting record to retrieve. Minimum value is `0`. If this parameter is omitted, Tenable.io uses the default value of `0`.
	Offset *int `json:"offset,omitempty"`

	// The field you want to sort the results by along with the sort order. Valid sort fields: `scan_creation_date`. Valid sort orders: `desc`, `asc`. `scan_creation_date` is the Unix timestamp when the remediation scan run was created. If this parameter is omitted, Tenable.io uses the default value of `scan_creation_date:desc`.
	Sort *IoScansRemediationListParamsSort `json:"sort,omitempty"`
}

// IoScansRemediationListParamsSort defines parameters for IoScansRemediationList.
type IoScansRemediationListParamsSort string

// IoScansRemediationCreateJSONBody defines parameters for IoScansRemediationCreate.
type IoScansRemediationCreateJSONBody struct {
	// An object that specifies credential parameters that enable a scanner to authenticate a connection to a target host.
	Credentials *struct {
		// A credentials object you want to add to the scan. For scan-specific credentials, the parameters of the object vary based on credentials category, credentials type, and type-specific settings. For more information, see [Determine Settings for a Credential Type](doc:determine-settings-for-credential-type). For managed credentials, the object contains a single parameter `id`, which specifies the UUID of the managed credentials you want to add.
		//
		// **Note:** This form displays limited parameters that support a Windows type of credentials that uses password authentication.
		Add *struct {
			// The name of this parameter corresponds to the display name that uniquely identifies the credentials category (in this case, `Host` for credentials from the Host category). This value corresponds to the following response message attributes:
			//  - `credentials[].data[].name` in the [GET /editor/type/templates/{template_uuid}](/reference#editor-template-details) response message
			//  - `credentials[].id` in the [GET /credentials/types](/reference#credentials-list-credential-types) response message
			Host *struct {
				// The name of this parameter corresponds to the display name that uniquely identifies the credentials type (in this case, `Windows` for a Windows credential). This value corresponds to the following response message attributes:
				//  - `credentials[].data[].types[].name` in the [GET /editor/type/templates/{template_uuid}](/reference#editor-template-details) response message
				//  - `credentials[].types[].id` in the [GET /credentials/types](/reference#credentials-list-credential-types) response message`
				Windows *[]struct {
					// The name for the authentication method. This value corresponds to the credentials[].types[].configuration[].options[].id attribute in the response message for the [GET /credentials/types](/reference#credentials-list-credential-types) endpoint.
					AuthMethod *IoScansRemediationCreateJSONBodyCredentialsAddHostWindowsAuthMethod `json:"auth_method,omitempty"`

					// The Windows domain to which the username belongs.
					Domain *string `json:"domain,omitempty"`

					// The user password on the target system.
					Password *string `json:"password,omitempty"`

					// The username on the target system.
					Username *string `json:"username,omitempty"`
				} `json:"Windows,omitempty"`
			} `json:"Host,omitempty"`
		} `json:"add,omitempty"`
	} `json:"credentials,omitempty"`

	// A comma-delimited list of plugins IDs to add to a remediation scan. You can use the [GET /plugins/families](ref:io-plugins-families-list) and [GET /plugins/families/{id}](ref:io-plugins-family-details) endpoints to get a list of plugin families and plugins to add to the scan.
	//
	// **Note:** This parameter is only valid for remediation scans. For more information on remediation scans and examples, see [Manage Remediation Scans](doc:io-manage-remediation-scans).
	EnabledPlugins *[]int `json:"enabled_plugins,omitempty"`
	Settings       struct {
		// An array containing permissions to apply to the scan.
		Acls *[]struct {
			// The name of the user or group granted the specified permissions, as it appears in the Tenable.io user interface.
			DisplayName *string `json:"display_name,omitempty"`

			// A number representing the order in which the user or user groups display in the Permissions tab in the Tenable.io user interface.
			Id *int `json:"id,omitempty"`

			// The name of the user or group granted the specified permissions.
			Name *string `json:"name,omitempty"`

			// A value that indicates whether the user or user group specified in the object owns the scan. Possible values include: `null` (system-owned permissions), `0` (the user is not the owner of the scan), `1` (the user is the owner of the scan).
			Owner *int `json:"owner,omitempty"`

			// The scan permission. For more information, see [Permissions](doc:permissions).
			Permissions *int `json:"permissions,omitempty"`

			// The type of scan permissions: `default` (default permissions for the scan), `user` (permissions for an individual user), or `group` (permissions for a user group).
			Type *string `json:"type,omitempty"`
		} `json:"acls,omitempty"`

		// An array of agent group UUIDs to scan. Required if the scan is an agent scan.
		AgentGroupId *[]string `json:"agent_group_id,omitempty"`

		// The description of the scan.
		Description *string `json:"description,omitempty"`

		// A comma-separated list of accounts that receive the email summary report.
		Emails *string `json:"emails,omitempty"`

		// The name of a file containing the list of targets to scan. Before you use this parameter, use the [POST /files/upload](ref:file-upload) endpoint to upload the file to Tenable.io; then, use the `fileuploaded` attribute of the response message as the `file_targets` parameter value.
		//
		// This parameter is required if your request omits other target parameters. For more information, see "Required Scan Target Parameters" in [Create a Scan](doc:create-scan-tio).
		//
		//  **Note:** Unicode/UTF-8 encoding is not supported in the targets file.
		FileTargets *string `json:"file_targets,omitempty"`

		// The name of the scan.
		Name string `json:"name"`

		// The unique ID of the policy to use to create the scan. If your user permissions are set to SCAN OPERATOR [24], this parameter is required. Use the [GET /policies](ref:policies-list) endpoint to find the policy ID.
		PolicyId *int32 `json:"policy_id,omitempty"`

		// The time frame, in minutes, during which agents must transmit scan results to Tenable.io in order to be included in dashboards and reports. If your request omits this parameter, the default value is 180 minutes. For non-agent scans, this attribute is null.
		ScanTimeWindow *int `json:"scan_time_window,omitempty"`

		// The unique ID of the scanner to use. Use the [GET /scanners](ref:scanners-list) endpoint to find the scanner ID. You can use the special value `AUTO-ROUTED` to assign scan targets to scanner groups based on the groups' configured scan routes. For more information, see [Manage Scan Routing](doc:manage-scan-routing-tio).
		//
		// **Note:** If you omit this parameter from the request, Tenable.io assigns the US Cloud Scanner by default.
		ScannerId *string `json:"scanner_id,omitempty"`

		// The list of asset tag identifiers that the scan uses to determine which assets it evaluates. For more information about tag-based scans, see [Manage Tag-Based Scans](doc:manage-tag-based-scans-tio).
		//
		// This parameter is required if your request omits other target parameters. For more information, see "Required Scan Target Parameters" in [Create a Scan](doc:create-scan-tio).
		TagTargets *[]string `json:"tag_targets,omitempty"`

		// For remediation scans, enter a valid target group ID from a previous scan you wish to remediate.
		TargetGroups *[]int `json:"target_groups,omitempty"`

		// For remediation scans, enter a valid target network UUID from a previous scan you wish to remediate.
		TargetNetworkUuid *string `json:"target_network_uuid,omitempty"`

		// The list of targets to scan. For a full list of supported target formats, see the [Tenable.io Vulnerability Management User Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AboutScanTargets.htm). You can specify multiple targets (of differing formats) as a comma-delimited list.
		//
		// This parameter is required if your request omits other target parameters. For more information, see "Required Scan Target Parameters" in [Create a Scan](doc:create-scan-tio).
		//
		//  For remediation scans, enter a valid target from a previous scan you wish to remediate.
		//
		// **Note:** Tenable.io does not perform validation on values you submit for this parameter. If you submit invalid values, Tenable.io stores the invalid values in the scan configuration, and when the scan runs, scanning fails on the invalid targets.
		TextTargets *string `json:"text_targets,omitempty"`
	} `json:"settings"`

	// The UUID for the Tenable-provided remediation scan template to use. Use the [GET /editor/remediation/templates](ref:editor-list-templates) endpoint to find remediation scan template UUIDs.
	Uuid string `json:"uuid"`
}

// IoScansRemediationCreateJSONBodyCredentialsAddHostWindowsAuthMethod defines parameters for IoScansRemediationCreate.
type IoScansRemediationCreateJSONBodyCredentialsAddHostWindowsAuthMethod string

// ScansDetailsParams defines parameters for ScansDetails.
type ScansDetailsParams struct {
	// The unique identifier of the historical data that you want Tenable.io to return. This identifier corresponds to the `history.id` attribute of the response message from the [GET /scans/{scan_id}/history](ref:scans-history) endpoint. You can use either this parameter or the `history_uuid` query parameter to specify a scan run.
	HistoryId *int32 `json:"history_id,omitempty"`

	// The UUID of the historical data that you want Tenable.io to return. This identifier corresponds to the `history.scan_uuid` attribute of the response message from the [GET /scans/{scan_id}/history](ref:scans-history) endpoint. You can use either this parameter or the `history_id` query parameter to specify a scan run.
	HistoryUuid *string `json:"history_uuid,omitempty"`
}

// ScansConfigureJSONBody defines parameters for ScansConfigure.
type ScansConfigureJSONBody struct {
	// An object that specifies credential parameters that enable a scanner to authenticate a connection to a target host.
	Credentials *struct {
		// A credentials object you want to add to the scan. The parameters of the object vary based on credentials category, credentials type, and type-specific settings. For more information, see [Add Credentials to a Scan](doc:add-credentials-to-scan).
		//
		// **Note:** This form displays limited parameters that support a Windows type of credentials that uses password authentication.
		Add *struct {
			// The name of this parameter corresponds to the display name that uniquely identifies the credentials category (in this case, `Host` for credentials from the Host category). This value corresponds to the following response message attributes:
			//  - `credentials[].data[].name` in the [GET /editor/type/templates/{template_uuid}](/reference#editor-template-details) response message
			//  - `credentials[].id` in the [GET /credentials/types](/reference#credentials-list-credential-types) response message
			Host *struct {
				// The name of this parameter corresponds to the display name that uniquely identifies the credentials type (in this case, `Windows` for a Windows credential). This value corresponds to the following response message attributes:
				//  - `credentials[].data[].types[].name` in the [GET /editor/type/templates/{template_uuid}](/reference#editor-template-details) response message
				//  - `credentials[].types[].id` in the [GET /credentials/types](/reference#credentials-list-credential-types) response message`
				Windows *[]struct {
					// The name for the authentication method. This value corresponds to the credentials[].types[].configuration[].options[].id attribute in the response message for the [GET /credentials/types](/reference#credentials-list-credential-types) endpoint.
					AuthMethod *ScansConfigureJSONBodyCredentialsAddHostWindowsAuthMethod `json:"auth_method,omitempty"`

					// The Windows domain to which the username belongs.
					Domain *string `json:"domain,omitempty"`

					// The user password on the target system.
					Password *string `json:"password,omitempty"`

					// The username on the target system.
					Username *string `json:"username,omitempty"`
				} `json:"Windows,omitempty"`
			} `json:"Host,omitempty"`
		} `json:"add,omitempty"`

		// A list of identifiers for the credentials you want to remove from the scan. For more information, see [Remove Credentials from a Scan](doc:remove-credentials-from-scan-tio).
		Delete *[]string `json:"delete,omitempty"`

		// A scan-specific credentials object you want to modify. The parameters of the object vary based on credential category, credential type, and type-specific settings. For more information, see [Update a Scan](doc:update-scan-tio).
		//
		//  **Note:** This parameter is not supported for use with managed credentials. For more information about editing managed credentials, see [Edit Managed Credentials](doc:edit-managed-credentials-tio).
		Edit *map[string]interface{} `json:"edit,omitempty"`
	} `json:"credentials,omitempty"`

	// A list of plugins to add to the non-remediation scans. Use the [GET /plugins/families](ref:io-plugins-families-list) endpoint to get a list of plugin families to choose from. Then, use the [GET /plugins/families/{id}](ref:io-plugins-family-details) endpoint to find plugins within the family to add to the scan.
	//
	// **Note:** This form displays limited parameters. The example below illustrates how to add two plugins within the `Web Servers` plugin family to a scan.
	Plugins *struct {
		// A list of plugin families containing individual plugins to add to the scan. Use the [GET /plugins/families](ref:io-plugins-families-list) endpoint to get a list of plugin families.
		WebServers *struct {
			// A list of individual plugins within the specified plugin family.
			Individual *struct {
				// The status (`enabled` or `disabled`) of the individual plugin within the plugin family to add to the scan.
				N11213 *ScansConfigureJSONBodyPluginsWebServersIndividual11213 `json:"11213,omitempty"`

				// The status (`enabled` or `disabled`) of the individual plugin within the plugin family to add to the scan.
				N18261 *ScansConfigureJSONBodyPluginsWebServersIndividual18261 `json:"18261,omitempty"`
			} `json:"individual,omitempty"`
		} `json:"Web Servers,omitempty"`
	} `json:"plugins,omitempty"`
	Settings struct {
		// An array containing sharing permissions to apply to the scan.
		Acls *[]struct {
			// The name of the user or group granted the specified permissions, as it appears in the Tenable.io user interface.
			DisplayName *string `json:"display_name,omitempty"`

			// A number representing the order in which the user or user groups display in the Permissions tab in the Tenable.io user interface.
			Id *int `json:"id,omitempty"`

			// The name of the user or group granted the specified permissions.
			Name *string `json:"name,omitempty"`

			// A value that indicates whether the user or user group specified in the object owns the scan. Possible values include: `null` (system-owned permissions), `0` (the user is not the owner of the scan), `1` (the user is the owner of the scan).
			Owner *int `json:"owner,omitempty"`

			// The scan permission. For more information, see [Permissions](doc:permissions).
			Permissions *int `json:"permissions,omitempty"`

			// The type of scan permissions: `default` (default permissions for the scan), `user` (permissions for an individual user), or `group` (permissions for a user group).
			Type *string `json:"type,omitempty"`
		} `json:"acls,omitempty"`

		// An array of agent group UUIDs to scan. Required if the scan is an agent scan.
		AgentGroupId *[]string `json:"agent_group_id,omitempty"`

		// The description of the scan.
		Description *string `json:"description,omitempty"`

		// A comma-separated list of accounts that receive the email summary report.
		Emails *string `json:"emails,omitempty"`

		// If `true`, the schedule for the scan is enabled. Note that scheduled scans do not run if they are in the scan owner's trash folder.
		Enabled *bool `json:"enabled,omitempty"`

		// The name of a file containing the list of targets to scan. Before you use this parameter, use the [POST /files/upload](ref:file-upload) endpoint to upload the file to Tenable.io; then, use the `fileuploaded` attribute of the response message as the `file_targets` parameter value.
		//
		//
		//
		// This parameter is required if your request omits other target parameters. For more information, see "Required Scan Target Parameters" in [Create a Scan](doc:create-scan-tio).
		//
		//  **Note:** Unicode/UTF-8 encoding is not supported in the targets file.
		FileTargets *string `json:"file_targets,omitempty"`

		// The unique ID of the folder where you want to store the scan. Use the [GET /folders](ref:folders-list) endpoint to find the folder ID.
		FolderId *int32 `json:"folder_id,omitempty"`

		// When to launch the scan. Possible values are: DAILY, WEEKLY, MONTHLY, YEARLY. Note that scheduled scans do not run if they are in the scan owner's trash folder.
		Launch *ScansConfigureJSONBodySettingsLaunch `json:"launch,omitempty"`

		// The name of the scan.
		Name string `json:"name"`

		// The unique ID of the user you want to make the owner of the specified scan. You can only change ownership for scans where you have OWNER [128] scan permissions. For more information, see [Change Scan Ownership](doc:change-scan-ownership-tio).
		OwnerId *int `json:"owner_id,omitempty"`

		// The interval at which the scan repeats. The interval is formatted as a string of three values delimited by semi-colons. These values are: the frequency (FREQ=ONETIME or DAILY or WEEKLY or MONTHLY or YEARLY), the interval (INTERVAL=1 or 2 or 3 ... x), and the days of the week (BYDAY=SU,MO,TU,WE,TH,FR,SA). For a scan that runs every three weeks on Monday Wednesday and Friday, the string would be `FREQ=WEEKLY;INTERVAL=3;BYDAY=MO,WE,FR`. If the scan is not scheduled to recur, this attribute is `null`. For more information, see [rrules Format](doc:example-assessment-scan-recurring#rrules-format).
		//
		// **Note:** To set the `rrules` parameter for an agent scan, the request must also include the following body parameters:<ul><li>The `uuid` parameter must specify an agent scan template. For more information, see [Tenable-Provided Agent Templates](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AgentTemplates.htm) and the [GET /editor/scan/templates](ref:editor-list-templates) endpoint.</li><li>The `agent_group_id` parameter must specify an agent group. For more information, see [Agent Groups](ref:agent-groups).</li></ul>For an example request body for an agent scan, see [Example Agent Scan: Recurring](doc:example-agent-scan-recurring).
		Rrules *string `json:"rrules,omitempty"`

		// The time frame, in minutes, during which agents must transmit scan results to Tenable.io in order to be included in dashboards and reports. If your request omits this parameter, the default value is 180 minutes. For non-agent scans, this attribute is null.
		ScanTimeWindow *int `json:"scan_time_window,omitempty"`

		// The unique ID of the scanner to use. Use the [GET /scanners](ref:scanners-list) endpoint to find the scanner ID. You can use the special value `AUTO-ROUTED` to assign scan targets to scanner groups based on the groups' configured scan routes. For more information, see [Manage Scan Routing](doc:manage-scan-routing-tio).
		//
		// **Note:** If you omit this parameter from the request, Tenable.io assigns the US Cloud Scanner by default.
		ScannerId *string `json:"scanner_id,omitempty"`

		// For one-time scans, the starting time and date for the scan. For recurrent scans, the first date on which the scan schedule is active and the time that recurring scans launch based on the `rrules` parameter.
		//
		// This parameter must be in the following format: `YYYYMMDDTHHMMSS`.
		Starttime *string `json:"starttime,omitempty"`

		// The list of asset tag identifiers that the scan uses to determine which assets it evaluates. For more information about tag-based scans, see [Manage Tag-Based Scans](doc:manage-tag-based-scans-tio).
		//
		//
		//
		// This parameter is required if your request omits other target parameters. For more information, see "Required Scan Target Parameters" in [Create a Scan](doc:create-scan-tio).
		TagTargets *[]string `json:"tag_targets,omitempty"`

		// An array of target group IDs to scan. Use the [GET /target-groups](/reference#target-groups-list) endpoint to determine target group IDs.
		//
		// This parameter is required if your request omits other target parameters. For more information, see "Required Scan Target Parameters" in [Create a Scan](doc:create-scan-tio).
		TargetGroups *[]int `json:"target_groups,omitempty"`

		// This field is required if the `scanner_id` parameter is `AUTO-ROUTED`. Specify a value as follows:<ul><li>If your scans involve separate environments with overlapping IP ranges, specify the UUID of the [network](doc:manage-networks-tio) you want to associate with the results of the auto-routed scan. This value must match the network where you have assigned the scanner groups that you configured for scan routing.</li><li>Otherwise, specify the default network (`00000000-0000-0000-0000-000000000000`).</li></ul><p>**Note:** This parameter does not override network associations for scans that are not auto-routed. Tenable.io automatically associates a non-routed scan with the network to which you have assigned the scanner that performs the scan.</p>
		TargetNetworkUuid *string `json:"target_network_uuid,omitempty"`

		// The list of targets to scan. For a full list of supported target formats, see the [Tenable.io Vulnerability Management User Guide](https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Scans/AboutScanTargets.htm). You can specify multiple targets (of differing formats) as a comma-delimited list.
		//
		// This parameter is required if your request omits other target parameters. For more information, see "Required Scan Target Parameters" in [Create a Scan](doc:create-scan-tio).
		//
		// **Note:** Tenable.io does not perform validation on values you submit for this parameter. If you submit invalid values, Tenable.io stores the invalid values in the scan configuration; when the scan runs, scanning fails on the invalid targets.
		TextTargets *string `json:"text_targets,omitempty"`

		// The timezone of the scheduled start time for the scan.
		Timezone *string `json:"timezone,omitempty"`
	} `json:"settings"`

	// The UUID for the Tenable-provided scan template to use. Use the [GET /editor/scan/templates](ref:editor-list-templates) endpoint to find the template UUID.
	Uuid string `json:"uuid"`
}

// ScansConfigureJSONBodyCredentialsAddHostWindowsAuthMethod defines parameters for ScansConfigure.
type ScansConfigureJSONBodyCredentialsAddHostWindowsAuthMethod string

// ScansConfigureJSONBodyPluginsWebServersIndividual11213 defines parameters for ScansConfigure.
type ScansConfigureJSONBodyPluginsWebServersIndividual11213 string

// ScansConfigureJSONBodyPluginsWebServersIndividual18261 defines parameters for ScansConfigure.
type ScansConfigureJSONBodyPluginsWebServersIndividual18261 string

// ScansConfigureJSONBodySettingsLaunch defines parameters for ScansConfigure.
type ScansConfigureJSONBodySettingsLaunch string

// ScansAttachmentsParams defines parameters for ScansAttachments.
type ScansAttachmentsParams struct {
	// The attachment access token.
	Key string `json:"key"`
}

// ScansCopyJSONBody defines parameters for ScansCopy.
type ScansCopyJSONBody struct {
	// The ID of the destination folder. If you don't specify a folder ID, Tenable.io creates the copy in the same folder as the original.
	FolderId *int32 `json:"folder_id,omitempty"`

	// The name of the copied scan. If you don't specify a name, Tenable.io uses the same name as the original with "Copy of" prefix.
	Name *string `json:"name,omitempty"`
}

// IoScansCredentialsConvertJSONBody defines parameters for IoScansCredentialsConvert.
type IoScansCredentialsConvertJSONBody struct {
	// A value specifying whether the credentials are scan-specific (`true`) or managed (`false`). You must use `false` for this request body attribute to convert scan-specific to managed credentials.
	AdHoc bool `json:"ad_hoc"`

	// The system name that uniquely identifies the credentials category, for example `Host`.
	Category *string `json:"category,omitempty"`

	// The name of the managed credentials. This name must be unique within your Tenable.io instance.
	Name string `json:"name"`

	// A list of user permissions for the managed credentials. If a request message omits this parameter, Tenable.io automatically creates a `permissions` object for the user account that submits the request.
	Permissions *[]struct {
		// The UUID of the user or user group granted permissions for managed credentials.
		//
		// This parameter is required when assigning CAN USE [32] or CAN EDIT [64] permissions for managed credentials.
		GranteeUuid *string `json:"grantee_uuid,omitempty"`

		// The name of the user or user group that you want to grant permissions for the managed credentials.
		//
		// This parameter is optional when assigning CAN USE [32] or CAN EDIT [64] permissions for the managed credentials.
		Name *string `json:"name,omitempty"`

		// A value specifying the permissions granted to the user or user group for the managed credentials. Possible values are:
		//  - 32—The user can view credentials information and use the credentials in scans. Corresponds to the **Can Use** permission in the user interface.
		//  - 64—The user can view and edit credential settings, delete the credentials, and use the credentials in scans. Corresponds to the **Can Edit** permission in the user interface.
		//
		// This parameter is required when assigning CAN USE [32] or CAN EDIT [64] permissions for managed credentials.
		Permissions *int `json:"permissions,omitempty"`

		// A value specifying whether the grantee is a user (`user`) or a user group (`group`).
		//
		// This parameter is required when assigning CAN USE [32] or CAN EDIT [64] permissions for  managed credentials.
		Type *IoScansCredentialsConvertJSONBodyPermissionsType `json:"type,omitempty"`
	} `json:"permissions,omitempty"`

	// The configuration settings for the credentials. The parameters of this object vary depending on the credentials type. For more information, see [Determine Settings for a Credential Type](doc:determine-settings-for-credential-type).
	//
	// **Note:** This form displays limited parameters that support a Windows type of credentials that uses password authentication.
	Settings struct {
		// The name for the authentication method. This value corresponds to the credentials[].types[].configuration[].options[].id attribute in the response message for the [GET /credentials/types](ref:credentials-list-credential-types) endpoint.
		AuthMethod *IoScansCredentialsConvertJSONBodySettingsAuthMethod `json:"auth_method,omitempty"`

		// The Windows domain to which the username belongs.
		Domain *string `json:"domain,omitempty"`

		// The user password on the target system.
		Password *string `json:"password,omitempty"`

		// The username on the target system.
		Username *string `json:"username,omitempty"`
	} `json:"settings"`

	// The system name that uniquely identifies the credentials type, for example, `Windows`.
	Type string `json:"type"`
}

// IoScansCredentialsConvertJSONBodyPermissionsType defines parameters for IoScansCredentialsConvert.
type IoScansCredentialsConvertJSONBodyPermissionsType string

// IoScansCredentialsConvertJSONBodySettingsAuthMethod defines parameters for IoScansCredentialsConvert.
type IoScansCredentialsConvertJSONBodySettingsAuthMethod string

// ScansExportRequestJSONBody defines parameters for ScansExportRequest.
type ScansExportRequestJSONBody struct {
	// The ID of the asset scanned.
	AssetId *string `json:"asset_id,omitempty"`

	// The chapters to include in the export. This parameter accepts a semi-colon delimited string comprised of some combination of the following options: vuln_hosts_summary, vuln_by_host, compliance_exec, remediations, vuln_by_plugin, compliance).
	//
	// **Note:** This parameter is required if the file format is `PDF` or `HTML`.
	Chapters *string `json:"chapters,omitempty"`

	// The name of the filter to apply to the exported scan report. You can find available filters by using the [GET /filters/workbenches/vulnerabilities](ref:io-filters-vulnerabilities-workbench-list) endpoint. If you specify the name of the filter, you must specify the operator as the `filter.0.quality` parameter and the value as the `filter.0.value` parameter. To use multiple filters, increment the `<INDEX>` portion of `filter.<INDEX>.filter`, for example, `filter.1.filter`. For more information about using this parameter, see [Scan Export Filters](doc:scan-export-filters-tio).
	//
	// **Note:** Filters are not supported when exporting scan results that are older than 60 days.
	Filter0Filter *string `json:"filter.0.filter,omitempty"`

	// The operator of the filter to apply to the exported scan report. You can find the operators for the filter using the [GET /filters/workbenches/vulnerabilities](ref:io-filters-vulnerabilities-workbench-list) endpoint. To use multiple filters, increment the `<INDEX>` portion of `filter.<INDEX>.quality`, for example, `filter.1.quality`. For more information about using this parameter, see [Scan Export Filters](doc:scan-export-filters-tio).
	Filter0Quality *string `json:"filter.0.quality,omitempty"`

	// The value of the filter to apply to the exported scan report. You can find valid values for the filter in the `control` attribute of the objects returned by the [GET /filters/workbenches/vulnerabilities](ref:io-filters-vulnerabilities-workbench-list) endpoint. To use multiple filters, increment the `<INDEX>` portion of `filter.<INDEX>.value`, for example, `filter.1.value`. For more information about using this parameter, see [Scan Export Filters](doc:scan-export-filters-tio).
	Filter0Value *string `json:"filter.0.value,omitempty"`

	// For multiple filters, specifies whether to use the AND or the OR logical operator. The default is AND. For more information about using this parameter, see [Scan Export Filters](doc:scan-export-filters-tio).
	FilterSearchType *ScansExportRequestJSONBodyFilterSearchType `json:"filter.search_type,omitempty"`

	// The file format to use (`Nessus`, `HTML`, `PDF`, `CSV`, or `DB`). For scans that are older than 60 days, only `Nessus` and `CSV` are supported.
	Format ScansExportRequestJSONBodyFormat `json:"format"`

	// The password used to encrypt database exports. This parameter is required when exporting as `DB`.
	Password *string `json:"password,omitempty"`
}

// ScansExportRequestParams defines parameters for ScansExportRequest.
type ScansExportRequestParams struct {
	// The unique identifier of the historical data that you want Tenable.io to export. This identifier corresponds to the `history.id` attribute of the response message from the [GET /scans/{scan_id}/history](ref:scans-history) endpoint.
	HistoryId *int32 `json:"history_id,omitempty"`

	// The UUID of the historical data that you want Tenable.io to return. This identifier corresponds to the `history.scan_uuid` attribute of the response message from the [GET /scans/{scan_id}/history](ref:scans-history) endpoint.
	HistoryUuid *string `json:"history_uuid,omitempty"`
}

// ScansExportRequestJSONBodyFilterSearchType defines parameters for ScansExportRequest.
type ScansExportRequestJSONBodyFilterSearchType string

// ScansExportRequestJSONBodyFormat defines parameters for ScansExportRequest.
type ScansExportRequestJSONBodyFormat string

// ScansHistoryParams defines parameters for ScansHistory.
type ScansHistoryParams struct {
	// The number of records to retrieve. If this parameter is omitted, Tenable.io uses the default value of `50`.
	Limit *int32 `json:"limit,omitempty"`

	// The starting record to retrieve. If this parameter is omitted, Tenable.io uses the default value of `0`.
	Offset *int32 `json:"offset,omitempty"`

	// The field you want to use to sort the results by along with the sort order. The field is specified first, followed by a colon, and the order is specified second (`asc` or `desc`). For example, `start_date:desc` would sort results by the `start_date` field in descending order.
	//
	// If you specify multiple fields, the fields must be separated by commas. For example, `start_date:desc,status:asc` would first sort results by the `start_date` field in descending order and then by the `status` field in ascending order.
	Sort *string `json:"sort,omitempty"`
}

// ScansLaunchJSONBody defines parameters for ScansLaunch.
type ScansLaunchJSONBody struct {
	// If you include this parameter, Tenable.io scans these targets instead of the default. Value can be an array where each index is a target, or an array with a single index of comma-separated targets.
	AltTargets *[]string `json:"alt_targets,omitempty"`
}

// ScansScheduleJSONBody defines parameters for ScansSchedule.
type ScansScheduleJSONBody struct {
	// Enables or disables the scan schedule.
	Enabled bool `json:"enabled"`
}

// ScansReadStatusJSONBody defines parameters for ScansReadStatus.
type ScansReadStatusJSONBody struct {
	// If `true`, the scan has been read.
	Read bool `json:"read"`
}

// ScansHostDetailsParams defines parameters for ScansHostDetails.
type ScansHostDetailsParams struct {
	// The unique identifier of the historical data that you want Tenable.io to return. This identifier corresponds to the `history.id` attribute of the response message from the [GET /scans/{scan_id}/history](ref:scans-history) endpoint.
	HistoryId *int32 `json:"history_id,omitempty"`

	// The UUID of the historical data that you want Tenable.io to return. This identifier corresponds to the `history.scan_uuid` attribute of the response message from the [GET /scans/{scan_id}/history](ref:scans-history) endpoint.
	HistoryUuid *string `json:"history_uuid,omitempty"`
}

// ScansPluginOutputParams defines parameters for ScansPluginOutput.
type ScansPluginOutputParams struct {
	// The unique identifier of the historical data that you want Tenable.io to return. This identifier corresponds to the `history.id` attribute of the response message from the [GET /scans/{scan_id}/history](ref:scans-history) endpoint.
	HistoryId *int32 `json:"history_id,omitempty"`

	// The UUID of the historical data that you want Tenable.io to return. This identifier corresponds to the `history.scan_uuid` attribute of the response message from the [GET /scans/{scan_id}/history](ref:scans-history) endpoint.
	HistoryUuid *string `json:"history_uuid,omitempty"`
}

// TagsAssignAssetTagsJSONBody defines parameters for TagsAssignAssetTags.
type TagsAssignAssetTagsJSONBody struct {
	// Specifies whether to add or remove tags.
	Action TagsAssignAssetTagsJSONBodyAction `json:"action"`

	// An array of asset UUIDs. For more information on determining values for this array, see [Determine Tag Identifiers](doc:determine-tag-identifiers-tio).
	Assets []string `json:"assets"`

	// An array of tag value UUIDs. For more information on determining values for this array, see [Determine Tag Identifiers](doc:determine-tag-identifiers-tio).
	Tags []string `json:"tags"`
}

// TagsAssignAssetTagsJSONBodyAction defines parameters for TagsAssignAssetTags.
type TagsAssignAssetTagsJSONBodyAction string

// TagsListTagCategoriesParams defines parameters for TagsListTagCategories.
type TagsListTagCategoriesParams struct {
	// A filter condition in the `field:operator:value` format, for example, `f=name:match:location`. Filter conditions can include:
	// * name:eq:&lt;name>
	// * name:match:<partial\_name>
	// * description:eq:&lt;description>
	// * description:match:<partial\_description>
	// * updated\_at:date-eq:<timestamp\_as\_int>
	// * updated\_at:date-gt:<timestamp\_as\_int>
	// * updated\_at:date-lt:<timestamp\_as\_int>
	// * created\_at:date-eq:<timestamp\_as\_int>
	// * created\_at:date-gt:<timestamp\_as\_int>
	// * created\_at:date-lt:<timestamp\_as\_int>
	// * updated\_by:eq:<user\_uuid>
	F *string `json:"f,omitempty"`

	// If multiple `f` parameters are present, specifies whether Tenable.io applies `AND` or `OR` to conditions. Supported values are `and` and `or`. If you omit this parameter when using multiple `f` parameters, Tenable.io applies `AND` by default.
	Ft *string `json:"ft,omitempty"`

	// The number of records to retrieve. If this parameter is omitted, Tenable.io uses the default value of `5000`.
	Limit *int32 `json:"limit,omitempty"`

	// The starting record to retrieve. If this parameter is omitted, Tenable.io uses the default value of `0`.
	Offset *int32 `json:"offset,omitempty"`

	// The field you want to use to sort the results by along with the sort order. The field is specified first, followed by a colon, and the order is specified second (`asc` or `desc`). For example, `name:desc` would sort results by the `name` field in descending order.
	//
	// If you specify multiple fields, the fields must be separated by commas. For example, `name:desc,updated_at:asc` would first sort results by the `name` field in descending order and then by the `updated_at` field in ascending order.
	Sort *string `json:"sort,omitempty"`
}

// TagsCreateTagCategoryJSONBody defines parameters for TagsCreateTagCategory.
type TagsCreateTagCategoryJSONBody struct {
	// The description of the tag category. Must not exceed 3,000 characters.
	Description *string `json:"description,omitempty"`

	// The name of the tag category. Must not exceed 127 characters.
	Name string `json:"name"`
}

// TagsEditTagCategoryJSONBody defines parameters for TagsEditTagCategory.
type TagsEditTagCategoryJSONBody struct {
	// The description of the category. Must not exceed 3,000 characters.
	Description *string `json:"description,omitempty"`

	// The name of the tag category. Must not exceed 127 characters.
	Name string `json:"name"`
}

// TagsListTagValuesParams defines parameters for TagsListTagValues.
type TagsListTagValuesParams struct {
	// A filter condition in the `field:operator:value` format, for example, `f=value:match:rhel`. Filters should match `field:op:value` format. Filter conditions can include:
	// * value:eq:&lt;value>
	// * value:match:&lt;value>
	// * category\_name:match:<partial\_value>
	// * category\_name:eq:<category\_name>
	// * category\_name:match:<partial\_category\_name>
	// * description:eq:&lt;description>
	// * description:match:<partial\_description>
	// * updated\_at:date-eq:<timestamp\_as\_int>
	// * updated\_at:date-gt:<timestamp\_as\_int>
	// * updated\_at:date-lt:<timestamp\_as\_int>
	// * updated\_by:eq:<user\_uuid>
	F *string `json:"f,omitempty"`

	// If multiple `f` parameters are present, specifies whether Tenable.io applies `AND` or `OR` to conditions. Supported values are `and` and `or`. If you omit this parameter when using multiple `f` parameters, Tenable.io applies `AND` by default.
	Ft *string `json:"ft,omitempty"`

	// A comma-separated list of fields to include in the wildcard search. Provides the same functionality as a `match` condition in the `f` in parameter. For example, `f=value:match:Chi` returns the same results as `wf=value&w=Chi`. Wildcard fields include:
	// * category\_name
	// * value
	// * description
	// Use the `w` parameter to specify the search value.
	Wf *string `json:"wf,omitempty"`

	// A single search value for the wildcard fields specified in the `wf` parameter.
	W *string `json:"w,omitempty"`

	// The number of records to retrieve. If this parameter is omitted, Tenable.io uses the default value of `5000`.
	Limit *int32 `json:"limit,omitempty"`

	// The starting record to retrieve. If this parameter is omitted, Tenable.io uses the default value of `0`.
	Offset *int32 `json:"offset,omitempty"`

	// The field you want to use to sort the results by along with the sort order. The field is specified first, followed by a colon, and the order is specified second (`asc` or `desc`). For example, `value:desc` would sort results by the `value` field in descending order.
	//
	// If you specify multiple fields, the fields must be separated by commas. For example, `value:desc,updated_at:asc` would first sort results by the `value` field in descending order and then by the `updated_at` field in ascending order.
	Sort *string `json:"sort,omitempty"`
}

// TagsCreateTagValueJSONBody defines parameters for TagsCreateTagValue.
type TagsCreateTagValueJSONBody struct {
	// Determines what the user can do with the tag value.
	AccessControl *struct {
		// List of the minimum set of permissions all users have on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
		AllUsersPermissions *TagsCreateTagValueJSONBodyAccessControlAllUsersPermissions `json:"all_users_permissions,omitempty"`

		// List of user and group-specific permissions for the current tag.
		CurrentDomainPermissions *[]struct {
			// The UUID of a user or group.
			Id *string `json:"id,omitempty"`

			// The name of the user or group.
			Name *string `json:"name,omitempty"`

			// The permissions associated with the user or group.
			Permissions *[]string `json:"permissions,omitempty"`

			// The type of permission.
			Type *TagsCreateTagValueJSONBodyAccessControlCurrentDomainPermissionsType `json:"type,omitempty"`
		} `json:"current_domain_permissions,omitempty"`

		// List of all permissions for the current user on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`.
		CurrentUserPermissions *TagsCreateTagValueJSONBodyAccessControlCurrentUserPermissions `json:"current_user_permissions,omitempty"`

		// List of all defined permissions for objects of type tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
		DefinedDomainPermissions *TagsCreateTagValueJSONBodyAccessControlDefinedDomainPermissions `json:"defined_domain_permissions,omitempty"`

		// Optional, user-defined value. This value must be incremented each time the permissions are updated. Set to `1` by default.
		Version *int64 `json:"version,omitempty"`
	} `json:"access_control,omitempty"`

	// The description for the new tag category that Tenable.io creates if the category specified by name does not exist. Otherwise, Tenable.io ignores the description.
	CategoryDescription *string `json:"category_description,omitempty"`

	// The name of the tag category to associate with the new value.
	//
	// Specify the name of a new category if you want to add both a <i>new</i> category and tag value.
	//
	// Specify the name of an <i>existing</i> category if you want to add the tag value to the existing category.
	//
	// <b>Caution:</b> This value is case-sensitive. For example, Tenable.io considers "location" and "Location" to be separate categories.
	//
	// The category_name can result in the following responses:
	//
	//  - If the category_name you specify exists, and the tag value you specify already exists for that category, Tenable.io returns a 400 response code, instead of adding the tag.
	//
	//  - If the category_name you specify exists, but the tag value you specify does not yet exist for that category, Tenable.io adds the tag value to the existing category.
	//
	//  - If the category_name you specify does not exist, Tenable.io creates a new tag category and adds the new tag value to that category.
	//
	// This parameter is required if category_uuid is not present in the request message.
	CategoryName *string `json:"category_name,omitempty"`

	// The UUID of the tag category to associate with the new value. For more information on determining this value, see [Determine Tag Identifiers](doc:determine-tag-identifiers-tio).
	//
	// Use this parameter only if you want to add the tag value to an existing category. If the UUID you specify does not exist, Tenable.io does not create a new catgory. Instead, it returns a 400 (Bad Request) response code.
	//
	// This parameter is required if category_name is not present in the request message.
	CategoryUuid *string `json:"category_uuid,omitempty"`

	// The new tag value description.
	Description *string `json:"description,omitempty"`

	// The filters (conditional sets of rules) for automatically applying the tag to assets. For more information, see [Apply Dynamic Tags](doc:apply-dynamic-tags).
	Filters *struct {
		// The object containing conditional sets of rules for applying the tags.
		//
		// **Note:** Tenable.io supports a maximum of 1,000 rules per tag. This limit means that you can specify a maximum of 1,000 `and` or `or` conditions for a single tag value. Additionally, Tenable.io supports a maximum of 1,024 values in a comma-delimited string per individual tag rule. Note that the request body is limited to 1 MB. For more information about asset tags and their limitations, see [Manage Asset Tags](doc:manage-asset-tags-tio).
		Asset *struct {
			// To apply the tag to assets that match all of the rules, specify the rules inside the `and` object.
			//
			// **Note:** The value you specify for the rule attribute is not case sensitive. For example, if you type the hostname "hostx," the rule matches to assets with hostname "HOSTX" and "hostx."
			And *[]struct {
				// The asset attribute name or tag to match.
				Field *string `json:"field,omitempty"`

				// The operator to apply to the matched value, for example, equals, does not equal, or contains. To find supported operators, use the [GET /tags/assets/filters](ref:tags-list-asset-filters) endpoint.
				Operator *string `json:"operator,omitempty"`

				// The asset attribute value or tag to match. You can specify multiple values separated by commas, for example, "192.0.2.57,192.0.2.177,192.0.2.8,192.0.2.176,192.0.2.225".
				Value *string `json:"value,omitempty"`
			} `json:"and,omitempty"`

			// To apply the tag to assets that match any of the rules, specify the rules inside the `or` object.
			//
			// **Note:** The value you specify for the rule attribute is not case sensitive. For example, if you type the hostname "hostx," the rule matches to assets with hostname "HOSTX" and "hostx."
			Or *[]struct {
				// The asset attribute name or tag to match.
				Field *string `json:"field,omitempty"`

				// The operator to apply to the matched value, for example, equals, does not equal, or contains. To find supported operators, use the [GET /tags/assets/filters](ref:tags-list-asset-filters) endpoint.
				Operator *string `json:"operator,omitempty"`

				// The asset attribute value or tag to match. You can specify multiple values separated by commas, for example, "192.0.2.57,192.0.2.177,192.0.2.8,192.0.2.176,192.0.2.225".
				Value *string `json:"value,omitempty"`
			} `json:"or,omitempty"`
		} `json:"asset,omitempty"`
	} `json:"filters,omitempty"`

	// The new tag value. Tag values cannot exceed 50 characters in length.
	//
	// <b>Caution:</b> This value is case-sensitive. For example, Tenable.io considers "headquarters" and "Headquarters" to be separate tag values.
	Value string `json:"value"`
}

// TagsCreateTagValueJSONBodyAccessControlAllUsersPermissions defines parameters for TagsCreateTagValue.
type TagsCreateTagValueJSONBodyAccessControlAllUsersPermissions []string

// TagsCreateTagValueJSONBodyAccessControlCurrentDomainPermissionsType defines parameters for TagsCreateTagValue.
type TagsCreateTagValueJSONBodyAccessControlCurrentDomainPermissionsType string

// TagsCreateTagValueJSONBodyAccessControlCurrentUserPermissions defines parameters for TagsCreateTagValue.
type TagsCreateTagValueJSONBodyAccessControlCurrentUserPermissions []string

// TagsCreateTagValueJSONBodyAccessControlDefinedDomainPermissions defines parameters for TagsCreateTagValue.
type TagsCreateTagValueJSONBodyAccessControlDefinedDomainPermissions []string

// TagsDeleteTagValuesBulkJSONBody defines parameters for TagsDeleteTagValuesBulk.
type TagsDeleteTagValuesBulkJSONBody struct {
	// The UUIDs of the tag values you want to delete.
	//
	// **Note:** A tag UUID is technically assigned to the tag value only (the second half of the category:value pair), but the API commands use this value to represent the whole `category:value` pair. For more information on determining this value, see [Determine Tag Identifiers](doc:determine-tag-identifiers-tio).
	Values *[]string `json:"values,omitempty"`
}

// TagsUpdateTagValueJSONBody defines parameters for TagsUpdateTagValue.
type TagsUpdateTagValueJSONBody struct {
	// Determines what the user can do with the tag value.
	AccessControl *struct {
		// List of the minimum set of permissions all users have on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
		AllUsersPermissions *TagsUpdateTagValueJSONBodyAccessControlAllUsersPermissions `json:"all_users_permissions,omitempty"`

		// List of user and group-specific permissions for the current tag.
		CurrentDomainPermissions *[]struct {
			// The UUID of a user or group.
			Id *string `json:"id,omitempty"`

			// The name of the user or group.
			Name *string `json:"name,omitempty"`

			// The permissions associated with the user or group.
			Permissions *[]string `json:"permissions,omitempty"`

			// The type of permission.
			Type *TagsUpdateTagValueJSONBodyAccessControlCurrentDomainPermissionsType `json:"type,omitempty"`
		} `json:"current_domain_permissions,omitempty"`

		// List of all permissions for the current user on the current tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`.
		CurrentUserPermissions *TagsUpdateTagValueJSONBodyAccessControlCurrentUserPermissions `json:"current_user_permissions,omitempty"`

		// List of all defined permissions for objects of type tag. Possible values are `ALL`, `CAN_EDIT`, and `CAN_SET_PERMISSIONS`. Note that in responses, this field is only returned for administrators and tag owners.
		DefinedDomainPermissions *TagsUpdateTagValueJSONBodyAccessControlDefinedDomainPermissions `json:"defined_domain_permissions,omitempty"`

		// Optional, user-defined value. This value must be incremented each time the permissions are updated. Set to `1` by default.
		Version *int64 `json:"version,omitempty"`
	} `json:"access_control,omitempty"`

	// The new tag value description.
	Description *string `json:"description,omitempty"`

	// The filters (conditional sets of rules) for automatically applying the tag to assets. For more information, see [Apply Dynamic Tags](doc:apply-dynamic-tags).
	Filters *struct {
		// The object containing conditional sets of rules for applying the tags.
		//
		// **Note:** Tenable.io supports a maximum of 1,000 rules per tag. This limit means that you can specify a maximum of 1,000 `and` or `or` conditions for a single tag value. Additionally, Tenable.io supports a maximum of 1,024 values in a comma-delimited string per individual tag rule. Note that the request body is limited to 1 MB. For more information about asset tags and their limitations, see [Manage Asset Tags](doc:manage-asset-tags-tio).
		Asset *struct {
			// To apply the tag to assets that match all of the rules, specify the rules inside the `and` object.
			//
			// **Note:** The value you specify for the rule attribute is not case sensitive. For example, if you type the hostname "hostx," the rule matches to assets with hostname "HOSTX" and "hostx."
			And *[]struct {
				// The asset attribute name or tag to match.
				Field *string `json:"field,omitempty"`

				// The operator to apply to the matched value, for example, equals, does not equal, or contains. To find supported operators, use the [GET /tags/assets/filters](ref:tags-list-asset-filters) endpoint.
				Operator *string `json:"operator,omitempty"`

				// The asset attribute value or tag to match. You can specify multiple values separated by commas, for example, "192.0.2.57,192.0.2.177,192.0.2.8,192.0.2.176,192.0.2.225".
				Value *string `json:"value,omitempty"`
			} `json:"and,omitempty"`

			// To apply the tag to assets that match any of the rules, specify the rules inside the `or` object.
			//
			// **Note:** The value you specify for the rule attribute is not case sensitive. For example, if you type the hostname "hostx," the rule matches to assets with hostname "HOSTX" and "hostx."
			Or *[]struct {
				// The asset attribute name or tag to match.
				Field *string `json:"field,omitempty"`

				// The operator to apply to the matched value, for example, equals, does not equal, or contains. To find supported operators, use the [GET /tags/assets/filters](ref:tags-list-asset-filters) endpoint.
				Operator *string `json:"operator,omitempty"`

				// The asset attribute value or tag to match. You can specify multiple values separated by commas, for example, "192.0.2.57,192.0.2.177,192.0.2.8,192.0.2.176,192.0.2.225".
				Value *string `json:"value,omitempty"`
			} `json:"or,omitempty"`
		} `json:"asset,omitempty"`
	} `json:"filters,omitempty"`

	// The new tag value. Tag values cannot exceed 50 characters in length.
	Value *string `json:"value,omitempty"`
}

// TagsUpdateTagValueJSONBodyAccessControlAllUsersPermissions defines parameters for TagsUpdateTagValue.
type TagsUpdateTagValueJSONBodyAccessControlAllUsersPermissions []string

// TagsUpdateTagValueJSONBodyAccessControlCurrentDomainPermissionsType defines parameters for TagsUpdateTagValue.
type TagsUpdateTagValueJSONBodyAccessControlCurrentDomainPermissionsType string

// TagsUpdateTagValueJSONBodyAccessControlCurrentUserPermissions defines parameters for TagsUpdateTagValue.
type TagsUpdateTagValueJSONBodyAccessControlCurrentUserPermissions []string

// TagsUpdateTagValueJSONBodyAccessControlDefinedDomainPermissions defines parameters for TagsUpdateTagValue.
type TagsUpdateTagValueJSONBodyAccessControlDefinedDomainPermissions []string

// TargetGroupsCreateJSONBody defines parameters for TargetGroupsCreate.
type TargetGroupsCreateJSONBody struct {
	// An array containing permissions to apply to the group.
	Acls *[]struct {
		// The unique ID of the user or group.
		Id *int `json:"id,omitempty"`

		// The permission value to grant access as described in [Permissions](doc:permissions).
		Permissions *int32 `json:"permissions,omitempty"`

		// The type of permission (default, user, group).
		Type *TargetGroupsCreateJSONBodyAclsType `json:"type,omitempty"`
	} `json:"acls,omitempty"`

	// The members of the group. A comma-separated list of FQDNs or IP address ranges that you want to scan.
	Members string `json:"members"`

	// The name for the group.
	Name string `json:"name"`
}

// TargetGroupsCreateJSONBodyAclsType defines parameters for TargetGroupsCreate.
type TargetGroupsCreateJSONBodyAclsType string

// TargetGroupsEditJSONBody defines parameters for TargetGroupsEdit.
type TargetGroupsEditJSONBody struct {
	// An array containing permissions to apply to the group.
	Acls *[]struct {
		// The unique ID of the user or group.
		Id *int `json:"id,omitempty"`

		// The permission value to grant access as described in [Permissions](doc:permissions).
		Permissions *int32 `json:"permissions,omitempty"`

		// The type of permission (default, user, group).
		Type *TargetGroupsEditJSONBodyAclsType `json:"type,omitempty"`
	} `json:"acls,omitempty"`

	// The members of the group. A comma-separated list of FQDNs or IP address ranges that you want to scan.
	Members *string `json:"members,omitempty"`

	// The name of the group.
	Name *string `json:"name,omitempty"`
}

// TargetGroupsEditJSONBodyAclsType defines parameters for TargetGroupsEdit.
type TargetGroupsEditJSONBodyAclsType string

// IoV2AccessGroupsListParams defines parameters for IoV2AccessGroupsList.
type IoV2AccessGroupsListParams struct {
	// A filter condition in the following format: `field:operator:value`. For a list of possible fields and operators, use the [GET /v2/access-groups/filters](ref:io-v2-access-groups-list-filters) endpoint. You can specify multiple `f` parameters, separated by ampersand (&) characters. If you specify multiple `f` parameters, use the `ft` parameter to specify how Tenable.io applies the multiple filter conditions.
	F *string `json:"f,omitempty"`

	// If multiple `f` parameters are present, specifies whether Tenable.io applies `AND` or `OR` to conditions. Supported values are `and` and `or`. If you omit this parameter when using multiple `f` parameters, Tenable.io applies `AND` by default.
	Ft *string `json:"ft,omitempty"`

	// The search value that Tenable.io applies across the wildcard fields. Wildcard fields are specified in the `wf` parameter.
	W *string `json:"w,omitempty"`

	// A comma-separated list of fields where Tenable.io applies the search value specified in the `w` parameter. For a list of supported wildcard fields, use the [GET /v2/access-groups/filters](ref:io-v2-access-groups-list-filters) endpoint.
	Wf *string `json:"wf,omitempty"`

	// Specifies whether or not to include the `rules` and `principals` objects in the response. Tenable.io defaults to `false` if this parameter is omitted.
	Fullypopulateresponse *bool `json:"fullypopulateresponse,omitempty"`

	// The number of records to retrieve.
	Limit *int32 `json:"limit,omitempty"`

	// The starting record to retrieve. If this parameter is omitted, Tenable.io uses the default value of `0`.
	Offset *int32 `json:"offset,omitempty"`

	// The field you want to use to sort the results by along with the sort order. The field is specified first, followed by a colon, and the order is specified second (`asc` or `desc`). For example, `name:desc` would sort results by the `name` field in descending order.
	//
	// If you specify multiple fields, the fields must be separated by commas. For example, `name:desc,created_at:asc` would first sort results by the `name` field in descending order and then by the `created_at` field in ascending order.
	//
	// For a list of supported sort fields, use the [GET /v2/access-groups/filters](ref:io-v2-access-groups-list-filters) endpoint.
	Sort *string `json:"sort,omitempty"`
}

// IoV2AccessGroupsCreateJSONBody defines parameters for IoV2AccessGroupsCreate.
type IoV2AccessGroupsCreateJSONBody struct {
	// The type of access group. It can be one of three possible types:
	//  * MANAGE_ASSETS—Users in this access group can view the asset records created during previous scans and scan the associated targets for those assets.
	//  * SCAN_TARGETS—Users in this access group can scan targets associated with the access group and view the results of those scans. Targets may be associated with existing assets.
	//  * ALL—This access group type is only applicable to the default system-generated "All Assets" access group that contains all assets in your organization. This group is referred to as the "All Assets" group in the user interface. By default, Tenable.io grants all users in this access group both CAN VIEW and CAN SCAN permissions.
	AccessGroupType *IoV2AccessGroupsCreateJSONBodyAccessGroupType `json:"access_group_type,omitempty"`

	// This parameter must always be `false` or omitted from create requests to specify that the access group is a user-created group. If you submit a create request with this parameter set to `true`, the create request fails.
	AllAssets *bool `json:"all_assets,omitempty"`

	// Specifies whether assets in the access group can be viewed by all or only some users in your organization:
	// * If `true`, all users in your organization have Can View access to the assets defined in the rules parameter. Tenable.io ignores any principal parameters in your request.
	// * If `false`, only specified users have Can View access to the assets defined in the rules parameter. You define which users or user groups have access in the principals parameter of the request.
	//
	// If you omit this parameter, Tenable.io sets the parameter to `false` by default.
	AllUsers *bool `json:"all_users,omitempty"`

	// The name of the access group you want to create. This name must be:
	// * Unique within your Tenable.io instance.
	// * A maximum of 255 characters.
	// * Alphanumeric, but can include limited special characters (underscore, dash, parenthesis, brackets, colon).
	//
	// **Note:** You can add a maximum of 5,000 access groups to an individual container.
	Name string `json:"name"`

	// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
	//
	// Tenable.io handles data in this array based on the all\_users parameter of the request:
	// * If all\_users is `true`, Tenable.io ignores any principal data in the request. You can omit this parameter from the request.
	// * If all\_users is `false`, Tenable.io adds the principal data to the access group.
	Principals *[]struct {
		// (Required) The permissions associated with the principal of the access group as described in <a href="/docs/permissions">Permissions</a>.
		Permissions *IoV2AccessGroupsCreateJSONBodyPrincipalsPermissions `json:"permissions,omitempty"`

		// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
		PrincipalId *string `json:"principal_id,omitempty"`

		// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
		PrincipalName *string `json:"principal_name,omitempty"`

		// (Required) The type of principal. Valid values include:
		//  - all_users—Grants access to all users in your organization. That access includes `Can View` access to the assets defined in the rules parameter.
		//  - user—Grants access to the user you specify.
		//  - group—Grants access to all users assigned to the user group you specify.
		Type *IoV2AccessGroupsCreateJSONBodyPrincipalsType `json:"type,omitempty"`
	} `json:"principals,omitempty"`

	// An array of asset rules. Tenable.io uses these rules to assign assets to the access group. You can specify a maximum of 1,000 rules for an individual access group. If you specify multiple rules for an access group, Tenable.io assigns an asset to the access group if the asset matches any of the rules. You can only add rules to access groups if the `all_assets` parameter is set to `false`.
	//
	// **Note:** When configuring rules for an `access_group_type` of `SCAN_TARGETS`, the asset attribute type (`rules.type`) must match the target format used in the related scan. For example, if a `SCAN_TARGETS` type access group rule filters on the FQDN/Hostname attribute, the related scan succeeds if the scan target is specified in FQDN or hostname format, but fails if the scan target is specified in IPv4 address format.
	Rules *[]struct {
		// The operator that specifies how Tenable.io matches the terms value to asset data.
		//
		// Possible operators include:
		//  - eq—Tenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
		//  - match—Tenable.io matches the rule to assets based a partial match of the specified term.
		//  - starts—Tenable.io matches the rule to assets that start with the specified term.
		//  - ends—Tenable.io matches the rule to assets that end with the specified term.
		//  - set-has—Tenable.io matches the rule to assets based on the specified `tag_uuid`.
		//
		// For a complete list of operators by rule type, use the [GET /v2/access-groups/rules/filters](ref:io-v2-access-groups-list-rule-filters) endpoint.
		Operator *string `json:"operator,omitempty"`

		// The values that Tenable.io uses to match an asset to the rule. A term must correspond to the rule type.
		//
		// For example:
		//  - If the rule type is `aws_account`, the term is an AWS account ID.
		//  - If the rule type is `fqdn`, the term is a hostname or a fully-qualified domain name (FQDN).
		//  - If the rule type is `ipv4`, the term is an individual IPv4 address, a range of IPv4 addresses (for example, 192.0.2.57-192.0.2.60), or a CIDR range (for example, 192.0.2.57/24).
		//
		// For a complete list of supported values by rule type, use the [GET /v2/access-groups/rules/filters](ref:io-v2-access-groups-list-rule-filters) endpoint.
		//
		// If you specify multiple terms values, Tenable.io includes an asset in the access group if the asset's attributes match any of the terms in the rule.
		// <br >You can specify up to 100,000 terms per asset rule.
		Terms *[]string `json:"terms,omitempty"`

		// The type of asset rule. The asset rule type corresponds to the type of data you can specify in the `terms` parameter. For a complete list of supported rule types, use the [GET /v2/access-groups/filters](ref:io-v2-access-groups-list-filters) endpoint.
		Type *string `json:"type,omitempty"`
	} `json:"rules,omitempty"`
}

// IoV2AccessGroupsCreateJSONBodyAccessGroupType defines parameters for IoV2AccessGroupsCreate.
type IoV2AccessGroupsCreateJSONBodyAccessGroupType string

// IoV2AccessGroupsCreateJSONBodyPrincipalsPermissions defines parameters for IoV2AccessGroupsCreate.
type IoV2AccessGroupsCreateJSONBodyPrincipalsPermissions []string

// IoV2AccessGroupsCreateJSONBodyPrincipalsType defines parameters for IoV2AccessGroupsCreate.
type IoV2AccessGroupsCreateJSONBodyPrincipalsType string

// IoV2AccessGroupsEditJSONBody defines parameters for IoV2AccessGroupsEdit.
type IoV2AccessGroupsEditJSONBody struct {
	// The type of access group. It can be one of three possible types:
	//  * MANAGE_ASSETS—Users in this access group can view the asset records created during previous scans and scan the associated targets for those assets.
	//  * SCAN_TARGETS—Users in this access group can scan targets associated with the access group and view the results of those scans. Targets may be associated with existing assets.
	//  * ALL—This access group type is only applicable to the default system-generated "All Assets" access group that contains all assets in your organization. This group is referred to as the "All Assets" group in the user interface. By default, Tenable.io grants all users in this access group both CAN VIEW and CAN SCAN permissions.
	AccessGroupType *IoV2AccessGroupsEditJSONBodyAccessGroupType `json:"access_group_type,omitempty"`

	// Specifies whether the access group you want to modify is the All Assets group or a user-defined group:
	// * If you want to refine membership in the All Assets access group (the only change you can make to the All Assets group), this parameter must be `true`. Tenable.io ignores any rules parameters in your request, but overwrrites existing principals parameters with those in the request based on the all\_users and principals parameters in the request.
	// * If you want to modify a user-defined access group, this parameter must be `false`. Tenable.io overwrites the existing rules parameters with the rules parameters you specify in this request, and overwrites existing principals parameters based on the all\_users and principals parameters in the request.
	AllAssets *bool `json:"all_assets,omitempty"`

	// Specifies whether assets in the access group can be viewed by all or only some users in your organization:
	// * If `true`, all users in your organization have Can View access to the assets defined in the rules parameter. Tenable.io ignores any principal parameters in your request.
	// * If `false`, only specified users have Can View access to the assets defined in the rules parameter. You define which users or user groups have access in the principals parameter of the request.
	//
	// If you omit this parameter, Tenable.io sets the parameter to `false` by default.
	AllUsers *bool `json:"all_users,omitempty"`

	// The name of the access group you want to modify.
	Name *string `json:"name,omitempty"`

	// An array of principals. Each principal represents a user or user group assigned to the access group. You cannot add an access group as a principal to another access group.
	Principals *[]struct {
		// (Required) The permissions associated with the principal of the access group as described in <a href="/docs/permissions">Permissions</a>.
		Permissions *IoV2AccessGroupsEditJSONBodyPrincipalsPermissions `json:"permissions,omitempty"`

		// The UUID of a user or user group. This parameter is required if the request omits the `principal_name` parameter.
		PrincipalId *string `json:"principal_id,omitempty"`

		// The name of the user or user group. This parameter is required if the request omits the `principal_id` parameter. If a request includes both `principal_id` and `principal_name`, Tenable.io assigns the user or user group to the access group based on the `principal_id` parameter, and ignores the `principal_name` parameter in the request.
		PrincipalName *string `json:"principal_name,omitempty"`

		// (Required) The type of principal. Valid values include:
		//  - all_users—Grants access to all users in your organization. That access includes `Can View` access to the assets defined in the rules parameter.
		//  - user—Grants access to the user you specify.
		//  - group—Grants access to all users assigned to the user group you specify.
		Type *IoV2AccessGroupsEditJSONBodyPrincipalsType `json:"type,omitempty"`
	} `json:"principals,omitempty"`

	// An array of asset rules. Tenable.io uses these rules to assign assets to the access group. You can specify a maximum of 1,000 rules for an individual access group. If you specify multiple rules for an access group, Tenable.io assigns an asset to the access group if the asset matches any of the rules. You can only add rules to access groups if the `all_assets` parameter is set to `false`.
	//
	// **Note:** When configuring rules for an `access_group_type` of `SCAN_TARGETS`, the asset attribute type (`rules.type`) must match the target format used in the related scan. For example, if a `SCAN_TARGETS` type access group rule filters on the FQDN/Hostname attribute, the related scan succeeds if the scan target is specified in FQDN or hostname format, but fails if the scan target is specified in IPv4 address format.
	Rules *[]struct {
		// The operator that specifies how Tenable.io matches the terms value to asset data.
		//
		// Possible operators include:
		//  - eq—Tenable.io matches the rule to assets based on an exact match of the specified term. Note: Tenable.io interprets the operator as `equals` for ipv4 rules that specify a single IP address, but interprets the operator as `contains` for ipv4 rules that specify an IP range or CIDR range.
		//  - match—Tenable.io matches the rule to assets based a partial match of the specified term.
		//  - starts—Tenable.io matches the rule to assets that start with the specified term.
		//  - ends—Tenable.io matches the rule to assets that end with the specified term.
		//  - set-has—Tenable.io matches the rule to assets based on the specified `tag_uuid`.
		//
		// For a complete list of operators by rule type, use the [GET /v2/access-groups/rules/filters](ref:io-v2-access-groups-list-rule-filters) endpoint.
		Operator *string `json:"operator,omitempty"`

		// The values that Tenable.io uses to match an asset to the rule. A term must correspond to the rule type.
		//
		// For example:
		//  - If the rule type is `aws_account`, the term is an AWS account ID.
		//  - If the rule type is `fqdn`, the term is a hostname or a fully-qualified domain name (FQDN).
		//  - If the rule type is `ipv4`, the term is an individual IPv4 address, a range of IPv4 addresses (for example, 192.0.2.57-192.0.2.60), or a CIDR range (for example, 192.0.2.57/24).
		//
		// For a complete list of supported values by rule type, use the [GET /v2/access-groups/rules/filters](ref:io-v2-access-groups-list-rule-filters) endpoint.
		//
		// If you specify multiple terms values, Tenable.io includes an asset in the access group if the asset's attributes match any of the terms in the rule.
		// <br >You can specify up to 100,000 terms per asset rule.
		Terms *[]string `json:"terms,omitempty"`

		// The type of asset rule. The asset rule type corresponds to the type of data you can specify in the `terms` parameter. For a complete list of supported rule types, use the [GET /v2/access-groups/filters](ref:io-v2-access-groups-list-filters) endpoint.
		Type *string `json:"type,omitempty"`
	} `json:"rules,omitempty"`
}

// IoV2AccessGroupsEditJSONBodyAccessGroupType defines parameters for IoV2AccessGroupsEdit.
type IoV2AccessGroupsEditJSONBodyAccessGroupType string

// IoV2AccessGroupsEditJSONBodyPrincipalsPermissions defines parameters for IoV2AccessGroupsEdit.
type IoV2AccessGroupsEditJSONBodyPrincipalsPermissions []string

// IoV2AccessGroupsEditJSONBodyPrincipalsType defines parameters for IoV2AccessGroupsEdit.
type IoV2AccessGroupsEditJSONBodyPrincipalsType string

// ExportsVulnsRequestExportJSONBody defines parameters for ExportsVulnsRequestExport.
type ExportsVulnsRequestExportJSONBody struct {
	// Specifies filters for exported vulnerabilities.
	//
	// **Note:** By default, vulnerability exports will only include vulnerabilities found or fixed within the last 30 days if no time-based filters (`indexed_at`, `last_fixed`, `last_found`, or `first_found`) are submitted with the request.
	Filters *struct {
		// Restricts search for vulnerabilities to assets assigned an IP address within the specified CIDR range. For example, 0.0.0.0/0 restricts the search to 0.0.0.1 and 255.255.255.254.
		CidrRange *string `json:"cidr_range,omitempty"`

		// Returns vulnerabilities that were first found between the specified date (in Unix time) and now.
		FirstFound *int64 `json:"first_found,omitempty"`

		// Returns vulnerabilities that were indexed into Tenable.io at the specified date and time (in Unix time).
		IndexedAt *int64 `json:"indexed_at,omitempty"`

		// Returns vulnerabilities that were fixed between the specified date (in Unix time) and now.
		LastFixed *int64 `json:"last_fixed,omitempty"`

		// Returns vulnerabilities that were last found between the specified date (in Unix time) and now.
		LastFound *int64 `json:"last_found,omitempty"`

		// The ID of the network object associated with scanners that detected the vulnerabilities you want to export. The default network ID is `00000000-0000-0000-0000-000000000000`. To determine the ID of a custom network, use the [GET /networks](ref:networks-list) endpoint. For more information about network objects, see [Manage Networks](doc:manage-networks-tio).
		NetworkId *string `json:"network_id,omitempty"`

		// A list of plugin families for which you want to filter the vulnerabilities returned in the vulnerability export. This filter is case-sensitive. If your request omits this parameter, the export includes all vulnerabilities regardless of plugin family. For a list of supported plugin family values, use the [GET /plugins/families](ref:io-plugins-families-list) endpoint.
		PluginFamily *[]string `json:"plugin_family,omitempty"`

		// A list of plugin IDs for which you want to filter the vulnerabilities returned in the vulnerability export. If your request omits this parameter, the export includes all vulnerabilities regardless of plugin ID.
		PluginId *[]int `json:"plugin_id,omitempty"`

		// The plugin type for which you want to filter the vulnerabilities returned in the vulnerability export. For example, `remote`, `local`, `combined`, etc. If your request omits this parameter, the export includes all vulnerabilities regardless of plugin type.
		PluginType *string `json:"plugin_type,omitempty"`

		// The severity of the vulnerabilities to include in the export. Defaults to all severity levels. The severity of a vulnerability is defined using the Common Vulnerability Scoring System (CVSS) base score. Supported array values are:
		//  - info—The vulnerability has a CVSS score of 0.
		//  - low—The vulnerability has a CVSS score between 0.1 and 3.9.
		//  - medium—The vulnerability has a CVSS score between 4.0 and 6.9.
		//  - high—The vulnerability has a CVSS score between 7.0 and 9.9.
		//  - critical—The vulnerability has a CVSS score of 10.0.
		Severity *[]string `json:"severity,omitempty"`

		// The start date (in Unix time) for the range of data you want to export. Use this filter in conjunction with the state filter as follows:
		//  - If the state filter is set to `open` or `reopened`, the export includes data for vulnerabilities that were seen on or after the since date you specify.
		//  - If the state filter is set to `fixed`, the export includes data for vulnerabilities that were fixed on or after the since date you specify.
		//  - If you do not include the state filter in your request, the export includes data for open and reopened vulnerabilities that were seen on or after the since date you specify, and fixed vulnerabilities that were fixed on or after the since date you specify.
		// **Note:** This filter cannot be used in conjunction with the `first_found`, `last_found`, or `last_fixed` filters.
		Since *int64 `json:"since,omitempty"`

		// The state of the vulnerabilities you want the export to include. Supported, case-insensitive values are:
		//  - open—The vulnerability is currently present on a host.
		//  - reopened—The vulnerability was previously marked as fixed on a host, but has returned.
		//  - fixed—The vulnerability was present on a host, but is no longer detected.
		//
		// This parameter is required if your request includes `first_found`, `last_found`, or `last_fixed` parameters. If your request omits this parameter, the export includes default states `open` and `reopened` only.
		State *[]string `json:"state,omitempty"`

		// Returns vulnerabilities on assets with the specified asset tags. The filter is defined as "tag", a period ("."), and the tag category name. The value of the filter is an array of tag values. For more information about tags, see the <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Settings/TagFormatAndApplication.htm" target="_blank">Tenable.io Vulnerability Management User Guide</a>.
		Tagcategory *[]string `json:"tag.<category>,omitempty"`

		// Returns vulnerabilities with the specified Vulnerability Priority Rating (VPR) score or scores. You can combine properties in this object to specify VPR ranges. For example, to export vulnerabilities greater than or equal to 9.0 but lesser than or equal to 9.9, the object would contain a `gte` property of 9.0 and an `lte` property of 9.9.
		//
		// For more information about VPR, see <a href="https://docs.tenable.com/tenableio/vulnerabilitymanagement/Content/Analysis/RiskMetrics.htm" target="_blank">Severity vs. VPR</a> in the <i>Tenable.io Vulnerability Management User Guide</i>.
		VprScore *struct {
			// Returns vulnerabilities with a VPR equal to the specified score or scores. This property cannot be combined with the following range operators: `lt`, `gt`, `lte`, or `gte`.
			Eq *[]float32 `json:"eq,omitempty"`

			// Returns vulnerabilities with a VPR greater than the specified score. This property cannot be combined with the `eq` property.
			Gt *float32 `json:"gt,omitempty"`

			// Returns vulnerabilities with a VPR greater than or equal to the specified score. This property cannot be combined with the `eq` property.
			Gte *float32 `json:"gte,omitempty"`

			// Returns vulnerabilities with a VPR lesser than the specified score. This property cannot be combined with the `eq` property.
			Lt *float32 `json:"lt,omitempty"`

			// Returns vulnerabilities with a VPR lesser than or equal to the specified score. This property cannot be combined with the `eq` property.
			Lte *float32 `json:"lte,omitempty"`

			// Returns vulnerabilities with a VPR not equal to the specified score or scores. This property can be combined with the `eq` property.
			Neq *[]float32 `json:"neq,omitempty"`
		} `json:"vpr_score,omitempty"`
	} `json:"filters,omitempty"`

	// Specifies whether or not to include unlicensed assets. The default is `false` when no parameter is specified.
	IncludeUnlicensed *bool `json:"include_unlicensed,omitempty"`

	// Specifies the number of assets used to chunk the vulnerabilities. The vulnerabilities export is split up by number of asset IDs in a chunk. The exported data of a chunk is the sum of all the vulnerabilities for each asset in that chunk. The range for number of assets in a chunk is a minimum of 50 (the default size) to a maximum of 5,000. If you specify a value outside this range, the system uses the upper or lower-bound value.
	NumAssets int32 `json:"num_assets"`
}

// WorkbenchesAssetsParams defines parameters for WorkbenchesAssets.
type WorkbenchesAssetsParams struct {
	// The number of days of data prior to and including today that should be returned.
	DateRange *int32 `json:"date_range,omitempty"`

	// The name of the filter to apply to the exported scan report. You can find available filters by using the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. If you specify the name of the filter, you must specify the operator as the filter.0.quality parameter and the value as the filter.0.value parameter. To use multiple filters, increment the `<INDEX>` portion of `filter.<INDEX>.filter`, for example, `filter.0.filter`. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Filter *string `json:"filter.0.filter,omitempty"`

	// The operator of the filter to apply to the exported scan report. You can find the operators for the filter using the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Quality *string `json:"filter.0.quality,omitempty"`

	// The value of the filter to apply to the exported scan report. You can find valid values for the filter in the 'control' attribute of the objects returned by the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	//
	//  **Note:** The value is case sensitive when used with the `match` (contains) or `nmatch` (does not contain) operators.
	Filter0Value *string `json:"filter.0.value,omitempty"`

	// For multiple filters, specifies whether to use the AND or the OR logical operator. The default is AND. For more information about this parameter, see [Workbench Filters](doc:workbench-filters).
	FilterSearchType *WorkbenchesAssetsParamsFilterSearchType `json:"filter.search_type,omitempty"`

	// A value specifying whether you want the returned data to include all fields (`full`) or only the default fields (`default`). The schema for this endpoint defines the `default` fields only. For a definition of the `full` fields, see [Common Asset Attributes](doc:common-asset-attributes).
	AllFields *string `json:"all_fields,omitempty"`
}

// WorkbenchesAssetsParamsFilterSearchType defines parameters for WorkbenchesAssets.
type WorkbenchesAssetsParamsFilterSearchType string

// WorkbenchesAssetsVulnerabilitiesParams defines parameters for WorkbenchesAssetsVulnerabilities.
type WorkbenchesAssetsVulnerabilitiesParams struct {
	// The number of days of data prior to and including today that should be returned.
	DateRange *int32 `json:"date_range,omitempty"`

	// The name of the filter to apply to the exported scan report. You can find available filters by using the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Filter *string `json:"filter.0.filter,omitempty"`

	// The operator of the filter to apply to the exported scan report. You can find the operators for the filter using the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint.For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Quality *string `json:"filter.0.quality,omitempty"`

	// The value of the filter to apply to the exported scan report. You can find valid values for the filter in the 'control' attribute of the objects returned by the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Value *string `json:"filter.0.value,omitempty"`

	// For multiple filters, specifies whether to use the AND or the OR logical operator. The default is AND. For more information about this parameter, see [Workbench Filters](doc:workbench-filters).
	FilterSearchType *WorkbenchesAssetsVulnerabilitiesParamsFilterSearchType `json:"filter.search_type,omitempty"`
}

// WorkbenchesAssetsVulnerabilitiesParamsFilterSearchType defines parameters for WorkbenchesAssetsVulnerabilities.
type WorkbenchesAssetsVulnerabilitiesParamsFilterSearchType string

// WorkbenchesAssetInfoParams defines parameters for WorkbenchesAssetInfo.
type WorkbenchesAssetInfoParams struct {
	// A value specifying whether you want the returned data to include all fields (`full`) or only the default fields (`default`).  The schema for this endpoint defines the `default` fields only. For a definition of the `full` fields, see [Common Asset Attributes](doc:common-asset-attributes).
	AllFields *string `json:"all_fields,omitempty"`
}

// WorkbenchesAssetVulnerabilitiesParams defines parameters for WorkbenchesAssetVulnerabilities.
type WorkbenchesAssetVulnerabilitiesParams struct {
	// The number of days of data prior to and including today that should be returned.
	DateRange *int32 `json:"date_range,omitempty"`

	// The name of the filter to apply to the exported scan report. You can find available filters by using the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Filter *string `json:"filter.0.filter,omitempty"`

	// The operator of the filter to apply to the exported scan report. You can find the operators for the filter using the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Quality *string `json:"filter.0.quality,omitempty"`

	// The value of the filter to apply to the exported scan report. You can find valid values for the filter in the 'control' attribute of the objects returned by the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Value *string `json:"filter.0.value,omitempty"`

	// For multiple filters, specifies whether to use the AND or the OR logical operator. The default is AND. For more information about this parameter, see [Workbench Filters](doc:workbench-filters).
	FilterSearchType *WorkbenchesAssetVulnerabilitiesParamsFilterSearchType `json:"filter.search_type,omitempty"`
}

// WorkbenchesAssetVulnerabilitiesParamsFilterSearchType defines parameters for WorkbenchesAssetVulnerabilities.
type WorkbenchesAssetVulnerabilitiesParamsFilterSearchType string

// WorkbenchesAssetVulnerabilityInfoParams defines parameters for WorkbenchesAssetVulnerabilityInfo.
type WorkbenchesAssetVulnerabilityInfoParams struct {
	// The number of days of data prior to and including today that should be returned.
	DateRange *int32 `json:"date_range,omitempty"`

	// The name of the filter to apply to the exported scan report. You can find available filters by using the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Filter *string `json:"filter.0.filter,omitempty"`

	// The operator of the filter to apply to the exported scan report. You can find the operators for the filter using the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Quality *string `json:"filter.0.quality,omitempty"`

	// The value of the filter to apply to the exported scan report. You can find valid values for the filter in the 'control' attribute of the objects returned by the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Value *string `json:"filter.0.value,omitempty"`

	// For multiple filters, specifies whether to use the AND or the OR logical operator. The default is AND. For more information about this parameter, see [Workbench Filters](doc:workbench-filters).
	FilterSearchType *WorkbenchesAssetVulnerabilityInfoParamsFilterSearchType `json:"filter.search_type,omitempty"`
}

// WorkbenchesAssetVulnerabilityInfoParamsFilterSearchType defines parameters for WorkbenchesAssetVulnerabilityInfo.
type WorkbenchesAssetVulnerabilityInfoParamsFilterSearchType string

// WorkbenchesAssetVulnerabilityOutputParams defines parameters for WorkbenchesAssetVulnerabilityOutput.
type WorkbenchesAssetVulnerabilityOutputParams struct {
	// The number of days of data prior to and including today that should be returned.
	DateRange *int32 `json:"date_range,omitempty"`

	// The name of the filter to apply to the exported scan report. You can find available filters by using the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Filter *string `json:"filter.0.filter,omitempty"`

	// The operator of the filter to apply to the exported scan report. You can find the operators for the filter using the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Quality *string `json:"filter.0.quality,omitempty"`

	// The value of the filter to apply to the exported scan report. You can find valid values for the filter in the 'control' attribute of the objects returned by the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Value *string `json:"filter.0.value,omitempty"`

	// For multiple filters, specifies whether to use the AND or the OR logical operator. The default is AND. For more information about this parameter, see [Workbench Filters](doc:workbench-filters).
	FilterSearchType *WorkbenchesAssetVulnerabilityOutputParamsFilterSearchType `json:"filter.search_type,omitempty"`
}

// WorkbenchesAssetVulnerabilityOutputParamsFilterSearchType defines parameters for WorkbenchesAssetVulnerabilityOutput.
type WorkbenchesAssetVulnerabilityOutputParamsFilterSearchType string

// WorkbenchesExportRequestParams defines parameters for WorkbenchesExportRequest.
type WorkbenchesExportRequestParams struct {
	// The file format to use (Nessus, HTML, PDF, or CSV).
	//
	// **Note:** Tag-based filters are supported for the `CSV` file format type only.
	Format WorkbenchesExportRequestParamsFormat `json:"format"`

	// The type of workbench report to be exported
	Report WorkbenchesExportRequestParamsReport `json:"report"`

	// The date (in unixtime) at which the exported results should begin to be included. Defaults to today.
	StartDate *int32 `json:"start_date,omitempty"`

	// Semicolon-separated list of chapters to include for vulnerabilities/hosts reports (vuln\_by\_plugin, vuln\_by\_asset, vuln\_hosts\_summary) or a single chapter for Executive Summary (exec\_summary). Currently, only vuln\_by\_asset is supported for .nessus workbench exports.
	Chapter string `json:"chapter"`

	// The number of days of data prior to and including start\_date that should be returned. If not specified, data for all dates is returned.
	DateRange *int32 `json:"date_range,omitempty"`

	// The name of the filter to apply to the exported scan report. You can find available filters by using the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Filter *string `json:"filter.0.filter,omitempty"`

	// The operator of the filter to apply to the exported scan report. You can find the operators for the filter using the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Quality *string `json:"filter.0.quality,omitempty"`

	// The value of the filter to apply to the exported scan report. You can find valid values for the filter in the 'control' attribute of the objects returned by the [GET /filters/workbenches/assets](ref:io-filters-assets-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Value *string `json:"filter.0.value,omitempty"`

	// For multiple filters, specifies whether to use the AND or the OR logical operator. The default is AND. For more information about this parameter, see [Workbench Filters](doc:workbench-filters).
	FilterSearchType *WorkbenchesExportRequestParamsFilterSearchType `json:"filter.search_type,omitempty"`

	// When `true`, Tenable.io returns only a minimal subset of scan details for each result, excluding plugin attributes. In this case, only plugin\_output and vulnerability\_state fields are always returned; first\_found, last\_found and last\_fixed are also returned if possible.
	MinimumVulnInfo *WorkbenchesExportRequestParamsMinimumVulnInfo `json:"minimum_vuln_info,omitempty"`

	// A plugin ID. Restricts the export data to vulnerabilities that only the specified plugin detects.
	PluginId *int32 `json:"plugin_id,omitempty"`

	// The UUID of an asset. Restricts the export data to findings on the specified asset only.
	AssetId *string `json:"asset_id,omitempty"`
}

// WorkbenchesExportRequestParamsFormat defines parameters for WorkbenchesExportRequest.
type WorkbenchesExportRequestParamsFormat string

// WorkbenchesExportRequestParamsReport defines parameters for WorkbenchesExportRequest.
type WorkbenchesExportRequestParamsReport string

// WorkbenchesExportRequestParamsFilterSearchType defines parameters for WorkbenchesExportRequest.
type WorkbenchesExportRequestParamsFilterSearchType string

// WorkbenchesExportRequestParamsMinimumVulnInfo defines parameters for WorkbenchesExportRequest.
type WorkbenchesExportRequestParamsMinimumVulnInfo bool

// WorkbenchesVulnerabilitiesParams defines parameters for WorkbenchesVulnerabilities.
type WorkbenchesVulnerabilitiesParams struct {
	// Lists only those vulnerabilities older than a certain number of days.
	Age *int32 `json:"age,omitempty"`

	// Lists only authenticated vulnerabilities.
	Authenticated *bool `json:"authenticated,omitempty"`

	// The number of days of data prior to and including today that should be returned.
	DateRange *int32 `json:"date_range,omitempty"`

	// Lists only exploitable vulnerabilities.
	Exploitable *bool `json:"exploitable,omitempty"`

	// The name of the filter to apply to the exported scan report. You can find available filters by using the [GET /filters/workbenches/vulnerabilities](ref:io-filters-vulnerabilities-workbench-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	//
	// **Note:** There is a limit of 10 filters. A `400 Bad Request` error is returned if you exceed this limit.
	Filter0Filter *string `json:"filter.0.filter,omitempty"`

	// The operator of the filter to apply to the exported scan report. You can find the operators for the filter using the [GET /filters/workbenches/vulnerabilities](ref:io-filters-vulnerabilities-workbench-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Quality *string `json:"filter.0.quality,omitempty"`

	// The value of the filter to apply to the exported scan report. You can find valid values for the filter in the 'control' attribute of the objects returned by the [GET /filters/workbenches/vulnerabilities](ref:io-filters-vulnerabilities-workbench-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	//
	// **Note:** There is a limit of 10 filter values per filter. A `400 Bad Request` error is returned if you exceed this limit.
	Filter0Value *string `json:"filter.0.value,omitempty"`

	// For multiple filters, specifies whether to use the AND or the OR logical operator. The default is AND. For more information about this parameter, see [Workbench Filters](doc:workbench-filters).
	FilterSearchType *WorkbenchesVulnerabilitiesParamsFilterSearchType `json:"filter.search_type,omitempty"`

	// Lists only those vulnerabilities with a remediation path.
	Resolvable *bool `json:"resolvable,omitempty"`

	// Lists only vulnerabilities of a specific severity (critical, high, medium or low)
	Severity *WorkbenchesVulnerabilitiesParamsSeverity `json:"severity,omitempty"`
}

// WorkbenchesVulnerabilitiesParamsFilterSearchType defines parameters for WorkbenchesVulnerabilities.
type WorkbenchesVulnerabilitiesParamsFilterSearchType string

// WorkbenchesVulnerabilitiesParamsSeverity defines parameters for WorkbenchesVulnerabilities.
type WorkbenchesVulnerabilitiesParamsSeverity string

// WorkbenchesVulnerabilityInfoParams defines parameters for WorkbenchesVulnerabilityInfo.
type WorkbenchesVulnerabilityInfoParams struct {
	// The number of days of data prior to and including today that should be returned.
	DateRange *int32 `json:"date_range,omitempty"`

	// The name of the filter to apply to the exported scan report. You can find available filters by using the [GET /filters/workbenches/vulnerabilities](ref:io-filters-vulnerabilities-workbench-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Filter *string `json:"filter.0.filter,omitempty"`

	// The operator of the filter to apply to the exported scan report. You can find the operators for the filter using the [GET /filters/workbenches/vulnerabilities](ref:io-filters-vulnerabilities-workbench-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Quality *string `json:"filter.0.quality,omitempty"`

	// The value of the filter to apply to the exported scan report. You can find valid values for the filter in the 'control' attribute of the objects returned by the [GET /filters/workbenches/vulnerabilities](ref:io-filters-vulnerabilities-workbench-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Value *string `json:"filter.0.value,omitempty"`

	// For multiple filters, specifies whether to use the AND or the OR logical operator. The default is AND. For more information about this parameter, see [Workbench Filters](doc:workbench-filters).
	FilterSearchType *WorkbenchesVulnerabilityInfoParamsFilterSearchType `json:"filter.search_type,omitempty"`
}

// WorkbenchesVulnerabilityInfoParamsFilterSearchType defines parameters for WorkbenchesVulnerabilityInfo.
type WorkbenchesVulnerabilityInfoParamsFilterSearchType string

// WorkbenchesVulnerabilityOutputParams defines parameters for WorkbenchesVulnerabilityOutput.
type WorkbenchesVulnerabilityOutputParams struct {
	// The number of days of data prior to and including today that should be returned.
	DateRange *int32 `json:"date_range,omitempty"`

	// The name of the filter to apply to the exported scan report. You can find available filters by using the [GET /filters/workbenches/vulnerabilities](ref:io-filters-vulnerabilities-workbench-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Filter *string `json:"filter.0.filter,omitempty"`

	// The operator of the filter to apply to the exported scan report. You can find the operators for the filter using the [GET /filters/workbenches/vulnerabilities](ref:io-filters-vulnerabilities-workbench-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Quality *string `json:"filter.0.quality,omitempty"`

	// The value of the filter to apply to the exported scan report. You can find valid values for the filter in the 'control' attribute of the objects returned by the [GET /filters/workbenches/vulnerabilities](ref:io-filters-vulnerabilities-workbench-list) endpoint. For more information about the format of this parameter, see [Workbench Filters](doc:workbench-filters).
	Filter0Value *string `json:"filter.0.value,omitempty"`

	// For multiple filters, specifies whether to use the AND or the OR logical operator. The default is AND. For more information about this parameter, see [Workbench Filters](doc:workbench-filters).
	FilterSearchType *WorkbenchesVulnerabilityOutputParamsFilterSearchType `json:"filter.search_type,omitempty"`
}

// WorkbenchesVulnerabilityOutputParamsFilterSearchType defines parameters for WorkbenchesVulnerabilityOutput.
type WorkbenchesVulnerabilityOutputParamsFilterSearchType string

// IoV1AccessGroupsCreateJSONRequestBody defines body for IoV1AccessGroupsCreate for application/json ContentType.
type IoV1AccessGroupsCreateJSONRequestBody IoV1AccessGroupsCreateJSONBody

// IoV1AccessGroupsEditJSONRequestBody defines body for IoV1AccessGroupsEdit for application/json ContentType.
type IoV1AccessGroupsEditJSONRequestBody IoV1AccessGroupsEditJSONBody

// AssetsBulkUpdateAcrJSONRequestBody defines body for AssetsBulkUpdateAcr for application/json ContentType.
type AssetsBulkUpdateAcrJSONRequestBody AssetsBulkUpdateAcrJSONBody

// AssetsBulkDeleteJSONRequestBody defines body for AssetsBulkDelete for application/json ContentType.
type AssetsBulkDeleteJSONRequestBody AssetsBulkDeleteJSONBody

// AssetsBulkMoveJSONRequestBody defines body for AssetsBulkMove for application/json ContentType.
type AssetsBulkMoveJSONRequestBody AssetsBulkMoveJSONBody

// VulnerabilitiesImportV2JSONRequestBody defines body for VulnerabilitiesImportV2 for application/json ContentType.
type VulnerabilitiesImportV2JSONRequestBody VulnerabilitiesImportV2JSONBody

// ExportsAssetsRequestExportJSONRequestBody defines body for ExportsAssetsRequestExport for application/json ContentType.
type ExportsAssetsRequestExportJSONRequestBody ExportsAssetsRequestExportJSONBody

// IoExportsComplianceCreateJSONRequestBody defines body for IoExportsComplianceCreate for application/json ContentType.
type IoExportsComplianceCreateJSONRequestBody IoExportsComplianceCreateJSONBody

// CredentialsCreateJSONRequestBody defines body for CredentialsCreate for application/json ContentType.
type CredentialsCreateJSONRequestBody CredentialsCreateJSONBody

// CredentialsUpdateJSONRequestBody defines body for CredentialsUpdate for application/json ContentType.
type CredentialsUpdateJSONRequestBody CredentialsUpdateJSONBody

// ExclusionsCreateJSONRequestBody defines body for ExclusionsCreate for application/json ContentType.
type ExclusionsCreateJSONRequestBody ExclusionsCreateJSONBody

// ExclusionsImportJSONRequestBody defines body for ExclusionsImport for application/json ContentType.
type ExclusionsImportJSONRequestBody ExclusionsImportJSONBody

// ExclusionsEditJSONRequestBody defines body for ExclusionsEdit for application/json ContentType.
type ExclusionsEditJSONRequestBody ExclusionsEditJSONBody

// IoFiltersAssetsListV2JSONRequestBody defines body for IoFiltersAssetsListV2 for application/json ContentType.
type IoFiltersAssetsListV2JSONRequestBody IoFiltersAssetsListV2JSONBody

// IoFiltersVulnerabilitiesWorkbenchListV2JSONRequestBody defines body for IoFiltersVulnerabilitiesWorkbenchListV2 for application/json ContentType.
type IoFiltersVulnerabilitiesWorkbenchListV2JSONRequestBody IoFiltersVulnerabilitiesWorkbenchListV2JSONBody

// FoldersCreateJSONRequestBody defines body for FoldersCreate for application/json ContentType.
type FoldersCreateJSONRequestBody FoldersCreateJSONBody

// FoldersEditJSONRequestBody defines body for FoldersEdit for application/json ContentType.
type FoldersEditJSONRequestBody FoldersEditJSONBody

// AssetsImportJSONRequestBody defines body for AssetsImport for application/json ContentType.
type AssetsImportJSONRequestBody AssetsImportJSONBody

// VulnerabilitiesImportJSONRequestBody defines body for VulnerabilitiesImport for application/json ContentType.
type VulnerabilitiesImportJSONRequestBody VulnerabilitiesImportJSONBody

// NetworksCreateJSONRequestBody defines body for NetworksCreate for application/json ContentType.
type NetworksCreateJSONRequestBody NetworksCreateJSONBody

// NetworksUpdateJSONRequestBody defines body for NetworksUpdate for application/json ContentType.
type NetworksUpdateJSONRequestBody NetworksUpdateJSONBody

// NetworksAssignScannerBulkJSONRequestBody defines body for NetworksAssignScannerBulk for application/json ContentType.
type NetworksAssignScannerBulkJSONRequestBody NetworksAssignScannerBulkJSONBody

// PermissionsChangeJSONRequestBody defines body for PermissionsChange for application/json ContentType.
type PermissionsChangeJSONRequestBody PermissionsChangeJSONBody

// PoliciesCreateJSONRequestBody defines body for PoliciesCreate for application/json ContentType.
type PoliciesCreateJSONRequestBody PoliciesCreateJSONBody

// PoliciesImportJSONRequestBody defines body for PoliciesImport for application/json ContentType.
type PoliciesImportJSONRequestBody PoliciesImportJSONBody

// ScannerGroupsCreateJSONRequestBody defines body for ScannerGroupsCreate for application/json ContentType.
type ScannerGroupsCreateJSONRequestBody ScannerGroupsCreateJSONBody

// ScannerGroupsEditJSONRequestBody defines body for ScannerGroupsEdit for application/json ContentType.
type ScannerGroupsEditJSONRequestBody ScannerGroupsEditJSONBody

// IoScannerGroupsUpdateRoutesJSONRequestBody defines body for IoScannerGroupsUpdateRoutes for application/json ContentType.
type IoScannerGroupsUpdateRoutesJSONRequestBody IoScannerGroupsUpdateRoutesJSONBody

// BulkAddAgentsJSONRequestBody defines body for BulkAddAgents for application/json ContentType.
type BulkAddAgentsJSONRequestBody BulkAddAgentsJSONBody

// IoAgentBulkOperationsGroupDirectiveJSONRequestBody defines body for IoAgentBulkOperationsGroupDirective for application/json ContentType.
type IoAgentBulkOperationsGroupDirectiveJSONRequestBody IoAgentBulkOperationsGroupDirectiveJSONBody

// BulkRemoveAgentsJSONRequestBody defines body for BulkRemoveAgents for application/json ContentType.
type BulkRemoveAgentsJSONRequestBody BulkRemoveAgentsJSONBody

// IoAgentBulkOperationsAddToNetworkJSONRequestBody defines body for IoAgentBulkOperationsAddToNetwork for application/json ContentType.
type IoAgentBulkOperationsAddToNetworkJSONRequestBody IoAgentBulkOperationsAddToNetworkJSONBody

// IoAgentBulkOperationsDirectiveJSONRequestBody defines body for IoAgentBulkOperationsDirective for application/json ContentType.
type IoAgentBulkOperationsDirectiveJSONRequestBody IoAgentBulkOperationsDirectiveJSONBody

// IoAgentBulkOperationsRemoveFromNetworkJSONRequestBody defines body for IoAgentBulkOperationsRemoveFromNetwork for application/json ContentType.
type IoAgentBulkOperationsRemoveFromNetworkJSONRequestBody IoAgentBulkOperationsRemoveFromNetworkJSONBody

// BulkUnlinkAgentsJSONRequestBody defines body for BulkUnlinkAgents for application/json ContentType.
type BulkUnlinkAgentsJSONRequestBody BulkUnlinkAgentsJSONBody

// ScannersEditJSONRequestBody defines body for ScannersEdit for application/json ContentType.
type ScannersEditJSONRequestBody ScannersEditJSONBody

// AgentGroupsCreateJSONRequestBody defines body for AgentGroupsCreate for application/json ContentType.
type AgentGroupsCreateJSONRequestBody AgentGroupsCreateJSONBody

// AgentGroupsConfigureJSONRequestBody defines body for AgentGroupsConfigure for application/json ContentType.
type AgentGroupsConfigureJSONRequestBody AgentGroupsConfigureJSONBody

// AgentConfigEditJSONRequestBody defines body for AgentConfigEdit for application/json ContentType.
type AgentConfigEditJSONRequestBody AgentConfigEditJSONBody

// AgentExclusionsCreateJSONRequestBody defines body for AgentExclusionsCreate for application/json ContentType.
type AgentExclusionsCreateJSONRequestBody AgentExclusionsCreateJSONBody

// AgentExclusionsEditJSONRequestBody defines body for AgentExclusionsEdit for application/json ContentType.
type AgentExclusionsEditJSONRequestBody AgentExclusionsEditJSONBody

// ScannersToggleLinkStateJSONRequestBody defines body for ScannersToggleLinkState for application/json ContentType.
type ScannersToggleLinkStateJSONRequestBody ScannersToggleLinkStateJSONBody

// ScannersControlScansJSONRequestBody defines body for ScannersControlScans for application/json ContentType.
type ScannersControlScansJSONRequestBody ScannersControlScansJSONBody

// ScansCreateJSONRequestBody defines body for ScansCreate for application/json ContentType.
type ScansCreateJSONRequestBody ScansCreateJSONBody

// IoScansCheckAutoTargetsJSONRequestBody defines body for IoScansCheckAutoTargets for application/json ContentType.
type IoScansCheckAutoTargetsJSONRequestBody IoScansCheckAutoTargetsJSONBody

// ScansImportJSONRequestBody defines body for ScansImport for application/json ContentType.
type ScansImportJSONRequestBody ScansImportJSONBody

// IoScansRemediationCreateJSONRequestBody defines body for IoScansRemediationCreate for application/json ContentType.
type IoScansRemediationCreateJSONRequestBody IoScansRemediationCreateJSONBody

// ScansConfigureJSONRequestBody defines body for ScansConfigure for application/json ContentType.
type ScansConfigureJSONRequestBody ScansConfigureJSONBody

// ScansCopyJSONRequestBody defines body for ScansCopy for application/json ContentType.
type ScansCopyJSONRequestBody ScansCopyJSONBody

// IoScansCredentialsConvertJSONRequestBody defines body for IoScansCredentialsConvert for application/json ContentType.
type IoScansCredentialsConvertJSONRequestBody IoScansCredentialsConvertJSONBody

// ScansExportRequestJSONRequestBody defines body for ScansExportRequest for application/json ContentType.
type ScansExportRequestJSONRequestBody ScansExportRequestJSONBody

// ScansLaunchJSONRequestBody defines body for ScansLaunch for application/json ContentType.
type ScansLaunchJSONRequestBody ScansLaunchJSONBody

// ScansScheduleJSONRequestBody defines body for ScansSchedule for application/json ContentType.
type ScansScheduleJSONRequestBody ScansScheduleJSONBody

// ScansReadStatusJSONRequestBody defines body for ScansReadStatus for application/json ContentType.
type ScansReadStatusJSONRequestBody ScansReadStatusJSONBody

// TagsAssignAssetTagsJSONRequestBody defines body for TagsAssignAssetTags for application/json ContentType.
type TagsAssignAssetTagsJSONRequestBody TagsAssignAssetTagsJSONBody

// TagsCreateTagCategoryJSONRequestBody defines body for TagsCreateTagCategory for application/json ContentType.
type TagsCreateTagCategoryJSONRequestBody TagsCreateTagCategoryJSONBody

// TagsEditTagCategoryJSONRequestBody defines body for TagsEditTagCategory for application/json ContentType.
type TagsEditTagCategoryJSONRequestBody TagsEditTagCategoryJSONBody

// TagsCreateTagValueJSONRequestBody defines body for TagsCreateTagValue for application/json ContentType.
type TagsCreateTagValueJSONRequestBody TagsCreateTagValueJSONBody

// TagsDeleteTagValuesBulkJSONRequestBody defines body for TagsDeleteTagValuesBulk for application/json ContentType.
type TagsDeleteTagValuesBulkJSONRequestBody TagsDeleteTagValuesBulkJSONBody

// TagsUpdateTagValueJSONRequestBody defines body for TagsUpdateTagValue for application/json ContentType.
type TagsUpdateTagValueJSONRequestBody TagsUpdateTagValueJSONBody

// TargetGroupsCreateJSONRequestBody defines body for TargetGroupsCreate for application/json ContentType.
type TargetGroupsCreateJSONRequestBody TargetGroupsCreateJSONBody

// TargetGroupsEditJSONRequestBody defines body for TargetGroupsEdit for application/json ContentType.
type TargetGroupsEditJSONRequestBody TargetGroupsEditJSONBody

// IoV2AccessGroupsCreateJSONRequestBody defines body for IoV2AccessGroupsCreate for application/json ContentType.
type IoV2AccessGroupsCreateJSONRequestBody IoV2AccessGroupsCreateJSONBody

// IoV2AccessGroupsEditJSONRequestBody defines body for IoV2AccessGroupsEdit for application/json ContentType.
type IoV2AccessGroupsEditJSONRequestBody IoV2AccessGroupsEditJSONBody

// ExportsVulnsRequestExportJSONRequestBody defines body for ExportsVulnsRequestExport for application/json ContentType.
type ExportsVulnsRequestExportJSONRequestBody ExportsVulnsRequestExportJSONBody

